<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: Fréchet Shorcuts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.6.devel</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Fréchet Shorcuts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Isabelle Sivignon</dd></dl>
<p>Table of contents:</p>
<ol type="1">
<li><a class="el" href="moduleFrechetShortcut.html#sectOverview">Overview</a><ol type="a">
<li><a class="el" href="moduleFrechetShortcut.html#subsectFrechet">Fréchet distance</a></li>
<li><a class="el" href="moduleFrechetShortcut.html#subsectCurve">Curve simplification problem</a></li>
</ol>
</li>
<li><a class="el" href="moduleFrechetShortcut.html#sectAlgo">Guaranteed algorithm using an approximated distance</a><ol type="a">
<li><a class="el" href="moduleFrechetShortcut.html#subsectDef">Definitions and overall algorithm</a></li>
<li><a class="el" href="moduleFrechetShortcut.html#subsectWidth">Updating the width efficiently</a></li>
<li><a class="el" href="moduleFrechetShortcut.html#subsectBackpath">Updating the backpath length efficiently</a></li>
<li><a class="el" href="moduleFrechetShortcut.html#subsectDirections">Memorizing the directions for which there exists a too long backpath</a></li>
</ol>
</li>
<li><a class="el" href="moduleFrechetShortcut.html#sectQuality">Quality of the result and complexity analysis</a><ol type="a">
<li><a class="el" href="moduleFrechetShortcut.html#subsectGuarantee">A guaranteed algorithm</a></li>
<li><a class="el" href="moduleFrechetShortcut.html#subsectComplexity">Complexity</a></li>
</ol>
</li>
<li><a class="el" href="moduleFrechetShortcut.html#sectImplementation">Implementation in DGtal</a></li>
</ol>
<h1><a class="anchor" id="sectOverview"></a>
Overview</h1>
<p>The algorithm implemented in the class <a class="el" href="classDGtal_1_1FrechetShortcut.html" title="Aim: On-line computation Computation of the longest shortcut according to the Fréchet distance for a ...">DGtal::FrechetShortcut</a> is the one presented in the article [1]. We present here the basic ideas of the algorithm and at the end, give pointers to the relative structures used in the implementation.</p>
<p>Given a polygonal curve, the curve simplification problem consists in computing another polygonal curve that (i) approximates the original curve, (ii) satisfies a given error criterion, (iii) with as few vertices as possible. This problem arises in a wide range of applications, such as geographic information systems (GIS), computer graphics or computer vision, where the management of the level of details is of crucial importance to save memory space or to speed-up analysis algorithms.</p>
<p>Given a 4- or 8-connected digital curve and a maximum error, we propose an algorithm that computes a simplification of the curve (a polygonal curve) such that the Fréchet distance between the original and the simplified curve is less than the error. The Fréchet distance is known to nicely measure the similarity between two curves. It can be intuitively defined considering a man walking his dog. Each protagonist walks along a path, and controls its speed independently, but cannot go backwards. The Fréchet distance between the two pathes is the minimal length of the leash required.</p>
<p>The algorithm implemented uses an approximation of the Fréchet distance, but a guarantee over the quality of the simplification is proved. Moreover, even if the theoretical complexity of the algorithm is in O(n log(n)), experiments show a linear behaviour in practice.</p>
<h2><a class="anchor" id="subsectFrechet"></a>
Fréchet distance</h2>
<p>Given two curves \( f \) and \( g \) specified by functions \( f:[0,1] \rightarrow \mathbb{R}^2 \) and \(g:[0,1] \rightarrow \mathbb{R}^2 \), and two non-decreasing continuous functions \( \alpha:[0,1] \rightarrow [0,1] \) and \( \beta:[0,1] \rightarrow [0,1] \) with \( \alpha(0)=0,\alpha(1)=1,\beta(0)=0,\beta(1)=1 \), the <b>Fréchet distance</b> \( \delta_F(f,g) \) between two curves f and g is defined as</p>
<p>\( \delta_F(f,g)=\inf_{\alpha,\beta} \max_{0\leq t \leq 1} d(f(\alpha(t)),g(\beta(t))) \)</p>
<p>As illustrated in the figure below, contrary to the Hausdorff distance denoted by \( \delta_H(f,g) \), the Fréchet distance takes into account the course of the curves.</p>
<div class="image">
<img src="hausdorff.png" alt="hausdorff.png"/>
<div class="caption">
Difference between the Fréchet distance and the Hausdorff distance</div></div>
 <h2><a class="anchor" id="subsectCurve"></a>
Curve simplification problem</h2>
<p>Given a polygonal curve \( P=\langle p_1,\dots p_n\rangle \), A curve \( P&#39;=\langle p_{i_1},\dots p_{i_k}\rangle \) with \( 1=i_1 &lt; \dots &lt; i_k=n \) is said to <b>simplify</b> the curve \( P \). \( P(i,j) \) denotes the subpath from \( p_i \) to \( p_j \).</p>
<p>Given a pair of indices \( 1 \leq i \leq j \leq n \), \( \delta_F(p_ip_j,P) \) denotes the Fréchet distance between the segment \( p_ip_j \) and the part \( P(i,j) \) of the curve. For the sake of clarity, the simplified notation \( error(i,j) = \delta_F(p_ip_j,P) \) will sometimes be used. We also say that \( p_ip_j \) is a <b>shortcut</b>.</p>
<p>In other words, the vertices of \( P&#39; \) form a subset of the vertices of \( P \), and the computation of \( P&#39; \) comes down to the selection of "shortcuts" \( p_ip_j \).</p>
<div class="image">
<img src="curve_simplification.png" alt="curve_simplification.png"/>
<div class="caption">
The red curve P' is a simplification of the blue curve P</div></div>
 <p>All in all, to <b>find \( P&#39; \) an \( \varepsilon \)-simplification of</b> \( P \) we have to:</p>
<ol type="1">
<li><b>Find shortcuts \( p_ip_j \) such that \( error(i,j) = \delta_F(p_ip_j,P) \leq \varepsilon \)</b></li>
<li><b>Minimize the number of vertices of \( P&#39; \)</b>.</li>
</ol>
<p>The following nice local property of the Fréchet distance proved in [3] will be very useful to prove a guarantee on the quality of the result produced by our algorithm (see illustration below):</p>
<p>Let \( P=\{p_1, p_2, \dots , p_n\} \) be a polygonal curve. \ For all \( i, j, l, r, 1 \leq i\leq l \leq r \leq j \leq n \), \( error(l,r) \leq 2 error(i,j) \).</p>
<p>In other words, the shortcuts of any \( \frac{\varepsilon}{2} \)-simplification cannot strictly enclose the shortcuts of a \( \varepsilon \)-simplification.</p>
<div class="image">
<img src="local.png" alt="local.png"/>
<div class="caption">
Illustration of the local property.</div></div>
 <h1><a class="anchor" id="sectAlgo"></a>
Guaranteed algorithm using an approximated distance</h1>
<h2><a class="anchor" id="subsectDef"></a>
Definitions and overall algorithm</h2>
<p>Using the exact Fréchet distance appears to be too expensive to design an efficient algorithm. Instead, we use an approximation of the Fréchet distance proposed in [2]. More precisely, they show that \(error(i,j)\) can be upper and lower bounded by functions of two values namely \(\omega(i,j)\) and \(b(i,j)\). \(\omega(i,j)\) is the width of the points of \(P(i,j)\) in the direction \(\overrightarrow{p_ip_j}\). \(b(i,j)\) is the length of the longest backpath in the direction \(\overrightarrow{p_ip_j}\).</p>
<div class="image">
<img src="def_width_backpath.png" alt="def_width_backpath.png"/>
<div class="caption">
Illustration of the definition of the width and the backpath length.</div></div>
 <div class="image">
<img src="def_width_backpath_2.png" alt="def_width_backpath_2.png"/>
<div class="caption">
When a new point is considered, the width and backpath lengths may totally change.</div></div>
 We have the following property from [2]:</p>
<p>The Fréchet error of a shortcut \(p_ip_j\) satisfies:</p>
<div class="image">
<img src="approx_distance.png" alt="approx_distance.png"/>
</div>
 Using this Fréchet distance approximation to greedily compute a shortcut requires a fast update of the quantities \(\omega(i,j)\) and \(b(i,j)\) when a new point is taken into account. This is not an easy task since these values can change drastically as illustrated above.</p>
<h2><a class="anchor" id="subsectWidth"></a>
Updating the width efficiently</h2>
<p>Instead of updating \(\omega(i,j)\), it is enough to consider the maximal distance between any point of \(P(i,j)\) and the vector \(\overrightarrow{p_ip_j}\). This is done using the algorithm of Chan and Chin [4] illustrated below:</p>
<p>Given an origin point \(p_i&quot;\) and a set of points \(P(i,j)\) we construct the set \(S_{ij}\) of straight lines \(l\) going through \(p_i\) such that \(\max_{p \in P(i,j)}d(p,l) \leq r\). As a result, deciding whether \(d_{max}(i,j)\) is lower than \(r\) or not is equivalent to checking whether the straight line \((p_i,p_j)\) belongs to \(S_{ij}\) or not.</p>
<p>All in all, the update of the cone and the decision are both done in constant time.</p>
<div class="image">
<img src="update_width.png" alt="update_width.png"/>
<div class="caption">
The cone (dark gray) is computed incrementally as the intersection of the light gray cones.</div></div>
 <h2><a class="anchor" id="subsectBackpath"></a>
Updating the backpath length efficiently</h2>
<p>This update is trickier. When a new point \(p_{j+1}\) is considered, we want to ckeck if there exists a backpath longer than a threshold in the direction \(\overrightarrow{p_ip_j}\). Let us first give some definitions:</p>
<div class="image">
<img src="definition1.png" alt="definition1.png"/>
</div>
 To do so, we consider a set of points named <em>occulters</em> which are the furthest points for a given direction:</p>
<div class="image">
<img src="definition_occulter.png" alt="definition_occulter.png"/>
</div>
 We can prove easily (see [1]) that the origin of the longest backpath is an occulter.</p>
<div class="image">
<img src="occulters.png" alt="occulters.png"/>
<div class="caption">
Occulters for the direction &lt;i&gt;d&lt;/i&gt; in red. Green arrows represent backpathes: the length of the plain arrows is to be checked, whereas we know that the backpathes represented by dashed arrows are not the longest ones.</div></div>
 Considering whether the last movement \(\overrightarrow{p_jp_{j+1}}\) is forward or backward in the direction \(\overrightarrow{p_ip_j}\), we can decide if there is a new backpath possibly longer than the threshold or not. This is done according to Algorithm 2 below.</p>
<div class="image">
<img src="algo2.png" alt="algo2.png"/>
</div>
 According to Algorithm 1 we see that Algorithm 2 must be applied for any possible direction for a given curve \(P\), which is computationally expensive. However, the computation of backpathes can be mutualized in the case of digital curves. Indeed for a digital curve, the set of elementary shifts \(\overrightarrow{p_jp_{j+1}}\) is well defined and it is actually possible to cluster the set of directions such that given an elementary shift \(e\), this shift is either forward (positive) or backward (negative) for all the directions of the cluster.</p>
<div class="image">
<img src="clusters.png" alt="clusters.png"/>
<div class="caption">
Left: The directions of the plane are clustered into 8 octants. For instance, direction</div></div>
<p> <em>d</em> is in octant <em>0</em>. Right: Illustration of the positive (or forward) elementary shifts for each octant."
@image latex clusters.png "Left: The directions of the plane are clustered into 8 octants. For instance, direction <em>d</em> is in octant <em>0</em>. Right: Illustration of the positive (or forward) elementary shifts for each octant."</p>
<p>If we now go back to Algorithm 2, we see that the result of the test lines 2-3 is the same for all the directions of a given octant. This test can thus be done jointly for all the directions of an octant. Nevertheless, to determine if a new point \(p_k\) is the new active occulter (the furthest point for the direction studied), the projection of the current active occulter and the point \(p_k\) on a direction are compared: the furthest of the two points is the active occulter. There, for any two points \(p_k\) and \(q\) the result of this comparison is not the same for all the directions of a given octant. This fact is illustrated in the figures below for the octant \(0\):</p>
<p>for any point \(q\) in the grey area, and for any direction in octant \(0\), \(q\) is after \(p\).</p>
<p>for any point \(q\) in the dashed area, and for any direction in octant \(0\), \(p\) is after \(q\).</p>
<p>in the white area, the order changes, as illustrated below.</p>
<div class="image">
<img src="zones.png" alt="zones.png"/>
</div>
 <div class="image">
<img src="ordre_projections.png" alt="ordre_projections.png"/>
<div class="caption">
For two points &lt;i&gt;p&lt;/i&gt; and &lt;i&gt;q&lt;/i&gt; and a direction &lt;i&gt;&lt;/i&gt;: on the left, &lt;i&gt;q&lt;/i&gt; is &lt;i&gt;after&lt;/i&gt; &lt;i&gt;p&lt;/i&gt;, and is the active occulter for direction &lt;i&gt;&lt;/i&gt;, whereas on the right, &lt;i&gt;p&lt;/i&gt; is after &lt;i&gt;q&lt;/i&gt; and is the active occulter.</div></div>
 Algorithm 3 below puts together these observations to update the list of active occulters for one octant.</p>
<div class="image">
<img src="algo3.png" alt="algo3.png"/>
</div>
 <h2><a class="anchor" id="subsectDirections"></a>
Memorizing the directions for which there exists a too long backpath</h2>
<p>From Algorithm 1, we see that the length of the longest backpath is tested for each new point, which defines a new direction. Moreover, we see from Algorithm 2 line 6 that for each negative shift, we can have as many backpathes as active occulters. All in all, testing individually all the possible backpathes when a new point is added is too expensive. To solve this problem, we propose to maintain a ``set'' of the directions for which there exists a backpath of length greater than the error \(\varepsilon\).</p>
<p>This set actually consists in a list of intervals: for a given backpath of length <em>l</em> and a given error \(\varepsilon\), the interval of directions for which the projection of the backpath is longer than \(\varepsilon\) is computed easily. The union of all these intervals is stored.</p>
<h1><a class="anchor" id="sectQuality"></a>
Quality of the result and complexity analysis</h1>
<h2><a class="anchor" id="subsectGuarantee"></a>
A guaranteed algorithm</h2>
<p>An important issue when designing an algorithm that is known not to be optimal is to prove that the result of this algorithm is not so far from the optimal. In this work, the optimal solution is to compute the \(\varepsilon\)-simplification of a digital curve P according to the Fréchet distance with a minimum number of vertices. The algorithm we propose here is not optimal for two reasons:</p>
<p>it is greedy: the simplification is computed from a given starting point, in a given scanning order.</p>
<p>the distance used is an approximation of the Fréchet distance.</p>
<p>However, we prove that the number of vertices of the simplified curve computed by our algorithm is upper bounded by a function of the optimal solution:</p>
<div class="image">
<img src="lemma3.png" alt="lemma3.png"/>
</div>
 For more details about this proof, please refer to [1].</p>
<h2><a class="anchor" id="subsectComplexity"></a>
Complexity</h2>
<p>The theoretical complexity of this algorithm is \(\mathcal{O}(n\log(n_i))\), for a digital curve of \(n\) points. \(n_i\) is the number of intervals used to store the directions for which there exist a backpath of length greater than the error. \(n_i\) is upper bounded by \(n\). Nevertheless, experiments on noisy shapes show that the general behaviour of the algorithm in linear in time.</p>
<h1><a class="anchor" id="sectImplementation"></a>
Implementation in DGtal</h1>
<p>In <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a>, the <a class="el" href="classDGtal_1_1FrechetShortcut.html" title="Aim: On-line computation Computation of the longest shortcut according to the Fréchet distance for a ...">FrechetShortcut</a> should be used with a Curve object, using its PointsRange, as in the example below:</p>
<div class="fragment"><div class="line">  Curve::PointsRange r = c.getPointsRange(); </div>
<div class="line">  </div>
<div class="line">  <span class="keyword">typedef</span> FrechetShortcut&lt;Curve::PointsRange::ConstIterator,int&gt; Shortcut;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Computation of one shortcut</span></div>
<div class="line">  Shortcut s(error);</div>
<div class="line">  </div>
<div class="line">  s.init( r.begin() );</div>
<div class="line">  <span class="keywordflow">while</span> ( ( s.end() != r.end() )</div>
<div class="line">          &amp;&amp;( s.extendForward() ) ) {}</div>
<div class="line">  </div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Computation of a greedy segmentation</span></div>
<div class="line">  </div>
<div class="line">  <span class="keyword">typedef</span> GreedySegmentation&lt;Shortcut&gt; Segmentation;</div>
<div class="line">  </div>
<div class="line">  Segmentation theSegmentation( r.begin(), r.end(), Shortcut(error) );</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// the segmentation is computed here</span></div>
<div class="line">  Segmentation::SegmentComputerIterator it = theSegmentation.begin();</div>
<div class="line">  Segmentation::SegmentComputerIterator itEnd = theSegmentation.end();</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> ( ; it != itEnd; ++it) {</div>
<div class="line">    s=Shortcut(*it);</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">    board &lt;&lt; s; </div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  board.<a class="codeRef" href="classLibBoard_1_1Board.html#a0bb157ee0eb70eb9281634e9ed311818">saveEPS</a>(<span class="stringliteral">&quot;FrechetShortcutExample.eps&quot;</span>, <a class="codeRef" href="classLibBoard_1_1Board.html#a77cdb88a32ac2d3ad62baef58353bfc2af144212fe6448c8c8a41644a48c6c8ff">Board2D::BoundingBox</a>, 5000 ); </div>
<div class="line"></div>
</div><!-- fragment --><p> The function <a class="el" href="classDGtal_1_1FrechetShortcut.html#a2523fa362d834bd812f76015d80c9a89">DGtal::FrechetShortcut::extendForward()</a> is called when a new point is added to the current shortcut. It calls <a class="el" href="classDGtal_1_1FrechetShortcut.html#aa4c41abcf69826987341fa76fd562404">DGtal::FrechetShortcut::updateWidth()</a> and <a class="el" href="classDGtal_1_1FrechetShortcut.html#a81765392e396d27887936b188dec78ed">DGtal::FrechetShortcut::updateBackpath()</a>.</p>
<p>The function <a class="el" href="classDGtal_1_1FrechetShortcut.html#aa4c41abcf69826987341fa76fd562404">DGtal::FrechetShortcut::updateWidth()</a> implements the update of the width \(\omega(i,j)\) and uses the subclass <a class="el" href="classDGtal_1_1FrechetShortcut_1_1Cone.html">DGtal::FrechetShortcut::Cone</a> for the cone definition and manipulation.</p>
<p>The length of the longest backpath is managed in the function <a class="el" href="classDGtal_1_1FrechetShortcut.html#a81765392e396d27887936b188dec78ed">DGtal::FrechetShortcut::updateBackpath()</a>. It updates a vector of $8$ backpaths, one per each octant. The subclass <a class="el" href="classDGtal_1_1FrechetShortcut_1_1Backpath.html">DGtal::FrechetShortcut::Backpath</a> contains all the necessary structures</p>
<ul>
<li><a class="el" href="classDGtal_1_1FrechetShortcut_1_1Backpath.html#aa53187611932f13a1a8d6c354be7832a">DGtal::FrechetShortcut::Backpath::myQuad</a> is the octant number</li>
<li><a class="el" href="classDGtal_1_1FrechetShortcut_1_1Backpath.html#aed565b5ff02618a291e95d8028a3241d">DGtal::FrechetShortcut::Backpath::myOcculters</a> is the list of occulters</li>
<li><a class="el" href="classDGtal_1_1FrechetShortcut_1_1Backpath.html#ae4f4c72bde709c060d3ca943a2a9ed46">DGtal::FrechetShortcut::Backpath::addPositivePoint()</a> is called when the next elementary move is forward for the octant</li>
<li><a class="el" href="classDGtal_1_1FrechetShortcut_1_1Backpath.html#afae1ee4c6f2546462c4aa1d014c13652">DGtal::FrechetShortcut::Backpath::addNegativePoint()</a> is called when the next elementary move is backward for the octant: it implements Algorithm 2 and calls updateOcculters()</li>
<li><a class="el" href="classDGtal_1_1FrechetShortcut_1_1Backpath.html#a87636293904d561c0d05154472694ec3">DGtal::FrechetShortcut::Backpath::updateOcculters()</a> implements Algorithm 3</li>
<li>the list of interval used to memorize the directions for which there exist a too long backpath is implemented through <a class="el" href="classDGtal_1_1FrechetShortcut_1_1Backpath.html#a1aab30992a5fa5db754d67087fd0236a">DGtal::FrechetShortcut::Backpath::myForbiddenIntervals</a> using the Boost Interval Container Library (<a href="http://www.boost.org/doc/libs/1_52_0/libs/icl">http://www.boost.org/doc/libs/1_52_0/libs/icl</a>). It is updated with the function <a class="el" href="classDGtal_1_1FrechetShortcut_1_1Backpath.html#aa29bfbf02f5e88939689494fea1f21f1">DGtal::FrechetShortcut::Backpath::updateIntervals()</a>.</li>
</ul>
<p>An output using the DGtal::Board mecanism is provided (see example above to output an eps file).</p>
<dl class="section user"><dt>References</dt><dd></dd></dl>
<ol type="1">
<li>Sivignon, I.: A near-linear time guaranteed algorithm for digital curve simplification under the Fréchet distance. In: Discrete Geometry for Computer Imagery 2011, Nancy, France. LNCS 6607, pp. 33-345. Springer (2011) <a href="http://link.springer.com/chapter/10.1007/978-3-642-19867-0_28">http://link.springer.com/chapter/10.1007/978-3-642-19867-0_28</a></li>
</ol>
<ol type="1">
<li>Abam, M.A., de Berg, M., Hachenberger, P., Zarei, A.: Streaming algorithms for line simplification. In: SCG ’07: Symp. on Comput. geometry. pp. 175–183. ACM (2007)</li>
</ol>
<ol type="1">
<li>Agarwal, P.K., Har-Peled, S., Mustafa, N.H., Wang, Y.: Near-linear time approximation algorithms for curve simplification. Algorithmica 42(3-4), 203–219 (2005)</li>
</ol>
<ol type="1">
<li>Chan, W.S., Chin, F.: Approximation of polygonal curves with minimum number of line segments. In: ISAAC ’92: Symp. on Algorithms and Computation. pp. 378– 387. Springer-Verlag (1992)</li>
</ol>
<ol type="1">
<li>Imai, H., Iri, M.: Polygonal approximations of a curve: formulations and algorithms. In: Computational Morphology. pp. 71–86. Elsevier Science (1988) </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 19 2012 19:10:44 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
