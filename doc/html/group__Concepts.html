<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: DGtal Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.6.devel</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">DGtal Concepts</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDGtal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html">DGtal</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPositiveIrreducibleFraction.html">DGtal::CPositiveIrreducibleFraction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers, with gcd(p,q)=1.  <a href="structDGtal_1_1CPositiveIrreducibleFraction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBackInsertable.html">DGtal::CBackInsertable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserter. Back Insertion Sequence are refinements of <a class="el" href="structDGtal_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>. They require more services than <a class="el" href="structDGtal_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>, for instance read services or erase services.  <a href="structDGtal_1_1CBackInsertable.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalOutputRange.html">DGtal::CBidirectionalOutputRange&lt; T, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of bidirectional range which require that a reverse output iterator exists.  <a href="structDGtal_1_1CBidirectionalOutputRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html">DGtal::CBidirectionalOutputRangeFromPoint&lt; T, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with an routputIterator() method from a point.  <a href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalRange.html">DGtal::CBidirectionalRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional range.  <a href="structDGtal_1_1CBidirectionalRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html">DGtal::CBidirectionalRangeFromPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1CBidirectionalRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html">DGtal::CConstBidirectionalRangeFromPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const bidirectional range with a begin() method from a point.  <a href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstSinglePassRange.html">DGtal::CConstSinglePassRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a const range.  <a href="structDGtal_1_1CConstSinglePassRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstSinglePassRangeFromPoint.html">DGtal::CConstSinglePassRangeFromPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const single pass range with a begin() method from a point.  <a href="structDGtal_1_1CConstSinglePassRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CLabel.html">DGtal::CLabel&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define the concept of <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> labels. Models of <a class="el" href="structDGtal_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible, assignable and equality comparable.">CLabel</a> can be default-constructible, assignable and equality comparable.  <a href="structDGtal_1_1CLabel.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPredicate.html">DGtal::CPredicate&lt; T, TElement &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate function, ie. a functor mapping a domain into the set of booleans.  <a href="structDGtal_1_1CPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CQuantity.html">DGtal::CQuantity&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of quantity in <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a>.  <a href="structDGtal_1_1CQuantity.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassOutputRange.html">DGtal::CSinglePassOutputRange&lt; T, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range which require that an output iterator exists.  <a href="structDGtal_1_1CSinglePassOutputRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassOutputRangeFromPoint.html">DGtal::CSinglePassOutputRangeFromPoint&lt; T, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a outputIterator() method from a point.  <a href="structDGtal_1_1CSinglePassOutputRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassRange.html">DGtal::CSinglePassRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a range.  <a href="structDGtal_1_1CSinglePassRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassRangeFromPoint.html">DGtal::CSinglePassRangeFromPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1CSinglePassRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUnaryFunctor.html">DGtal::CUnaryFunctor&lt; X, A, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a unary functor, which associates arguments to results.  <a href="structDGtal_1_1CUnaryFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html">DGtal::CBidirectionalSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">CSegment</a> that can extend itself in the two possible directions.  <a href="structDGtal_1_1CBidirectionalSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html">DGtal::CDynamicBidirectionalSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">CSegment</a> that can extend and retract itself in either direction.  <a href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html">DGtal::CDynamicSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">CSegment</a> that can extend and retract itself (in the direction that is relative to the underlying iterator).  <a href="structDGtal_1_1CDynamicSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CForwardSegmentComputer.html">DGtal::CForwardSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a forward segment computer. Like any model of <a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer, ie. a model of CSegmentFactory t...">CIncrementalSegmentComputer</a>, it can control its own extension (in the direction that is relative to the underlying iterator) so that an implicit predicate P remains true. However, contrary to models of <a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer, ie. a model of CSegmentFactory t...">CIncrementalSegmentComputer</a>, it garantees that P is also true for any subrange of the whole segment at any time. This extra constraint is necessary to be able to incrementally check whether or not the segment is maximal.  <a href="structDGtal_1_1CForwardSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html">DGtal::CIncrementalSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an incremental segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegmentFactory.html" title="Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct...">CSegmentFactory</a> that can, in addition, incrementally check whether or not an implicit predicate P is true. In other words, it can control its own extension from a range of one element (in the direction that is relative to the underlying iterator) so that an implicit predicate P remains true.  <a href="structDGtal_1_1CIncrementalSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSegment.html">DGtal::CSegment&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment, ie. a valid and not empty range.  <a href="structDGtal_1_1CSegment.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSegmentFactory.html">DGtal::CSegmentFactory&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct instances of its own type or of derived type.  <a href="structDGtal_1_1CSegmentFactory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CGlobalGeometricEstimator.html">DGtal::CGlobalGeometricEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range so as to return one estimated quantity for the whole range.  <a href="structDGtal_1_1CGlobalGeometricEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CLocalGeometricEstimator.html">DGtal::CLocalGeometricEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range so as to return one estimated quantity for each element of the range (or a given subrange).  <a href="structDGtal_1_1CLocalGeometricEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSegmentComputerEstimator.html">DGtal::CSegmentComputerEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept is a refinement of <a class="el" href="structDGtal_1_1CLocalGeometricEstimator.html" title="Aim: This concept describes an object that can process a range so as to return one estimated quantity...">CLocalGeometricEstimator</a> devoted to the estimation of a geometric quantiy along a segment detected by a segment computer.  <a href="structDGtal_1_1CSegmentComputerEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConvolutionWeights.html">DGtal::CConvolutionWeights&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines models of centered convolution kernel used for normal vector integration for instance.  <a href="structDGtal_1_1CConvolutionWeights.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CNormalVectorEstimator.html">DGtal::CNormalVectorEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of estimator of normal vector along digital surfaces.  <a href="structDGtal_1_1CNormalVectorEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSeparableMetric.html">DGtal::CSeparableMetric&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstImage.html">DGtal::CConstImage&lt; I &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImage.html">DGtal::CImage&lt; I &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CTrivialConstImage.html">DGtal::CTrivialConstImage&lt; I &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CTrivialImage.html">DGtal::CTrivialImage&lt; I &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">DGtal::CDrawableWithBoard2D&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">DGtal::CDrawableWithDisplay3D&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CColorMap.html">DGtal::CColorMap&lt; CMap &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a color map. A color map converts a value within a given range into an RGB triple.  <a href="structDGtal_1_1CColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBoundedInteger.html">DGtal::CBoundedInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CBoundedInteger.html" title="Aim: The concept CBoundedInteger specifies what are the bounded integer numbers. Hence, it is a refinement of CInteger Concept ensuring that the numbers are bounded.">CBoundedInteger</a> specifies what are the bounded integer numbers. Hence, it is a refinement of <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> Concept ensuring that the numbers are bounded.  <a href="structDGtal_1_1CBoundedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCommutativeRing.html">DGtal::CCommutativeRing&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring.  <a href="structDGtal_1_1CCommutativeRing.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanRing.html">DGtal::CEuclideanRing&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operator.  <a href="structDGtal_1_1CEuclideanRing.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CInteger.html">DGtal::CInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> specifies what are the usual integer numbers, more precisely the ones that are representable on a computer.  <a href="structDGtal_1_1CInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointEmbedder.html">DGtal::CPointEmbedder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A point embedder is a mapping from digital points to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CPointEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointFunctor.html">DGtal::CPointFunctor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a functor on points.  <a href="structDGtal_1_1CPointFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointPredicate.html">DGtal::CPointPredicate&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a point.  <a href="structDGtal_1_1CPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSignedInteger.html">DGtal::CSignedInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Signed Integer.  <a href="structDGtal_1_1CSignedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSpace.html">DGtal::CSpace&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a digital space, ie a cartesian product of integer lines.  <a href="structDGtal_1_1CSpace.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUnsignedInteger.html">DGtal::CUnsignedInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Unsigned Integer.  <a href="structDGtal_1_1CUnsignedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CWithGradientMap.html">DGtal::CWithGradientMap&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Such object provides a gradient map that associates to each argument some real vector.  <a href="structDGtal_1_1CWithGradientMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSet.html">DGtal::CDigitalSet&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of points within the given domain. This set of points is modifiable by the user.  <a href="structDGtal_1_1CDigitalSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalBoundedShape.html">DGtal::CDigitalBoundedShape&lt; TShape &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalOrientedShape.html">DGtal::CDigitalOrientedShape&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for points on a <a class="el" href="classDGtal_1_1SpaceND.html" title="Aim: SpaceND is a utility class that defines the fundamental structure of a Digital Space in ND...">SpaceND</a>. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1CDigitalOrientedShape.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">DGtal::CEuclideanBoundedShape&lt; TShape &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html">DGtal::CEuclideanOrientedShape&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for real points. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1CEuclideanOrientedShape.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImplicitFunction.html">DGtal::CImplicitFunction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes any function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1CImplicitFunction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImplicitFunctionDiff1.html">DGtal::CImplicitFunctionDiff1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes a 1-differentiable function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1CImplicitFunctionDiff1.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CAdjacency.html">DGtal::CAdjacency&lt; Adj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> defines an elementary adjacency relation between points of a digital space.  <a href="structDGtal_1_1CAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCellEmbedder.html">DGtal::CCellEmbedder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCellularGridSpaceND.html">DGtal::CCellularGridSpaceND&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian product, cells have a cubic shape that depends on the dimension: 0-cells are points, 1-cells are unit segments, 2-cells are squares, 3-cells are cubes, and so on.  <a href="structDGtal_1_1CCellularGridSpaceND.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html">DGtal::CDigitalSurfaceContainer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1CDigitalSurfaceContainer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceEmbedder.html">DGtal::CDigitalSurfaceEmbedder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A digital surface embedder is a specialized mapping from signed cells to Euclidean points. It adds inner types to functor as well as a method to access the digital surface.  <a href="structDGtal_1_1CDigitalSurfaceEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceTracker.html">DGtal::CDigitalSurfaceTracker&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1CDigitalSurfaceTracker.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDomainAdjacency.html">DGtal::CDomainAdjacency&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Refines the concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by telling that the adjacency is specific to a given domain of the embedding digital space.  <a href="structDGtal_1_1CDomainAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSCellEmbedder.html">DGtal::CSCellEmbedder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A cell embedder is a mapping from signed cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CSCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSurfelPredicate.html">DGtal::CSurfelPredicate&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a surfel.  <a href="structDGtal_1_1CSurfelPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUndirectedSimpleGraph.html">DGtal::CUndirectedSimpleGraph&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1CUndirectedSimpleGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUndirectedSimpleLocalGraph.html">DGtal::CUndirectedSimpleLocalGraph&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1CUndirectedSimpleLocalGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CVertexMap.html">DGtal::CVertexMap&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: models of <a class="el" href="structDGtal_1_1CVertexMap.html" title="Aim: models of CVertexMap concept implement mapping between graph vertices and values.">CVertexMap</a> concept implement mapping between graph vertices and values.  <a href="structDGtal_1_1CVertexMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CVertexPredicate.html">DGtal::CVertexPredicate&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a vertex.  <a href="structDGtal_1_1CVertexPredicate.html#details">More...</a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 19 2012 19:10:45 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
