<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: DGtal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.6.devel</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">DGtal Namespace Reference<div class="ingroups"><a class="el" href="group__Concepts.html">DGtal Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDGtal_1_1BasicColorToScalarFunctors"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1BasicColorToScalarFunctors.html">BasicColorToScalarFunctors</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1ConceptUtils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1ConceptUtils.html">ConceptUtils</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1deprecated"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1deprecated.html">deprecated</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1detail.html">detail</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1details"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1details.html">details</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1experimental"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1experimental.html">experimental</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1Z2i"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1Z2i.html">Z2i</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1Z3i"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1Z3i.html">Z3i</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html">ClosedIntegerHalfPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A half-space specified by a vector N and a constant c. The half-space is the set \( \{ P \in Z^2, N.P \le c \} \).  <a href="structDGtal_1_1ClosedIntegerHalfPlane.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPositiveIrreducibleFraction.html">CPositiveIrreducibleFraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers, with gcd(p,q)=1.  <a href="structDGtal_1_1CPositiveIrreducibleFraction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntegerComputer.html">IntegerComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class gathers several types and methods to make computation with integers.  <a href="classDGtal_1_1IntegerComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LatticePolytope2D.html">LatticePolytope2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane. The list of points must follow the <b>clockwise</b> ordering.  <a href="classDGtal_1_1LatticePolytope2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LighterSternBrocot.html">LighterSternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1LighterSternBrocot.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightSternBrocot.html">LightSternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1LightSternBrocot.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements basic functions on modular arithmetic.  <a href="classDGtal_1_1ModuloComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a digital straight line.  <a href="classDGtal_1_1Pattern.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SternBrocot.html">SternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1SternBrocot.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalIteratorArchetype.html">CBidirectionalIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of BidirectionalIterator.  <a href="structDGtal_1_1CBidirectionalIteratorArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html">CConstBidirectionalIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of ConstBidirectionalIterator.  <a href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CForwardIteratorArchetype.html">CForwardIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of ForwardIterator.  <a href="structDGtal_1_1CForwardIteratorArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MinFunctor.html">MinFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MaxFunctor.html">MaxFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MinusFunctor.html">MinusFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AbsFunctor.html">AbsFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultFunctor.html">DefaultFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple default functor that just returns its argument.  <a href="structDGtal_1_1DefaultFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstValueFunctor.html">ConstValueFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor that returns a constant value (0 by default).  <a href="classDGtal_1_1ConstValueFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CastFunctor.html">CastFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor using the static cast operator.  <a href="structDGtal_1_1CastFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Composer.html">Composer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a new Functor from the composition of two other functors.  <a href="classDGtal_1_1Composer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Thresholder.html">Thresholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small functor with an operator () that compares one value to a threshold value according to two bool template parameters.  <a href="classDGtal_1_1Thresholder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Thresholder_3_01T_00_01false_00_01false_01_4.html">Thresholder&lt; T, false, false &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Thresholder_3_01T_00_01false_00_01true_01_4.html">Thresholder&lt; T, false, true &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Thresholder_3_01T_00_01true_00_01false_01_4.html">Thresholder&lt; T, true, false &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Thresholder_3_01T_00_01true_00_01true_01_4.html">Thresholder&lt; T, true, true &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PredicateCombiner.html">PredicateCombiner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the given binary functor returns true for the two Predicates given at construction.  <a href="structDGtal_1_1PredicateCombiner.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntervalThresholder.html">IntervalThresholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small functor with an operator () that compares one value to an interval.  <a href="classDGtal_1_1IntervalThresholder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Pair1st.html">Pair1st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor that returns the first member of a pair.  <a href="classDGtal_1_1Pair1st.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Pair2nd.html">Pair2nd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor that returns the second member of a pair.  <a href="classDGtal_1_1Pair2nd.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Pair1stMutator.html">Pair1stMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple unary functor that returns a reference on the first member of a pair in order to update it.  <a href="classDGtal_1_1Pair1stMutator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Pair2ndMutator.html">Pair2ndMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple unary functor that returns a reference on the first member of a pair in order to update it.  <a href="classDGtal_1_1Pair2ndMutator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Bits.html">Bits</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBackInsertable.html">CBackInsertable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserter. Back Insertion Sequence are refinements of <a class="el" href="structDGtal_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>. They require more services than <a class="el" href="structDGtal_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>, for instance read services or erase services.  <a href="structDGtal_1_1CBackInsertable.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalOutputRange.html">CBidirectionalOutputRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of bidirectional range which require that a reverse output iterator exists.  <a href="structDGtal_1_1CBidirectionalOutputRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html">CBidirectionalOutputRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with an routputIterator() method from a point.  <a href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalRange.html">CBidirectionalRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional range.  <a href="structDGtal_1_1CBidirectionalRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html">CBidirectionalRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1CBidirectionalRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html">CConstBidirectionalRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const bidirectional range with a begin() method from a point.  <a href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstSinglePassRange.html">CConstSinglePassRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a const range.  <a href="structDGtal_1_1CConstSinglePassRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstSinglePassRangeFromPoint.html">CConstSinglePassRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const single pass range with a begin() method from a point.  <a href="structDGtal_1_1CConstSinglePassRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Circulator.html">Circulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as in a loop. The increment (resp. decrement if at least bidirectionnal) operator encapsulates the validity test and the assignement to the first (resp. last) iterator of a given range. For instance, the pre-increment operator does:  <a href="classDGtal_1_1Circulator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CLabel.html">CLabel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define the concept of <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> labels. Models of <a class="el" href="structDGtal_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible, assignable and equality comparable.">CLabel</a> can be default-constructible, assignable and equality comparable.  <a href="structDGtal_1_1CLabel.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Clock.html">Clock</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithDisplay3D.html">DrawableWithDisplay3D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithBoard2D.html">DrawableWithBoard2D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagFalse.html">TagFalse</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagTrue.html">TagTrue</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagUnknown.html">TagUnknown</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate.html">Negate</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate_3_01TagTrue_01_4.html">Negate&lt; TagTrue &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate_3_01TagFalse_01_4.html">Negate&lt; TagFalse &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DummyObject.html">DummyObject</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adapts any iterator so that operator* returns another element than the one pointed to by the iterator.  <a href="classDGtal_1_1ConstIteratorAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstRangeAdapter.html">ConstRangeAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1ConstRangeAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstRangeFromPointAdapter.html">ConstRangeFromPointAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts any bidirectional range and provides services to iterate over it (in a read-only manner).  <a href="classDGtal_1_1ConstRangeFromPointAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Smart pointer based on reference counts.  <a href="classDGtal_1_1CountedPtr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Copy on write shared pointer.  <a href="classDGtal_1_1CowPtr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPredicate.html">CPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate function, ie. a functor mapping a domain into the set of booleans.  <a href="structDGtal_1_1CPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CQuantity.html">CQuantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of quantity in <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a>.  <a href="structDGtal_1_1CQuantity.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassOutputRange.html">CSinglePassOutputRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range which require that an output iterator exists.  <a href="structDGtal_1_1CSinglePassOutputRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassOutputRangeFromPoint.html">CSinglePassOutputRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a outputIterator() method from a point.  <a href="structDGtal_1_1CSinglePassOutputRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassRange.html">CSinglePassRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a range.  <a href="structDGtal_1_1CSinglePassRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassRangeFromPoint.html">CSinglePassRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1CSinglePassRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUnaryFunctor.html">CUnaryFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a unary functor, which associates arguments to results.  <a href="structDGtal_1_1CUnaryFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IOException.html">IOException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InputException.html">InputException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConnectivityException.html">ConnectivityException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MemoryException.html">MemoryException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InfiniteNumberException.html">InfiniteNumberException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW.html">POW</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW_3_01X_00_011_01_4.html">POW&lt; X, 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2.html">LOG2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2_3_012_01_4.html">LOG2&lt; 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2_3_011_01_4.html">LOG2&lt; 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IndexedListWithBlocks.html">IndexedListWithBlocks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a mixed list/array structure which is useful in some context. It is essentially a list of blocks.  <a href="classDGtal_1_1IndexedListWithBlocks.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html">InputIteratorWithRankOnSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence. The sequence is smartly copied within the iterator. Hence, the given sequence need not to persist during the visit. Since it is only an input sequence, it is not necessary to give a valid sequence when creating the end() iterator.  <a href="classDGtal_1_1InputIteratorWithRankOnSequence.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IteratorAdapter.html">IteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adapts any lvalue iterator so that operator* returns a member on the element pointed to by the iterator, instead the element itself.  <a href="classDGtal_1_1IteratorAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsCirculator.html">IsCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Checks whether type  is a circular or a classical iterator.  <a href="structDGtal_1_1IsCirculator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorType.html">IteratorCirculatorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the type of  as a nested type.  <a href="structDGtal_1_1IteratorCirculatorType.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits.html">IteratorCirculatorTagTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the category of the iterator (resp. circulator) {<a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>,<a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>,<a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>}.  <a href="structDGtal_1_1IteratorCirculatorTagTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1forward__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::forward_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1bidirectional__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1random__access__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::random_access_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01boost_1_1forward__traversal__tag_01_4.html">IteratorCirculatorTagTraits&lt; boost::forward_traversal_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01boost_1_1bidirectional__traversal__tag_01_4.html">IteratorCirculatorTagTraits&lt; boost::bidirectional_traversal_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01boost_1_1random__access__traversal__tag_01_4.html">IteratorCirculatorTagTraits&lt; boost::random_access_traversal_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01boost_1_1detail_1_1iterator__category__with__trav7c3e00e2eb7908d2ae91f03c79a71172.html">IteratorCirculatorTagTraits&lt; boost::detail::iterator_category_with_traversal&lt; std::input_iterator_tag, boost::forward_traversal_tag &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01boost_1_1detail_1_1iterator__category__with__trav8d48ed628c0166e9654f17f910e91a4c.html">IteratorCirculatorTagTraits&lt; boost::detail::iterator_category_with_traversal&lt; std::input_iterator_tag, boost::bidirectional_traversal_tag &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01boost_1_1detail_1_1iterator__category__with__trave963740ba0c806f27d968227f12a68a7.html">IteratorCirculatorTagTraits&lt; boost::detail::iterator_category_with_traversal&lt; std::input_iterator_tag, boost::random_access_traversal_tag &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides nested types for both iterators and circulators: Type, Category, Value, Difference, Pointer and Reference.  <a href="structDGtal_1_1IteratorCirculatorTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits_3_01T_01_5_01_4.html">IteratorCirculatorTraits&lt; T * &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits_3_01T_01const_01_5_01_4.html">IteratorCirculatorTraits&lt; T const * &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LabelledMap.html">LabelledMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a map label -&gt; data, where the label is an integer between 0 and a constant L-1. It is based on a binary coding of labels and a mixed list/array structure. The assumption is that the number of used labels is much less than L. The objective is to minimize the memory usage.  <a href="classDGtal_1_1LabelledMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Labels.html">Labels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Stores a set of labels in {O..L-1} as a sequence of bits.  <a href="classDGtal_1_1Labels.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OpInSTLContainers.html">OpInSTLContainers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of an adapter for erase and insert methods of STL containers so that they not only work for the iterator type, but also for the reverse_iterator type.  <a href="structDGtal_1_1OpInSTLContainers.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OpInSTLContainers_3_01Container_00_01std_1_1reverse__iterator_3_01typename_01Container_1_1iterator_01_4_01_4.html">OpInSTLContainers&lt; Container, std::reverse_iterator&lt; typename Container::iterator &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be changed (shifted, reversed, ...). Useful for the arithmetic minimum length polygon (AMLP).  <a href="classDGtal_1_1OrderedAlphabet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OutputIteratorAdapter.html">OutputIteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Adapts an output iterator i with a unary functor f, both given at construction, so that the element pointed to by i is updated with a given value through f.  <a href="classDGtal_1_1OutputIteratorAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html">OwningOrAliasingPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class describes a smart pointer that is, given the constructor called by the user, either an alias pointer on existing data or an owning pointer on a copy.  <a href="classDGtal_1_1OwningOrAliasingPtr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ReverseIterator.html">ReverseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adapts any bidirectional iterator so that operator++ calls operator&ndash; and vice versa.  <a href="classDGtal_1_1ReverseIterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleConstRange.html">SimpleConstRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstRange that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleConstRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html">SimpleRandomAccessConstRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html">SimpleRandomAccessRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html" title="Aim: refined concept of single pass range with a begin() method from a point.">CBidirectionalRangeFromPoint</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Statistic.html">Statistic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class processes a set of sample values for one variable and can then compute different statistics, like sample mean, sample variance, sample unbiased variance, etc. It is minimalistic for space efficiency. For multiple variables, sample storage and others, see Statistics class.  <a href="classDGtal_1_1Statistic.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1StdMapRebinder.html">StdMapRebinder</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Trace.html">Trace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of basic methods to trace out messages with indentation levels.  <a href="classDGtal_1_1Trace.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Class to implement trace writers.  <a href="classDGtal_1_1TraceWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements trace prefix for color terminals.  <a href="classDGtal_1_1TraceWriterTerm.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connected points (x,y) such that mu &lt;= ax - by &lt; mu + omega.  <a href="classDGtal_1_1ArithmeticalDSS.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">ArithmeticalDSS3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Dynamic recognition of a 3d-digital straight segment (DSS)  <a href="classDGtal_1_1ArithmeticalDSS3d.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a 2D contour convolved by some binomial. It computes first and second order derivatives so as to be able to estimate tangent and curvature. In particular, it smoothes digital contours but could be used for other kind of contours.  <a href="classDGtal_1_1BinomialConvolver.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html">TangentFromBinomialConvolverFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a functor for getting the tangent vector of a binomial convolver.  <a href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html">CurvatureFromBinomialConvolverFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a functor for getting the tangent vector of a binomial convolver.  <a href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BinomialConvolverEstimator.html">BinomialConvolverEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class encapsulates a <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> and a functor on <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> so as to be a model of <a class="el" href="structDGtal_1_1CLocalGeometricEstimator.html" title="Aim: This concept describes an object that can process a range so as to return one estimated quantity...">CLocalGeometricEstimator</a>.  <a href="classDGtal_1_1BinomialConvolverEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html">CBidirectionalSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">CSegment</a> that can extend itself in the two possible directions.  <a href="structDGtal_1_1CBidirectionalSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html">CDynamicBidirectionalSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">CSegment</a> that can extend and retract itself in either direction.  <a href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html">CDynamicSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">CSegment</a> that can extend and retract itself (in the direction that is relative to the underlying iterator).  <a href="structDGtal_1_1CDynamicSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CForwardSegmentComputer.html">CForwardSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a forward segment computer. Like any model of <a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer, ie. a model of CSegmentFactory t...">CIncrementalSegmentComputer</a>, it can control its own extension (in the direction that is relative to the underlying iterator) so that an implicit predicate P remains true. However, contrary to models of <a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer, ie. a model of CSegmentFactory t...">CIncrementalSegmentComputer</a>, it garantees that P is also true for any subrange of the whole segment at any time. This extra constraint is necessary to be able to incrementally check whether or not the segment is maximal.  <a href="structDGtal_1_1CForwardSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html">CIncrementalSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an incremental segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegmentFactory.html" title="Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct...">CSegmentFactory</a> that can, in addition, incrementally check whether or not an implicit predicate P is true. In other words, it can control its own extension from a range of one element (in the direction that is relative to the underlying iterator) so that an implicit predicate P remains true.  <a href="structDGtal_1_1CIncrementalSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CombinatorialDSS.html">CombinatorialDSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="classDGtal_1_1CombinatorialDSS.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSegment.html">CSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment, ie. a valid and not empty range.  <a href="structDGtal_1_1CSegment.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSegmentFactory.html">CSegmentFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct instances of its own type or of derived type.  <a href="structDGtal_1_1CSegmentFactory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Best Linear Unbiased Two step length estimator.  <a href="classDGtal_1_1BLUELocalLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CGlobalGeometricEstimator.html">CGlobalGeometricEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range so as to return one estimated quantity for the whole range.  <a href="structDGtal_1_1CGlobalGeometricEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CLocalGeometricEstimator.html">CLocalGeometricEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range so as to return one estimated quantity for each element of the range (or a given subrange).  <a href="structDGtal_1_1CLocalGeometricEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CompareLocalEstimators.html">CompareLocalEstimators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor to compare two local geometric estimators.  <a href="structDGtal_1_1CompareLocalEstimators.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSegmentComputerEstimator.html">CSegmentComputerEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept is a refinement of <a class="el" href="structDGtal_1_1CLocalGeometricEstimator.html" title="Aim: This concept describes an object that can process a range so as to return one estimated quantity...">CLocalGeometricEstimator</a> devoted to the estimation of a geometric quantiy along a segment detected by a segment computer.  <a href="structDGtal_1_1CSegmentComputerEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the length of the resulting (not uniquely defined) polygon.  <a href="classDGtal_1_1DSSLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> (faithful polygon)  <a href="classDGtal_1_1FPLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step).  <a href="classDGtal_1_1L1LengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (given by the <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>)  <a href="classDGtal_1_1MLPLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html">MostCenteredMaximalSegmentEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of CLocalCurveGeometricEstimator that assigns to each element of a (sub)range a quantity estimated from the most centered maximal segment passing through this element.  <a href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeArcLengthFunctor.html">ParametricShapeArcLengthFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that estimates the arc length of a paramtric curve.  <a href="classDGtal_1_1ParametricShapeArcLengthFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeCurvatureFunctor.html">ParametricShapeCurvatureFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that computes the curvature at a given point of a parametric shape.  <a href="classDGtal_1_1ParametricShapeCurvatureFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeTangentFunctor.html">ParametricShapeTangentFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that computes the tangent vector at a given point of a parametric shape.  <a href="classDGtal_1_1ParametricShapeTangentFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Rosen-Proffitt Length Estimator.  <a href="classDGtal_1_1RosenProffittLocalLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDSSEstimator.html">TangentFromDSSEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentVectorFromDSSEstimator.html">TangentVectorFromDSSEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentAngleFromDSSEstimator.html">TangentAngleFromDSSEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDCAEstimator.html">CurvatureFromDCAEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NormalFromDCAEstimator.html">NormalFromDCAEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDCAEstimator.html">TangentFromDCAEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceFromDCAEstimator.html">DistanceFromDCAEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDSSLengthEstimator.html">CurvatureFromDSSLengthEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDSSEstimator.html">CurvatureFromDSSEstimator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html">TrueGlobalEstimatorOnPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the true quantity to each element of a range associated to a parametric shape.  <a href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueLocalEstimatorOnPoints.html">TrueLocalEstimatorOnPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the true quantity to each element of a range associated to a parametric shape.  <a href="classDGtal_1_1TrueLocalEstimatorOnPoints.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step).  <a href="classDGtal_1_1TwoStepLocalLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter.html">Adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: abstract adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>. Has 2 virtual methods:  <a href="classDGtal_1_1Adapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter4ConvexPart.html">Adapter4ConvexPart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a> used by <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> in convex parts. Has 2 methods:  <a href="classDGtal_1_1Adapter4ConvexPart.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter4ConcavePart.html">Adapter4ConcavePart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a> used by <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> in concave parts. Has 2 methods:  <a href="classDGtal_1_1Adapter4ConcavePart.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FP.html">FP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the faithful polygon (<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>) of a range of 4/8-connected 2D Points.  <a href="classDGtal_1_1FP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FrechetShortcut.html">FrechetShortcut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: On-line computation Computation of the longest shortcut according to the Fréchet distance for a given error. See related article: Sivignon, I., (2011). A Near-Linear Time Guaranteed Algorithm for Digital Curve Simplification under the Fréchet Distance. DGCI 2011. Retrieved from <a href="http://link.springer.com/chapter/10.1007/978-3-642-19867-0_28">http://link.springer.com/chapter/10.1007/978-3-642-19867-0_28</a>.  <a href="classDGtal_1_1FrechetShortcut.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GeometricalDCA.html">GeometricalDCA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edges such that there is at least one (Euclidean) circle that separates the centers of the two incident pixels of each grid edge.  <a href="classDGtal_1_1GeometricalDCA.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GeometricalDSS.html">GeometricalDSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid edges such that there is at least one straight line that separates the centers of the two incident pixels of each grid edge.  <a href="classDGtal_1_1GeometricalDSS.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.  <a href="classDGtal_1_1GreedySegmentation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: describes, in a cellular space of dimension n, a closed of open sequence of signed d-cells (or d-scells), d being either equal to 1 or (n-1).  <a href="classDGtal_1_1GridCurve.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range given by a pair of ConstIterators (maximal segments are segments that cannot be included in greater segments).  <a href="classDGtal_1_1SaturatedSegmentation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SegmentComputerTraits.html">SegmentComputerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the category of the segment computer {<a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a>,<a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a>}.  <a href="structDGtal_1_1SegmentComputerTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a helper class to process sequences of points.  <a href="classDGtal_1_1ContourHelper.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1COBAGenericNaivePlane.html">COBAGenericNaivePlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1, it corresponds to naive planes. Contrary to <a class="el" href="classDGtal_1_1COBANaivePlane.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlane</a>, the axis is <b>not</b> specified at initialization of the object. This class uses three instances of <a class="el" href="classDGtal_1_1COBANaivePlane.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlane</a>, one per axis.  <a href="classDGtal_1_1COBAGenericNaivePlane.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1COBANaivePlane.html">COBANaivePlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizing pieces of digital planes of given axis width. When the width is 1, it corresponds to naive planes. The axis is specified at initialization of the object.  <a href="classDGtal_1_1COBANaivePlane.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstantConvolutionWeights.html">ConstantConvolutionWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implement a trivial constant convolution kernel which returns 1 to each distance.  <a href="classDGtal_1_1ConstantConvolutionWeights.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GaussianConvolutionWeights.html">GaussianConvolutionWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implement a Gaussian centered convolution kernel.  <a href="classDGtal_1_1GaussianConvolutionWeights.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConvolutionWeights.html">CConvolutionWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines models of centered convolution kernel used for normal vector integration for instance.  <a href="structDGtal_1_1CConvolutionWeights.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CNormalVectorEstimator.html">CNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of estimator of normal vector along digital surfaces.  <a href="structDGtal_1_1CNormalVectorEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html">DigitalSurfaceEmbedderWithNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Combines a digital surface embedder with a normal vector estimator to get a model of <a class="el" href="structDGtal_1_1CDigitalSurfaceEmbedder.html" title="Aim: A digital surface embedder is a specialized mapping from signed cells to Euclidean points...">CDigitalSurfaceEmbedder</a> and <a class="el" href="structDGtal_1_1CWithGradientMap.html" title="Aim: Such object provides a gradient map that associates to each argument some real vector...">CWithGradientMap</a>. (also default constructible, copy constructible, assignable).  <a href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimatorGradientMap.html">DigitalSurfaceEmbedderWithNormalVectorEstimatorGradientMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LocalConvolutionNormalVectorEstimator.html">LocalConvolutionNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the normal vector at a surface element by convolution of elementary normal vector to adjacent surfel.  <a href="classDGtal_1_1LocalConvolutionNormalVectorEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructible, copy constructible, assignable).  <a href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O(n), with the algorithm of O'Rourke (1981).  <a href="classDGtal_1_1Preimage2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SphericalAccumulator.html">SphericalAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements an accumulator (as histograms for 1D scalars) adapted to spherical point samples.  <a href="classDGtal_1_1SphericalAccumulator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSeparableMetric.html">CSeparableMetric</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceTransformation.html">DistanceTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time distance transformation for separable metrics.  <a href="classDGtal_1_1DistanceTransformation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FMM.html">FMM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Fast Marching Method (<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>) for nd distance transforms.  <a href="classDGtal_1_1FMM.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html">L2FirstOrderLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1L2FirstOrderLocalDistance.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2SecondOrderLocalDistance.html">L2SecondOrderLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values of some points lying in the neighborhood of p, such that only one of their coordinate differ from the coordinates of p by at most two.  <a href="classDGtal_1_1L2SecondOrderLocalDistance.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LInfLocalDistance.html">LInfLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the LInf-distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1LInfLocalDistance.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L1LocalDistance.html">L1LocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the L1-distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1L1LocalDistance.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistanceFromCells.html">L2FirstOrderLocalDistanceFromCells</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values in the neighborhood of p. Contrary to <a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2FirstOrderLocalDistance</a>, the distance values are not available from the points adjacent to p but instead from the (d-1)-cells lying between p and these points.  <a href="classDGtal_1_1L2FirstOrderLocalDistanceFromCells.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SpeedExtrapolator.html">SpeedExtrapolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the a speed value at some point p, from the available distance values and speed values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1) in order to extrapolate a speed field in the normal direction to the interface.  <a href="classDGtal_1_1SpeedExtrapolator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html">ReverseDistanceTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time reverse distance transformation.  <a href="classDGtal_1_1ReverseDistanceTransformation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricHelper.html">SeparableMetricHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements basic functions associated to metrics used by separable volumetric algorithms.  <a href="structDGtal_1_1SeparableMetricHelper.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TPoint_00_01TInternalValue_00_012_01_4.html">SeparableMetricHelper&lt; TPoint, TInternalValue, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TPoint_00_01TInternalValue_00_011_01_4.html">SeparableMetricHelper&lt; TPoint, TInternalValue, 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TPoint_00_01TInternalValue_00_010_01_4.html">SeparableMetricHelper&lt; TPoint, TInternalValue, 0 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1VoronoiMap.html">VoronoiMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time Voronoi map construction.  <a href="classDGtal_1_1VoronoiMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Measure.html">Measure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2, it corresponds to the area of the set, to the volume in dimension 3,...  <a href="classDGtal_1_1Measure.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImage.html">CImage</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstImageAdapter.html">ConstImageAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for domain, f for accessing point values.  <a href="classDGtal_1_1ConstImageAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CTrivialConstImage.html">CTrivialConstImage</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CTrivialImage.html">CTrivialImage</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DefaultConstImageRange.html">DefaultConstImageRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts the domain of an image in order to iterate over the values associated to its domain points (in a read-only as well as a write-only manner).  <a href="classDGtal_1_1DefaultConstImageRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DefaultImageRange.html">DefaultImageRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> and <a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point...">CBidirectionalOutputRangeFromPoint</a> that adapts the domain of an image in order to iterate over the values associated to its domain points (in a read-only as well as a write-only manner).  <a href="classDGtal_1_1DefaultImageRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements association bewteen points lying in a digital domain and values.  <a href="classDGtal_1_1Image.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageAdapter.html">ImageAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain, f for accessing point values and f-1 for writing point values.  <a href="classDGtal_1_1ImageAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerByHashTree.html">ImageContainerByHashTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.  <a href="classDGtal_1_1ImageContainerByHashTree.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceFunctorFromPoint.html">DistanceFunctorFromPoint</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html">ImageLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for images. (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a>.  <a href="classDGtal_1_1ImageLinearCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageSelector.html">ImageSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Automatically defines an adequate image type according to the hints given by the user.  <a href="structDGtal_1_1ImageSelector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageSelector_3_01Domain_00_01Value_00_01LOW__ITER__I_09LOW__BEL__I_01_4.html">ImageSelector&lt; Domain, Value, LOW_ITER_I+LOW_BEL_I &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageFromSet.html">ImageFromSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define utilities to convert a digital set into an image.  <a href="structDGtal_1_1ImageFromSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntervalForegroundPredicate.html">IntervalForegroundPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple Foreground predicate thresholding image values between two constant values.  <a href="classDGtal_1_1IntervalForegroundPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetFromImage.html">SetFromImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define utilities to convert a digital set into an image.  <a href="structDGtal_1_1SetFromImage.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleThresholdForegroundPredicate.html">SimpleThresholdForegroundPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple Foreground predicate thresholding image values given a single thresold. More precisely, the functor operator() returns true if the value is greater than a given threshold.  <a href="classDGtal_1_1SimpleThresholdForegroundPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Morton.html">Morton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements the binary <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> code construction in nD.  <a href="classDGtal_1_1Morton.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SetValueIterator.html">SetValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements an output iterator, which is able to write values in an underlying image, by calling its setValue method.  <a href="classDGtal_1_1SetValueIterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board2D.html">Board2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class specializes a 'Board' class so as to display <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> objects more naturally (with &lt;&lt;). The user has simply to declare a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a> object and uses stream operators to display most digital objects. Furthermore, one can use this class to modify the current style for drawing.  <a href="classDGtal_1_1Board2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithBoardModifier.html">DrawWithBoardModifier</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomStyle.html">CustomStyle</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetMode.html">SetMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a> stream. Useful to choose your own mode for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">CDrawableWithBoard2D</a>.  <a href="structDGtal_1_1SetMode.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomColors.html">CustomColors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen color and the fill color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomColors.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomPenColor.html">CustomPenColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomPenColor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomFillColor.html">CustomFillColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the fill color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomFillColor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomPen.html">CustomPen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen attributes. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomPen.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.  <a href="classDGtal_1_1Board3DTo2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">CDrawableWithBoard2D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing an RGB triple.  <a href="classDGtal_1_1Color.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CColorMap.html">CColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a color map. A color map converts a value within a given range into an RGB triple.  <a href="structDGtal_1_1CColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color with given lightness.  <a href="classDGtal_1_1ColorBrightnessColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a gradient defined by two or more colors.  <a href="classDGtal_1_1GradientColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into gray levels.  <a href="classDGtal_1_1GrayscaleColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a <em>cyclic</em> hue shade colormap, maybe aka rainbow color map. This color map is suitable, for example, to colorize distance functions. By default, only one hue cycle is used.  <a href="classDGtal_1_1HueShadeColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: access to random color from a gradientColorMap.  <a href="classDGtal_1_1RandomColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Display2DFactory.html">Display2DFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for Display2D:  <a href="structDGtal_1_1Display2DFactory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Display3D.html">Display3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). The class <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> and <a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a> implement two different ways to display 3D objects. The first one (<a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>), permits an interactive visualisation (based on  OpenGL ) and the second one (<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>) provides 3D visualisation from 2D vectorial display (based on the CAIRO library)  <a href="classDGtal_1_1Display3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Display3DFactory.html">Display3DFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for GPL <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a>:  <a href="structDGtal_1_1Display3DFactory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithDisplay3DModifier.html">DrawWithDisplay3DModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class specifying the methods for classes which intend to modify a <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> stream.  <a href="structDGtal_1_1DrawWithDisplay3DModifier.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetMode3D.html">SetMode3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> stream. Useful to choose your own mode for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a>.  <a href="structDGtal_1_1SetMode3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomStyle3D.html">CustomStyle3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> stream. Useful to choose your own style for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a>.  <a href="structDGtal_1_1CustomStyle3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomColors3D.html">CustomColors3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the fill color and the gl_LINE/gl_POINT color. You can use <a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple.">DGtal::Color</a> with alpha transparency value but you nedd to take into account the z-buffer during the Open-GL based rendering.  <a href="structDGtal_1_1CustomColors3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ClippingPlane.html">ClippingPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for adding a Clipping plane through the <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> stream. Realizes the concept CDrawableWithViewer3D.  <a href="structDGtal_1_1ClippingPlane.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraPosition.html">CameraPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraPosition.html" title="CameraPosition class to set camera position.">CameraPosition</a> class to set camera position.  <a href="structDGtal_1_1CameraPosition.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraDirection.html">CameraDirection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraDirection.html" title="CameraDirection class to set camera direction.">CameraDirection</a> class to set camera direction.  <a href="structDGtal_1_1CameraDirection.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraUpVector.html">CameraUpVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraUpVector.html" title="CameraUpVector class to set camera up-vector.">CameraUpVector</a> class to set camera up-vector.  <a href="structDGtal_1_1CameraUpVector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraZNearFar.html">CameraZNearFar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraZNearFar.html" title="CameraZNearFar class to set near and far distance.">CameraZNearFar</a> class to set near and far distance.  <a href="structDGtal_1_1CameraZNearFar.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TransformedKSSurfel.html">TransformedKSSurfel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to modify the position and scale to construct better illustration mode.  <a href="structDGtal_1_1TransformedKSSurfel.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LongvolReader.html">LongvolReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Longvol" file format (with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type).  <a href="structDGtal_1_1LongvolReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MagickReader.html">MagickReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a 2D image using the ImageMagick library.  <a href="structDGtal_1_1MagickReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MeshReader.html">MeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defined to import OFF and OFS surface mesh. It allows to import a <a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a> object and takes into accouts the optional color faces.  <a href="structDGtal_1_1MeshReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PNMReader.html">PNMReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a 2D or 3D using the Netpbm formats (ASCII mode).  <a href="structDGtal_1_1PNMReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PointListReader.html">PointListReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements method to read a set of points represented in each line of a file.  <a href="structDGtal_1_1PointListReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RawReader.html">RawReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Vol" file format.  <a href="structDGtal_1_1RawReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1VolReader.html">VolReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Vol" file format.  <a href="structDGtal_1_1VolReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Style2DFactory.html">Style2DFactory</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleCircular__AngleLinearMinimizer.html">DefaultDrawStyleCircular_AngleLinearMinimizer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleBB__ArithmeticalDSS.html">DefaultDrawStyleBB_ArithmeticalDSS</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStylePoints__ArithmeticalDSS.html">DefaultDrawStylePoints_ArithmeticalDSS</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__DigitalSetBySTLSet.html">DefaultDrawStyle_DigitalSetBySTLSet</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__DigitalSetBySTLVector.html">DefaultDrawStyle_DigitalSetBySTLVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__FP.html">DefaultDrawStyle_FP</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__FreemanChain.html">DefaultDrawStyleGrid_FreemanChain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleInterGrid__FreemanChain.html">DefaultDrawStyleInterGrid_FreemanChain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__GeometricalDSS.html">DefaultDrawStyle_GeometricalDSS</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__GeometricalDCA.html">DefaultDrawStyle_GeometricalDCA</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__FrechetShortcut.html">DefaultDrawStyle_FrechetShortcut</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStylePaving__HyperRectDomain.html">DefaultDrawStylePaving_HyperRectDomain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__HyperRectDomain.html">DefaultDrawStyleGrid_HyperRectDomain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__ImageContainerByHashTree.html">DefaultDrawStyle_ImageContainerByHashTree</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__ImageContainerBySTLVector.html">DefaultDrawStyle_ImageContainerBySTLVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__KhalimskyCell.html">DefaultDrawStyle_KhalimskyCell</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__Object.html">DefaultDrawStyle_Object</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStylePaving__PointVector.html">DefaultDrawStylePaving_PointVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__PointVector.html">DefaultDrawStyleGrid_PointVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__SignedKhalimskyCell.html">DefaultDrawStyle_SignedKhalimskyCell</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleFilled__LatticePolytope2D.html">DefaultDrawStyleFilled_LatticePolytope2D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleTransparent__LatticePolytope2D.html">DefaultDrawStyleTransparent_LatticePolytope2D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DGtalInventor.html">DGtalInventor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A stream object based on Open Inventor for exporting or displaying <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> objects.  <a href="classDGtal_1_1DGtalInventor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVViewer.html">IVViewer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A facade to represent an inventor window for 3D objects. May be a SoXt or a SoQt examiner viewer. NB: backported from ImaGeneUtils library.  <a href="classDGtal_1_1IVViewer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Lattice.html">Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an n-dimensional integer lattice in an m-dimensional real vector space.  <a href="classDGtal_1_1Lattice.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Display 3D primitive (like <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). This class uses the libQGLViewer library (<a href="http://www.libqglviewer.com">http://www.libqglviewer.com </a>). It inherits of the class <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> and permits to display object using a simple stream mechanism of "&lt;&lt;".  <a href="classDGtal_1_1Viewer3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LongvolWriter.html">LongvolWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Longvol formats (volumetric image with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type).  <a href="structDGtal_1_1LongvolWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MeshWriter.html">MeshWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a Mesh (<a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a> object) in different format as OFF and OBJ).  <a href="structDGtal_1_1MeshWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PGMWriter.html">PGMWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 2D and a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Netpbm PGM formats (ASCII mode).  <a href="structDGtal_1_1PGMWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PPMWriter.html">PPMWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 2D and a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Netpbm PPM formats (ASCII mode).  <a href="structDGtal_1_1PPMWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RawWriter.html">RawWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Raw binary export of an <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>.  <a href="structDGtal_1_1RawWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1VolWriter.html">VolWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Vol formats.  <a href="structDGtal_1_1VolWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Projector.html">Projector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor that maps a point P of dimension i to a point Q of dimension j. The member <em>myDims</em> is an array containing the coordinates - (0, 1, ..., j-1) by default - that are copied from P to Q.  <a href="structDGtal_1_1Projector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ConstantPointPredicate.html">ConstantPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always the same value boolCst.  <a href="structDGtal_1_1ConstantPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TruePointPredicate.html">TruePointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always true.  <a href="structDGtal_1_1TruePointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1FalsePointPredicate.html">FalsePointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always false.  <a href="structDGtal_1_1FalsePointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsLowerPointPredicate.html">IsLowerPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is below (or equal) the given upper bound.  <a href="structDGtal_1_1IsLowerPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsUpperPointPredicate.html">IsUpperPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is above (or equal) the given lower bound.  <a href="structDGtal_1_1IsUpperPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsWithinPointPredicate.html">IsWithinPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is within the given bounds.  <a href="structDGtal_1_1IsWithinPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NotPointPredicate.html">NotPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point predicate given at construction return false. Thus inverse a predicate: NOT operator.  <a href="structDGtal_1_1NotPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1EqualPointPredicate.html">EqualPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point given as argument equals the reference point given at construction.  <a href="structDGtal_1_1EqualPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BinaryPointPredicate.html">BinaryPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the given binary functor returns true for the two PointPredicates given at construction.  <a href="structDGtal_1_1BinaryPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PointFunctorPredicate.html">PointFunctorPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the predicate returns true for the value assigned to a given point in the point functor.  <a href="structDGtal_1_1PointFunctorPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for unsigned cell, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn.  <a href="structDGtal_1_1CanonicEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicSCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBoundedInteger.html">CBoundedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CBoundedInteger.html" title="Aim: The concept CBoundedInteger specifies what are the bounded integer numbers. Hence, it is a refinement of CInteger Concept ensuring that the numbers are bounded.">CBoundedInteger</a> specifies what are the bounded integer numbers. Hence, it is a refinement of <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> Concept ensuring that the numbers are bounded.  <a href="structDGtal_1_1CBoundedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCommutativeRing.html">CCommutativeRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring.  <a href="structDGtal_1_1CCommutativeRing.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanRing.html">CEuclideanRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operator.  <a href="structDGtal_1_1CEuclideanRing.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CInteger.html">CInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> specifies what are the usual integer numbers, more precisely the ones that are representable on a computer.  <a href="structDGtal_1_1CInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointEmbedder.html">CPointEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A point embedder is a mapping from digital points to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CPointEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointFunctor.html">CPointFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a functor on points.  <a href="structDGtal_1_1CPointFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointPredicate.html">CPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a point.  <a href="structDGtal_1_1CPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSignedInteger.html">CSignedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Signed Integer.  <a href="structDGtal_1_1CSignedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSpace.html">CSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a digital space, ie a cartesian product of integer lines.  <a href="structDGtal_1_1CSpace.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUnsignedInteger.html">CUnsignedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Unsigned Integer.  <a href="structDGtal_1_1CUnsignedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CWithGradientMap.html">CWithGradientMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Such object provides a gradient map that associates to each argument some real vector.  <a href="structDGtal_1_1CWithGradientMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDomain.html">CDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digital space.  <a href="structDGtal_1_1CDomain.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CDomainArchetype.html">CDomainArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The archetype of a class that represents a digital domain, i.e. a non mutable subset of points of the given digital space.  <a href="classDGtal_1_1CDomainArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DomainPredicate.html">DomainPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction. It is just a wrapper class around the methods Domain::isInside( const Point &amp; ), where <code>Domain</code> stands for any model of <a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a>.  <a href="structDGtal_1_1DomainPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Parallelepidec region of a digital space, model of a '<a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a>'.  <a href="classDGtal_1_1HyperRectDomain.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__Iterator.html">HyperRectDomain_Iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__subIterator.html">HyperRectDomain_subIterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LinearAlgebra.html">LinearAlgebra</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class that contains methods to perform integral linear algebra.  <a href="structDGtal_1_1LinearAlgebra.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits.html">NumberTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The traits class for all models of Cinteger.  <a href="structDGtal_1_1NumberTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint16__t_01_4.html">NumberTraits&lt; uint16_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int16__t_01_4.html">NumberTraits&lt; int16_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint8__t_01_4.html">NumberTraits&lt; uint8_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int8__t_01_4.html">NumberTraits&lt; int8_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint32__t_01_4.html">NumberTraits&lt; uint32_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int32__t_01_4.html">NumberTraits&lt; int32_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint64__t_01_4.html">NumberTraits&lt; uint64_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int64__t_01_4.html">NumberTraits&lt; int64_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01float_01_4.html">NumberTraits&lt; float &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01double_01_4.html">NumberTraits&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01long_01double_01_4.html">NumberTraits&lt; long double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Warning__promote__trait__not__specialized__for__this__case.html">Warning_promote_trait_not_specialized_for_this_case</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1promote__trait.html">promote_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1promote__trait_3_01int32__t_00_01int64__t_01_4.html">promote_trait&lt; int32_t, int64_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements basic operations that will be used in Point and Vector classes.  <a href="classDGtal_1_1PointVector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0,...,0) is mapped onto the digital point (0,...,0).  <a href="classDGtal_1_1RegularPointEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSet.html">CDigitalSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of points within the given domain. This set of points is modifiable by the user.  <a href="structDGtal_1_1CDigitalSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CDigitalSetArchetype.html">CDigitalSetArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The archetype of a container class for storing sets of digital points within some given domain.  <a href="classDGtal_1_1CDigitalSetArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A container class for storing sets of digital points within some given domain.  <a href="classDGtal_1_1DigitalSetBySTLSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Realizes the concept <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a> by using the STL container std::vector.  <a href="classDGtal_1_1DigitalSetBySTLVector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetConverter.html">DigitalSetConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Utility class to convert between types of sets.  <a href="structDGtal_1_1DigitalSetConverter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Constructs a domain limited to the given digital set.  <a href="classDGtal_1_1DigitalSetDomain.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An adapter for viewing an associative image container like <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> as a simple digital set. This class is merely based on an aliasing pointer on the image, which must exists elsewhere.  <a href="classDGtal_1_1DigitalSetFromMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetInserter.html">DigitalSetInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: this output iterator class is designed to allow algorithms to insert points in the digital set. Using the assignment operator, even when dereferenced, causes the digital set to insert a point.  <a href="classDGtal_1_1DigitalSetInserter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector.html">DigitalSetSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Automatically defines an adequate digital set type according to the hints given by the user.  <a href="structDGtal_1_1DigitalSetSelector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector_3_01Domain_00_01SMALL__DS_09LOW__VAR__DS_09LOW__ITER__DS_09LOW__BEL__DS_01_4.html">DigitalSetSelector&lt; Domain, SMALL_DS+LOW_VAR_DS+LOW_ITER_DS+LOW_BEL_DS &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector_3_01Domain_00_01SMALL__DS_09LOW__VAR__DS_09HIGH__ITER__DS_09LOW__BEL__DS_01_4.html">DigitalSetSelector&lt; Domain, SMALL_DS+LOW_VAR_DS+HIGH_ITER_DS+LOW_BEL_DS &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetPredicate.html">SetPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction.  <a href="structDGtal_1_1SetPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements basic MxN Matrix services (M,N&gt;=1).  <a href="classDGtal_1_1SimpleMatrix.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleMatrixSpecializations.html">SimpleMatrixSpecializations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement internal matrix services for specialized matrix size.  <a href="structDGtal_1_1SimpleMatrixSpecializations.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_012_00_012_01_4.html">SimpleMatrixSpecializations&lt; TMatrix, 2, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_012_00_012_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_011_00_011_01_4.html">SimpleMatrixSpecializations&lt; TMatrix, 1, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_011_00_011_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_013_00_013_01_4.html">SimpleMatrixSpecializations&lt; TMatrix, 3, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_013_00_013_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="classDGtal_1_1SpaceND.html" title="Aim: SpaceND is a utility class that defines the fundamental structure of a Digital Space in ND...">SpaceND</a> is a utility class that defines the fundamental structure of a Digital Space in ND.  <a href="classDGtal_1_1SpaceND.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AngleComputer.html">AngleComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Used to minimize the angle variation between different angles while taking into accounts min and max constraints. Example (.  <a href="classDGtal_1_1AngleLinearMinimizer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByRelaxation.html">AngleLinearMinimizerByRelaxation</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByGradientDescent.html">AngleLinearMinimizerByGradientDescent</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByAdaptiveStepGradientDescent.html">AngleLinearMinimizerByAdaptiveStepGradientDescent</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines associated to domains defined as polygons in the (a,b)-parameter space. This parameter space maps the line $ax-y+b=0$ to the point $(a,b)$.  <a href="classDGtal_1_1MeasureOfStraightLines.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl_3_011_00_01TRing_00_01TOwner_00_01TAlloc_00_01TX_01_4.html">MPolynomialEvaluatorImpl&lt; 1, TRing, TOwner, TAlloc, TX &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl.html">MPolynomialEvaluatorImpl</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluator_3_011_00_01TRing_00_01TAlloc_00_01TX_01_4.html">MPolynomialEvaluator&lt; 1, TRing, TAlloc, TX &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluator.html">MPolynomialEvaluator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomial_3_010_00_01TRing_00_01TAlloc_01_4.html">MPolynomial&lt; 0, TRing, TAlloc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> for degree 0.  <a href="classDGtal_1_1MPolynomial_3_010_00_01TRing_00_01TAlloc_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVector.html">IVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVector_3_01T_00_01TAlloc_00_01true_01_4.html">IVector&lt; T, TAlloc, true &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a multivariate polynomial, i.e. an element of \( K[X_0, ..., X_{n-1}] \), where <em>K</em> is some ring or field.  <a href="classDGtal_1_1MPolynomial.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Xe__kComputer.html">Xe_kComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Xe__kComputer_3_010_00_01Ring_00_01Alloc_01_4.html">Xe_kComputer&lt; 0, Ring, Alloc &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_010_00_01n_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; 0, n, Ring, Alloc &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer.html">MPolynomialDerivativeComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_010_00_010_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; 0, 0, Ring, Alloc &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_01N_00_010_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; N, 0, Ring, Alloc &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignalData.html">SignalData</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Signal.html">Signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is only cloned when modified.  <a href="classDGtal_1_1Signal.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalBoundedShape.html">CDigitalBoundedShape</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalOrientedShape.html">CDigitalOrientedShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for points on a <a class="el" href="classDGtal_1_1SpaceND.html" title="Aim: SpaceND is a utility class that defines the fundamental structure of a Digital Space in ND...">SpaceND</a>. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1CDigitalOrientedShape.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html">CEuclideanOrientedShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for real points. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1CEuclideanOrientedShape.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two other points. It is able to return for any given point its signed distance to itself.  <a href="classDGtal_1_1CircleFrom2Points.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given 2D point its signed distance to itself.  <a href="classDGtal_1_1CircleFrom3Points.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MeshFromPoints.html">MeshFromPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces represented by its vertex index. By default it does not memorize the color Face and all faces will have the white color.  <a href="classDGtal_1_1MeshFromPoints.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Point2ShapePredicate.html">Point2ShapePredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Predicate returning 'true' iff a given point is in the 'interior' of a given shape, 'false' otherwise.  <a href="classDGtal_1_1Point2ShapePredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator.html">Point2ShapePredicateComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values according to two bool template parameters.  <a href="structDGtal_1_1Point2ShapePredicateComparator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html">Point2ShapePredicateComparator&lt; T, false, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&lt;).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html">Point2ShapePredicateComparator&lt; T, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&lt;=).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html">Point2ShapePredicateComparator&lt; T, true, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&gt;).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html">Point2ShapePredicateComparator&lt; T, true, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&gt;=).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any given 2D point its signed distance to itself.  <a href="classDGtal_1_1StraightLineFrom2Points.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with some \( h_1 Z \times h_2 Z \times \cdots \times h_n Z \). Note that the real point (0,...,0) is mapped onto the digital point (0,...,0).  <a href="classDGtal_1_1GaussDigitizer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImplicitFunction.html">CImplicitFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes any function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1CImplicitFunction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImplicitFunctionDiff1.html">CImplicitFunctionDiff1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes a 1-differentiable function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1CImplicitFunctionDiff1.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a ball in nD..  <a href="classDGtal_1_1ImplicitBall.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html">ImplicitFunctionDiff1LinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a> and <a class="el" href="structDGtal_1_1CWithGradientMap.html" title="Aim: Such object provides a gradient map that associates to each argument some real vector...">CWithGradientMap</a>.  <a href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedderGradientMap.html">ImplicitFunctionDiff1LinearCellEmbedderGradientMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html">ImplicitFunctionLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a>.  <a href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create an hypercube in nD..  <a href="classDGtal_1_1ImplicitHyperCube.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a ball for the L_1 norm in nD.  <a href="classDGtal_1_1ImplicitNorm1Ball.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> concepts to create a shape from a polynomial.  <a href="classDGtal_1_1ImplicitPolynomial3Shape.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a rounded hypercube in nD..  <a href="classDGtal_1_1ImplicitRoundedHyperCube.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any accelerated flower in the plane.  <a href="classDGtal_1_1AccFlower2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any circle in the plane.  <a href="classDGtal_1_1Ball2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ball3D.html">Ball3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept <a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a> represents any Sphere in the space.  <a href="classDGtal_1_1Ball3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any ellipse in the plane.  <a href="classDGtal_1_1Ellipse2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.  <a href="classDGtal_1_1Flower2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any regular k-gon in the plane.  <a href="classDGtal_1_1NGon2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Shapes.html">Shapes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class for constructing different shapes (balls, diamonds, and others).  <a href="classDGtal_1_1Shapes.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or set (called initial core).  <a href="classDGtal_1_1BreadthFirstVisitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CAdjacency.html">CAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> defines an elementary adjacency relation between points of a digital space.  <a href="structDGtal_1_1CAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCellEmbedder.html">CCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCellularGridSpaceND.html">CCellularGridSpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian product, cells have a cubic shape that depends on the dimension: 0-cells are points, 1-cells are unit segments, 2-cells are squares, 3-cells are cubes, and so on.  <a href="structDGtal_1_1CCellularGridSpaceND.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html">CDigitalSurfaceContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1CDigitalSurfaceContainer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceEmbedder.html">CDigitalSurfaceEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A digital surface embedder is a specialized mapping from signed cells to Euclidean points. It adds inner types to functor as well as a method to access the digital surface.  <a href="structDGtal_1_1CDigitalSurfaceEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceTracker.html">CDigitalSurfaceTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1CDigitalSurfaceTracker.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDomainAdjacency.html">CDomainAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Refines the concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by telling that the adjacency is specific to a given domain of the embedding digital space.  <a href="structDGtal_1_1CDomainAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSCellEmbedder.html">CSCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A cell embedder is a mapping from signed cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CSCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSurfelPredicate.html">CSurfelPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a surfel.  <a href="structDGtal_1_1CSurfelPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUndirectedSimpleGraph.html">CUndirectedSimpleGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1CUndirectedSimpleGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUndirectedSimpleLocalGraph.html">CUndirectedSimpleLocalGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1CUndirectedSimpleLocalGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CVertexMap.html">CVertexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: models of <a class="el" href="structDGtal_1_1CVertexMap.html" title="Aim: models of CVertexMap concept implement mapping between graph vertices and values.">CVertexMap</a> concept implement mapping between graph vertices and values.  <a href="structDGtal_1_1CVertexMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CVertexPredicate.html">CVertexPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a vertex.  <a href="structDGtal_1_1CVertexPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DepthFirstVisitor.html">DepthFirstVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to perform a depth-first exploration of a graph given a starting point or set (called initial core).  <a href="classDGtal_1_1DepthFirstVisitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of a given digital set.  <a href="classDGtal_1_1DigitalSetBoundary.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cells. Therefore, a digital surface is a pure cubical complex (model of CCubicalComplex), made of k-cells, 0 &lt;= k &lt; n. This complex is generally not a manifold (i.e. a kind of surface), except when it has the property of being well-composed.  <a href="classDGtal_1_1DigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html">DigitalSurface2DSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a 2-dimensional slice in a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>. In a sense, it is a 4-connected contour, open or not. To be valid, it must be connected to some digital surface and a starting surfel.  <a href="classDGtal_1_1DigitalSurface2DSlice.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a digital topology as a couple of adjacency relations.  <a href="classDGtal_1_1DigitalTopology.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adjacency and neighborhood computations.  <a href="classDGtal_1_1DomainAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Expander.html">Expander</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to visit an object by adjacencies, layer by layer.  <a href="classDGtal_1_1Expander.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by a predicate telling whether a given surfel belongs or not to the shape boundary. Compute once the boundary of the surface with a tracking.  <a href="classDGtal_1_1ExplicitDigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BoundaryPredicate.html">BoundaryPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate on surfels that represents the frontier between a region and its complementary in an image. It can be used with <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> or <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a> so as to define a digital surface. Such surfaces may of course be open.  <a href="classDGtal_1_1BoundaryPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FrontierPredicate.html">FrontierPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate on surfels that represents the frontier between two regions in an image. It can be used with <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> or <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a> so as to define a digital surface. Such surfaces may of course be open.  <a href="classDGtal_1_1FrontierPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).  <a href="classDGtal_1_1Surfaces.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of an implicitly define shape. Compute once the boundary of the surface with a tracking.  <a href="classDGtal_1_1ImplicitDigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an (unsigned) cell in a cellular grid space by its Khalimsky coordinates.  <a href="structDGtal_1_1KhalimskyCell.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed cell in a cellular grid space by its Khalimsky coordinates and a boolean value.  <a href="structDGtal_1_1SignedKhalimskyCell.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CellDirectionIterator.html">CellDirectionIterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>. It represents the cubical grid as a cell complex, whose cells are defined as an array of integers. The topology of the cells is defined by the parity of the coordinates (even: closed, odd: open).  <a href="classDGtal_1_1KhalimskySpaceND.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by a predicate telling whether a given surfel belongs or not to the shape boundary. The whole boundary is not precomputed nor stored. You may use an iterator to visit it.  <a href="classDGtal_1_1LightExplicitDigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of an implicitly define shape. The whole boundary is not precomputed nor stored. You may use an iterator to visit it.  <a href="classDGtal_1_1LightImplicitDigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinity-norm.  <a href="classDGtal_1_1MetricAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_012_00_012_01_4.html">MetricAdjacency&lt; TSpace, 2, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_011_00_012_01_4.html">MetricAdjacency&lt; TSpace, 1, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_013_00_013_01_4.html">MetricAdjacency&lt; TSpace, 3, 3 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_012_00_013_01_4.html">MetricAdjacency&lt; TSpace, 2, 3 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_011_00_013_01_4.html">MetricAdjacency&lt; TSpace, 1, 3 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An object (or digital object) represents a set in some digital space associated with a digital topology.  <a href="classDGtal_1_1Object.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToPoint.html">SCellToPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a scell into a point.  <a href="classDGtal_1_1SCellToPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToMidPoint.html">SCellToMidPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a scell into a real point (the coordinates are divided by 2)  <a href="classDGtal_1_1SCellToMidPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToArrow.html">SCellToArrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell into an arrow, ie. a pair point-vector.  <a href="classDGtal_1_1SCellToArrow.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToInnerPoint.html">SCellToInnerPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a point corresponding to the signed cell of greater dimension that is indirectly incident to c.  <a href="classDGtal_1_1SCellToInnerPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToOuterPoint.html">SCellToOuterPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a point corresponding to the signed cell of greater dimension that is directly incident to c.  <a href="classDGtal_1_1SCellToOuterPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToIncidentPoints.html">SCellToIncidentPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a pair of points corresponding to the signed cells of greater dimension that are indirectly and directly incident to c.  <a href="classDGtal_1_1SCellToIncidentPoints.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToCode.html">SCellToCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a 2d signed cell, basically a linel, into a code (0,1,2 or 3),.  <a href="classDGtal_1_1SCellToCode.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by the set of surfels that composed the surface. The set of surfels is stored in this container.  <a href="classDGtal_1_1SetOfSurfels.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1STLMapToVertexMapAdapter.html">STLMapToVertexMapAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class adapts any map of the STL to match with the <a class="el" href="structDGtal_1_1CVertexMap.html" title="Aim: models of CVertexMap concept implement mapping between graph vertices and values.">CVertexMap</a> concept.  <a href="classDGtal_1_1STLMapToVertexMapAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ordering or exterior to interior ordering. It allows tracking of boundaries and of surfaces.  <a href="classDGtal_1_1SurfelAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a> so as to determine adjacent surfels (either looking for them from interior to exterior or inversely).  <a href="classDGtal_1_1SurfelNeighborhood.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SurfelSetPredicate.html">SurfelSetPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction.  <a href="structDGtal_1_1SurfelSetPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1UmbrellaComputer.html">UmbrellaComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Useful for computing umbrellas on '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>'s, ie set of n-1 cells around a n-3 cell.  <a href="classDGtal_1_1UmbrellaComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImplicitDigitalEllipse3.html">ImplicitDigitalEllipse3</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a40f198468aea6d0121b11cd49e599e92"><td class="memItemLeft" align="right" valign="top">typedef boost::function0&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a></td></tr>
<tr class="memitem:a9a92f37472d9010932be3fe6d28f94cb"><td class="memItemLeft" align="right" valign="top">typedef boost::function1&lt; bool, <br class="typebreak"/>
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a></td></tr>
<tr class="memitem:a7d57d4419aa9656ae4be838f903b5dd2"><td class="memItemLeft" align="right" valign="top">typedef boost::function2&lt; bool, <br class="typebreak"/>
bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a></td></tr>
<tr class="memitem:a1bbf050f10f3c666dc5e170e893d8e57"><td class="memItemLeft" align="right" valign="top">typedef boost::function3&lt; bool, <br class="typebreak"/>
bool, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1bbf050f10f3c666dc5e170e893d8e57">BoolFunction3</a></td></tr>
<tr class="memitem:a3f01c0f785c605d021be8e328180f502"><td class="memItemLeft" align="right" valign="top">typedef boost::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">uint8_t</a></td></tr>
<tr class="memitem:a30f912c6a9d587320495d627df2719ba"><td class="memItemLeft" align="right" valign="top">typedef boost::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">uint16_t</a></td></tr>
<tr class="memitem:a27c59126488e9c545120667959d2fc4e"><td class="memItemLeft" align="right" valign="top">typedef boost::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a></td></tr>
<tr class="memitem:ab33c0c25b8cc3cd86de343bca34329f5"><td class="memItemLeft" align="right" valign="top">typedef boost::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a></td></tr>
<tr class="memitem:ac28d51e0b1672afa52b3c218a32a6a01"><td class="memItemLeft" align="right" valign="top">typedef boost::int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">int8_t</a></td></tr>
<tr class="memitem:ac62de8348789e05494b7515c6525baa0"><td class="memItemLeft" align="right" valign="top">typedef boost::int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">int16_t</a></td></tr>
<tr class="memitem:ac1e9ac6a329319ae13c51c0c9e92486a"><td class="memItemLeft" align="right" valign="top">typedef boost::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">int32_t</a></td></tr>
<tr class="memitem:a1c09e3f63904ff371f1b99f45069fc63"><td class="memItemLeft" align="right" valign="top">typedef boost::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a></td></tr>
<tr class="memitem:a8fbe8c8d47ca5c36ced14284ac62613d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9f6cc75dc44e45506a66cd233e0deb41"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">Orientation</a> { <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553">INSIDE</a> =  0, 
<a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e">ON</a> =  1, 
<a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734">OUTSIDE</a> =  2
 }</td></tr>
<tr class="memitem:a7f3384cac6dea91b4d46cc1421854dda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854dda">ImageIterability</a> { <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c">HIGH_ITER_IMAGE</a> =  0, 
<a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">LOW_ITER_I</a> =  1
 }</td></tr>
<tr class="memitem:afbda75b83fdb9094d0e38931838c8d6a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6a">ImageBelongTestability</a> { <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">HIGH_BEL_I</a> =  0, 
<a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">LOW_BEL_I</a> =  2
 }</td></tr>
<tr class="memitem:a0a142484d2c7efc3d29f5bbde3b449b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7">ImageSpecificContainer</a> { <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">NORMAL_CONTAINER_I</a> =  0, 
<a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">VTKIMAGEDATA_CONTAINER_I</a> =  4
 }</td></tr>
<tr class="memitem:a2526218ffac7b4842d393facbedd9ee3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3">DomainDrawMode</a> { <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">GRID</a> =  0, 
<a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">PAVING</a> =  1
 }</td></tr>
<tr class="memitem:aa68309838cffd86a3c671c44ef129cb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2">ColorGradientPreset</a> { <br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">CMAP_CUSTOM</a> =  0, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">CMAP_GRAYSCALE</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">CMAP_SPRING</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">CMAP_SUMMER</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">CMAP_AUTUMN</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">CMAP_WINTER</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">CMAP_COOL</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">CMAP_COPPER</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">CMAP_HOT</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a>
<br/>
 }</td></tr>
<tr class="memitem:a65228f031a436d2f4edd698ae733ba31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">BoundEnum</a> { <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">BOUNDED</a> =  0, 
<a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">UNBOUNDED</a> =  1, 
<a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">BOUND_UNKNOWN</a> =  2
 }</td></tr>
<tr class="memitem:a679e16b34aad98ff340decf89d1c86db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">SignEnum</a> { <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">SIGNED</a> =  0, 
<a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">UNSIGNED</a> =  1, 
<a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">SIGN_UNKNOWN</a> =  2
 }</td></tr>
<tr class="memitem:a07a2f5d6c861cd13dd680ea2e64e2dd4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4">DigitalSetSize</a> { <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">SMALL_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">MEDIUM_DS</a> =  1, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">BIG_DS</a> =  2, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">WHOLE_DS</a> =  3
 }</td></tr>
<tr class="memitem:ae37267b68e31ee8f7531488f7e88426a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426a">DigitalSetVariability</a> { <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">LOW_VAR_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">HIGH_VAR_DS</a> =  4
 }</td></tr>
<tr class="memitem:abae5017e6f3a3d5e0c4debd8142e8ccc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccc">DigitalSetIterability</a> { <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">LOW_ITER_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">HIGH_ITER_DS</a> =  8
 }</td></tr>
<tr class="memitem:a0f37e197740e9d7742426109610c513a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513a">DigitalSetBelongTestability</a> { <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">LOW_BEL_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">HIGH_BEL_DS</a> =  16
 }</td></tr>
<tr class="memitem:a9f57dcd68d3056024eec6b4205f7083d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083d">DigitalTopologyProperties</a> { <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">UNKNOWN_DT</a> =  0, 
<a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">NOT_JORDAN_DT</a> =  1, 
<a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> =  2
 }</td></tr>
<tr class="memitem:a5df441c76f46779791d077a80f0b902e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902e">Connectedness</a> { <a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea">DISCONNECTED</a> =  0, 
<a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a">CONNECTED</a> =  1, 
<a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4">UNKNOWN</a> =  2
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a75322b203241e20a106afb814182df80"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a75322b203241e20a106afb814182df80"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a75322b203241e20a106afb814182df80">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html">ClosedIntegerHalfPlane</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a196a8c122d6e58d73ecd46c249b8b849"><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr class="memitem:a196a8c122d6e58d73ecd46c249b8b849"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a196a8c122d6e58d73ecd46c249b8b849">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IntegerComputer.html">IntegerComputer</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a2c2216f99d3bb51af40e13a811bfd846"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TSequence &gt; </td></tr>
<tr class="memitem:a2c2216f99d3bb51af40e13a811bfd846"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2c2216f99d3bb51af40e13a811bfd846">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LatticePolytope2D.html">LatticePolytope2D</a>&lt; TSpace, TSequence &gt; &amp;object)</td></tr>
<tr class="memitem:ae4f0a1e7a73fe21a13f6809e3a47ff0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4f0a1e7a73fe21a13f6809e3a47ff0c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae4f0a1e7a73fe21a13f6809e3a47ff0c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a5f14f15bee0a8b951c870363e278a94e"><td class="memTemplParams" colspan="2">template&lt;typename TFraction &gt; </td></tr>
<tr class="memitem:a5f14f15bee0a8b951c870363e278a94e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5f14f15bee0a8b951c870363e278a94e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Pattern.html">Pattern</a>&lt; TFraction &gt; &amp;object)</td></tr>
<tr class="memitem:aa0e2794580b8d7d35c4b4761f264d08e"><td class="memTemplParams" colspan="2">template&lt;typename TFraction &gt; </td></tr>
<tr class="memitem:aa0e2794580b8d7d35c4b4761f264d08e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa0e2794580b8d7d35c4b4761f264d08e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a>&lt; TFraction &gt; &amp;object)</td></tr>
<tr class="memitem:ac4d5198d8a044649b47cf6ccecf43549"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac4d5198d8a044649b47cf6ccecf43549">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Clock.html">Clock</a> &amp;object)</td></tr>
<tr class="memitem:a0e7ca3a483107d4b69dfa47cf7919663"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TFunctor , typename TReturnType &gt; </td></tr>
<tr class="memitem:a0e7ca3a483107d4b69dfa47cf7919663"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0e7ca3a483107d4b69dfa47cf7919663">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ConstRangeAdapter.html">ConstRangeAdapter</a>&lt; TIterator, TFunctor, TReturnType &gt; &amp;object)</td></tr>
<tr class="memitem:aba713edeb51f787070eff9f9edc210c7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aba713edeb51f787070eff9f9edc210c7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aba713edeb51f787070eff9f9edc210c7">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; A, B &gt; &amp;object)</td></tr>
<tr class="memitem:aa5ad29732984e904acf8a15b5f36f391"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5ad29732984e904acf8a15b5f36f391"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa5ad29732984e904acf8a15b5f36f391">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a3b43a30839ecc0499b0b5d2d71952233"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b43a30839ecc0499b0b5d2d71952233"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3b43a30839ecc0499b0b5d2d71952233">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:af78ce7935f43397801a6d65785f71df5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af78ce7935f43397801a6d65785f71df5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af78ce7935f43397801a6d65785f71df5">minDGtal</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memitem:a5da3e5d223f3f741760a4e0fc3483c3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5da3e5d223f3f741760a4e0fc3483c3a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5da3e5d223f3f741760a4e0fc3483c3a">maxDGtal</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memitem:a54cd4c3ec97c9ec323a52de71339f589"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54cd4c3ec97c9ec323a52de71339f589"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a54cd4c3ec97c9ec323a52de71339f589">abs</a> (const T &amp;a)</td></tr>
<tr class="memitem:a156fb1231cef8a4755062c0319f5b0eb"><td class="memTemplParams" colspan="2">template&lt;typename TValue , unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:a156fb1231cef8a4755062c0319f5b0eb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a156fb1231cef8a4755062c0319f5b0eb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IndexedListWithBlocks.html">IndexedListWithBlocks</a>&lt; TValue, N, M &gt; &amp;object)</td></tr>
<tr class="memitem:a7b3757780615da753f109e91c107bbd3"><td class="memTemplParams" colspan="2">template&lt;typename TSequence , typename TRank &gt; </td></tr>
<tr class="memitem:a7b3757780615da753f109e91c107bbd3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7b3757780615da753f109e91c107bbd3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html">InputIteratorWithRankOnSequence</a>&lt; TSequence, TRank &gt; &amp;object)</td></tr>
<tr class="memitem:a6b49e997d09ccb163eb82529e8970996"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a6b49e997d09ccb163eb82529e8970996"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6b49e997d09ccb163eb82529e8970996">isEmpty</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="memitem:a6f1b22211474c60437654c3a0decb8ef"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a6f1b22211474c60437654c3a0decb8ef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="memitem:a7d3cb1a90041cd25855944e723d44f5a"><td class="memTemplParams" colspan="2">template&lt;typename TData , unsigned int L, typename TWord , unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:a7d3cb1a90041cd25855944e723d44f5a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7d3cb1a90041cd25855944e723d44f5a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LabelledMap.html">LabelledMap</a>&lt; TData, L, TWord, N, M &gt; &amp;object)</td></tr>
<tr class="memitem:a2f5edcc946b7d5701677dd3acac2860a"><td class="memTemplParams" colspan="2">template&lt;unsigned int L, typename TWord &gt; </td></tr>
<tr class="memitem:a2f5edcc946b7d5701677dd3acac2860a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2f5edcc946b7d5701677dd3acac2860a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Labels.html">Labels</a>&lt; L, TWord &gt; &amp;object)</td></tr>
<tr class="memitem:a0213a561c03e9d90b12581abcf2ea54d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0213a561c03e9d90b12581abcf2ea54d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a> &amp;object)</td></tr>
<tr class="memitem:a756d34159757aef9d0e815a8426071f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a756d34159757aef9d0e815a8426071f9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a756d34159757aef9d0e815a8426071f9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html">OwningOrAliasingPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a2129e2cee3ca511648fd20bcf90635f4"><td class="memTemplParams" colspan="2">template&lt;typename RealNumberType &gt; </td></tr>
<tr class="memitem:a2129e2cee3ca511648fd20bcf90635f4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2129e2cee3ca511648fd20bcf90635f4">operator&lt;&lt;</a> (std::ostream &amp;thatStream, const <a class="el" href="classDGtal_1_1Statistic.html">Statistic</a>&lt; RealNumberType &gt; &amp;that_object_to_display)</td></tr>
<tr class="memitem:ae5cfe3192eb33036ed5a6afdce4fa90c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae5cfe3192eb33036ed5a6afdce4fa90c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Trace.html">Trace</a> &amp;object)</td></tr>
<tr class="memitem:aa1a0c72f3ea963c433d33b86d1fba535"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa1a0c72f3ea963c433d33b86d1fba535">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a> &amp;object)</td></tr>
<tr class="memitem:abb0ae3e476260be1ddbbe6c881738e81"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abb0ae3e476260be1ddbbe6c881738e81">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a> &amp;object)</td></tr>
<tr class="memitem:aa60540f21dc15c6580824e2e370a7600"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa60540f21dc15c6580824e2e370a7600">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> &amp;object)</td></tr>
<tr class="memitem:a36a2459f7913ffe2255193bdfc4536d8"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr class="memitem:a36a2459f7913ffe2255193bdfc4536d8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a36a2459f7913ffe2255193bdfc4536d8">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr class="memitem:aaabd5b098d8beabcd7e4bc7d4316586a"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr class="memitem:aaabd5b098d8beabcd7e4bc7d4316586a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aaabd5b098d8beabcd7e4bc7d4316586a">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">ArithmeticalDSS3d</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr class="memitem:a352f8e878ed0810de6b9166501d8f33a"><td class="memTemplParams" colspan="2">template&lt;typename TConstIteratorOnPoints , typename TValue &gt; </td></tr>
<tr class="memitem:a352f8e878ed0810de6b9166501d8f33a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a352f8e878ed0810de6b9166501d8f33a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a>&lt; TConstIteratorOnPoints, TValue &gt; &amp;object)</td></tr>
<tr class="memitem:ab3a7c82e86886176e1633ffa720003cb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab3a7c82e86886176e1633ffa720003cb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab3a7c82e86886176e1633ffa720003cb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CombinatorialDSS.html">CombinatorialDSS</a>&lt; T1, T2 &gt; &amp;object)</td></tr>
<tr class="memitem:a2e60731c3d380a3d904efbf5c088cf07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e60731c3d380a3d904efbf5c088cf07"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2e60731c3d380a3d904efbf5c088cf07">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:ac81440dbce679bb785c1679dc6b226af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac81440dbce679bb785c1679dc6b226af"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac81440dbce679bb785c1679dc6b226af">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a9611bc4af426ac90cd62f4f0d147d686"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9611bc4af426ac90cd62f4f0d147d686"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9611bc4af426ac90cd62f4f0d147d686">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a8b8a89999c5ec643ec73f257abe6c488"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b8a89999c5ec643ec73f257abe6c488"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b8a89999c5ec643ec73f257abe6c488">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a5b8eb9b80ef38f0b355c23ce44caec57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b8eb9b80ef38f0b355c23ce44caec57"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5b8eb9b80ef38f0b355c23ce44caec57">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a4b1f11e76731f6b53d58741593de1718"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b1f11e76731f6b53d58741593de1718"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4b1f11e76731f6b53d58741593de1718">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a3ebfff66f1d6cdbd2b15f83c2ee8c55b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ebfff66f1d6cdbd2b15f83c2ee8c55b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3ebfff66f1d6cdbd2b15f83c2ee8c55b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a6ba93e4cd388ebab2cb5ec533a303962"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr class="memitem:a6ba93e4cd388ebab2cb5ec533a303962"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6ba93e4cd388ebab2cb5ec533a303962">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FP.html">FP</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr class="memitem:afb8e4d60f980875ee264a4470c0cd39d"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger &gt; </td></tr>
<tr class="memitem:afb8e4d60f980875ee264a4470c0cd39d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afb8e4d60f980875ee264a4470c0cd39d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FrechetShortcut.html">FrechetShortcut</a>&lt; TIterator, TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a85c3c4d290e6b5c6de7e46b431d4c4fe"><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr class="memitem:a85c3c4d290e6b5c6de7e46b431d4c4fe"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a85c3c4d290e6b5c6de7e46b431d4c4fe">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a62707785131f3a712ab96fdc6525f956"><td class="memTemplParams" colspan="2">template&lt;typename TConstIterator &gt; </td></tr>
<tr class="memitem:a62707785131f3a712ab96fdc6525f956"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a62707785131f3a712ab96fdc6525f956">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GeometricalDCA.html">GeometricalDCA</a>&lt; TConstIterator &gt; &amp;object)</td></tr>
<tr class="memitem:af36416f9fdefcffddd2b2953f551257b"><td class="memTemplParams" colspan="2">template&lt;typename TConstIterator &gt; </td></tr>
<tr class="memitem:af36416f9fdefcffddd2b2953f551257b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af36416f9fdefcffddd2b2953f551257b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GeometricalDSS.html">GeometricalDSS</a>&lt; TConstIterator &gt; &amp;object)</td></tr>
<tr class="memitem:a52995248ae36d8cd61977cf8e37c63bc"><td class="memTemplParams" colspan="2">template&lt;typename SegmentComputer &gt; </td></tr>
<tr class="memitem:a52995248ae36d8cd61977cf8e37c63bc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a52995248ae36d8cd61977cf8e37c63bc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a>&lt; SegmentComputer &gt; &amp;object)</td></tr>
<tr class="memitem:a6f39f856a5dc3683cd3fdb8e22afa143"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a6f39f856a5dc3683cd3fdb8e22afa143"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6f39f856a5dc3683cd3fdb8e22afa143">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a86a932423c11c531c9ecfe4631704aab"><td class="memTemplParams" colspan="2">template&lt;typename SegmentComputer &gt; </td></tr>
<tr class="memitem:a86a932423c11c531c9ecfe4631704aab"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a86a932423c11c531c9ecfe4631704aab">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>&lt; SegmentComputer &gt; &amp;object)</td></tr>
<tr class="memitem:a8c4fb1b2976e5fc35dc1b4073149408e"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a8c4fb1b2976e5fc35dc1b4073149408e"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>)</td></tr>
<tr class="memitem:a9cf4e9405b276ba5b8b931f72d180d9d"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a9cf4e9405b276ba5b8b931f72d180d9d"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9cf4e9405b276ba5b8b931f72d180d9d">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>)</td></tr>
<tr class="memitem:a8f53c482fe83e31093accf95ec7190d9"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a8f53c482fe83e31093accf95ec7190d9"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8f53c482fe83e31093accf95ec7190d9">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>)</td></tr>
<tr class="memitem:a318f9e3e73cd0988af98b3a66a543334"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a318f9e3e73cd0988af98b3a66a543334"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a318f9e3e73cd0988af98b3a66a543334">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="memitem:a4718031e09102bb8f73a874c47e10aaf"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a4718031e09102bb8f73a874c47e10aaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="memitem:a367841808f36fa49eceaa1671718f3ee"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a367841808f36fa49eceaa1671718f3ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a367841808f36fa49eceaa1671718f3ee">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="memitem:a21c7d5ea8b24456694c6fa5f6a25f4cc"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a21c7d5ea8b24456694c6fa5f6a25f4cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a21c7d5ea8b24456694c6fa5f6a25f4cc">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a462eaaf587bc04ebd2e6141bed3fc21e"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a462eaaf587bc04ebd2e6141bed3fc21e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="memitem:a9f50b26bc3256332ab287e1bb2a3e7cf"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a9f50b26bc3256332ab287e1bb2a3e7cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f50b26bc3256332ab287e1bb2a3e7cf">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="memitem:a567c997ae858c829256cc8a13c04d230"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a567c997ae858c829256cc8a13c04d230"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a567c997ae858c829256cc8a13c04d230">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr class="memitem:ad8d73948fddeeb1f2e0fa94c4c9b03a9"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad8d73948fddeeb1f2e0fa94c4c9b03a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="memitem:a04bd5266c4907488dc943c3fd18b72a0"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a04bd5266c4907488dc943c3fd18b72a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a04bd5266c4907488dc943c3fd18b72a0">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="memitem:ad09a396e60a1ff248a246cc2f365fb31"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad09a396e60a1ff248a246cc2f365fb31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad09a396e60a1ff248a246cc2f365fb31">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:ad4831d5ff3c1c70bd1c6a26403297a9a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad4831d5ff3c1c70bd1c6a26403297a9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad4831d5ff3c1c70bd1c6a26403297a9a">maximalRetraction</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a137f26d321873e90065142afff6fa928"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a137f26d321873e90065142afff6fa928"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a137f26d321873e90065142afff6fa928">oppositeEndMaximalRetraction</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr class="memitem:a2034305fadb5376a987519daba4c982a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a2034305fadb5376a987519daba4c982a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="memitem:a67994f04a54230cdb524e46dba46a127"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a67994f04a54230cdb524e46dba46a127"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a67994f04a54230cdb524e46dba46a127">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="memitem:a464c32dc87cc7ded90f601f4657664a1"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a464c32dc87cc7ded90f601f4657664a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a464c32dc87cc7ded90f601f4657664a1">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:ae6d3175b6c7d86845a0c259f566bd7ea"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae6d3175b6c7d86845a0c259f566bd7ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:ae37d5f56ebcd83255b9c93038deff781"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae37d5f56ebcd83255b9c93038deff781"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae37d5f56ebcd83255b9c93038deff781">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a8b81102d807d1ec5629d25c6e13ddae7"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8b81102d807d1ec5629d25c6e13ddae7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b81102d807d1ec5629d25c6e13ddae7">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:aae8ba2a7a4a42e59741df4afed37f449"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:aae8ba2a7a4a42e59741df4afed37f449"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aae8ba2a7a4a42e59741df4afed37f449">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a18c5282eb177f64a2957c29bf51b0e1c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a18c5282eb177f64a2957c29bf51b0e1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a18c5282eb177f64a2957c29bf51b0e1c">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a1b3f25b1f654c74c78819624604e4950"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a1b3f25b1f654c74c78819624604e4950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:ad153558eaa4afb851f884b64680f4631"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad153558eaa4afb851f884b64680f4631"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad153558eaa4afb851f884b64680f4631">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a07a2cb535d2b0befce8f080d9d1a2414"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a07a2cb535d2b0befce8f080d9d1a2414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a07a2cb535d2b0befce8f080d9d1a2414">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:aa43392e8f5aeba868858b9b2c1e52cf7"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:aa43392e8f5aeba868858b9b2c1e52cf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa43392e8f5aeba868858b9b2c1e52cf7">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:adb7b7f5908ea811a44f41186c7a01e8e"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:adb7b7f5908ea811a44f41186c7a01e8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adb7b7f5908ea811a44f41186c7a01e8e">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a19f04b5f095862ee00e620f8246df2f8"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a19f04b5f095862ee00e620f8246df2f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:a8c5dc0554703f63c1ec705f764f2ba3a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8c5dc0554703f63c1ec705f764f2ba3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c5dc0554703f63c1ec705f764f2ba3a">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a652ebafea1d9e8891f40d9b0af8fcb02"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a652ebafea1d9e8891f40d9b0af8fcb02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a652ebafea1d9e8891f40d9b0af8fcb02">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:a47282aa7c7fc28d49e7a52a3f8eeee3c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a47282aa7c7fc28d49e7a52a3f8eeee3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a47282aa7c7fc28d49e7a52a3f8eeee3c">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:afa3e824f983193de48aaf18590edaa52"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:afa3e824f983193de48aaf18590edaa52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa3e824f983193de48aaf18590edaa52">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a91c1293187f38e931f5f353d1a38f71c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a91c1293187f38e931f5f353d1a38f71c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:a0f4fc5b05689abd850faa6637a64505c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a0f4fc5b05689abd850faa6637a64505c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0f4fc5b05689abd850faa6637a64505c">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a6ee548c7f570f6bdb18ce2cc592cb009"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a6ee548c7f570f6bdb18ce2cc592cb009"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6ee548c7f570f6bdb18ce2cc592cb009">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:ae9e6d98ecc15fc5062f30060d4452706"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae9e6d98ecc15fc5062f30060d4452706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae9e6d98ecc15fc5062f30060d4452706">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a325d2a962cd3410424a45f83c1b32b7a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a325d2a962cd3410424a45f83c1b32b7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a325d2a962cd3410424a45f83c1b32b7a">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:adabb9ea04f81cba914f3ac178439ffd4"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:adabb9ea04f81cba914f3ac178439ffd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:a8e35d35160afaea835678e7bf4a3458c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8e35d35160afaea835678e7bf4a3458c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8e35d35160afaea835678e7bf4a3458c">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:afa1f75e59b72ea5e69760c965e20b3ff"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:afa1f75e59b72ea5e69760c965e20b3ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa1f75e59b72ea5e69760c965e20b3ff">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:ad14e74091568436294698404dc08c9c5"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad14e74091568436294698404dc08c9c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad14e74091568436294698404dc08c9c5">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:af03fbf680fc202a21ef0801ee9240934"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:af03fbf680fc202a21ef0801ee9240934"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af03fbf680fc202a21ef0801ee9240934">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr class="memitem:a3e210a0da2db0fe767f88859a7ec00ba"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3e210a0da2db0fe767f88859a7ec00ba">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a> &amp;object)</td></tr>
<tr class="memitem:a97a5060ed0aa5b031edef61dd369aafd"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TInternalInteger &gt; </td></tr>
<tr class="memitem:a97a5060ed0aa5b031edef61dd369aafd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a97a5060ed0aa5b031edef61dd369aafd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1COBAGenericNaivePlane.html">COBAGenericNaivePlane</a>&lt; TSpace, TInternalInteger &gt; &amp;object)</td></tr>
<tr class="memitem:ae591e8cecb39b8f25c2ffa65929ce1d7"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TInternalInteger &gt; </td></tr>
<tr class="memitem:ae591e8cecb39b8f25c2ffa65929ce1d7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae591e8cecb39b8f25c2ffa65929ce1d7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1COBANaivePlane.html">COBANaivePlane</a>&lt; TSpace, TInternalInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a311a8c89ec31846a61238a44a48c51c9"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceEmbedder , typename TNormalVectorEstimator &gt; </td></tr>
<tr class="memitem:a311a8c89ec31846a61238a44a48c51c9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a311a8c89ec31846a61238a44a48c51c9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>&lt; TDigitalSurfaceEmbedder, TNormalVectorEstimator &gt; &amp;object)</td></tr>
<tr class="memitem:a855e675db4e5e115051b87a6c79c6f36"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurface , typename TNormalVectorEstimator , typename TEmbedder &gt; </td></tr>
<tr class="memitem:a855e675db4e5e115051b87a6c79c6f36"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a855e675db4e5e115051b87a6c79c6f36">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a>&lt; TDigitalSurface, TNormalVectorEstimator, TEmbedder &gt; &amp;object)</td></tr>
<tr class="memitem:af1add10c7a26535a4feb8d370bd6fb4e"><td class="memTemplParams" colspan="2">template&lt;typename Shape &gt; </td></tr>
<tr class="memitem:af1add10c7a26535a4feb8d370bd6fb4e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af1add10c7a26535a4feb8d370bd6fb4e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a>&lt; Shape &gt; &amp;object)</td></tr>
<tr class="memitem:aed3c31b50222da39a5484940fa7c7987"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed3c31b50222da39a5484940fa7c7987"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aed3c31b50222da39a5484940fa7c7987">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SphericalAccumulator.html">SphericalAccumulator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:ad3c376126e05e1f797bb688366dd30f5"><td class="memTemplParams" colspan="2">template&lt;typename TImage , typename TSet , typename TPointPredicate , typename TPointFunctor &gt; </td></tr>
<tr class="memitem:ad3c376126e05e1f797bb688366dd30f5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad3c376126e05e1f797bb688366dd30f5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FMM.html">FMM</a>&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt; &amp;object)</td></tr>
<tr class="memitem:a71ebae2f928719f51222d9830f580ab6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71ebae2f928719f51222d9830f580ab6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a71ebae2f928719f51222d9830f580ab6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Measure.html">Measure</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a9353d51816abd73c77d05aa44b5298ed"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer , typename TNewDomain , typename TFunctorD , typename TNewValue , typename TFunctorV &gt; </td></tr>
<tr class="memitem:a9353d51816abd73c77d05aa44b5298ed"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9353d51816abd73c77d05aa44b5298ed">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ConstImageAdapter.html">ConstImageAdapter</a>&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV &gt; &amp;object)</td></tr>
<tr class="memitem:a3611cd19b341d3f70a23a0023e6aff2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3611cd19b341d3f70a23a0023e6aff2d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3611cd19b341d3f70a23a0023e6aff2d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Image.html">Image</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:aa5fc9d51f585b97ec5094a8a7792ea44"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer , typename TNewDomain , typename TFunctorD , typename TNewValue , typename TFunctorV , typename TFunctorVm1 &gt; </td></tr>
<tr class="memitem:aa5fc9d51f585b97ec5094a8a7792ea44"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa5fc9d51f585b97ec5094a8a7792ea44">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageAdapter.html">ImageAdapter</a>&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV, TFunctorVm1 &gt; &amp;object)</td></tr>
<tr class="memitem:adcd8d9d47caf12b58c0270ee77c7ec5e"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue , typename THashKey &gt; </td></tr>
<tr class="memitem:adcd8d9d47caf12b58c0270ee77c7ec5e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adcd8d9d47caf12b58c0270ee77c7ec5e">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classDGtal_1_1ImageContainerByHashTree.html">ImageContainerByHashTree</a>&lt; TDomain, TValue, THashKey &gt; &amp;object)</td></tr>
<tr class="memitem:ad5f4caac3598001543faa58512905fa1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TV &gt; </td></tr>
<tr class="memitem:ad5f4caac3598001543faa58512905fa1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad5f4caac3598001543faa58512905fa1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">experimental::ImageContainerByITKImage</a>&lt; T, TV &gt; &amp;object)</td></tr>
<tr class="memitem:a44bf615980e20b3cd46b582b7141a6a4"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue &gt; </td></tr>
<tr class="memitem:a44bf615980e20b3cd46b582b7141a6a4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a44bf615980e20b3cd46b582b7141a6a4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">experimental::ImageContainerByITKImage</a>&lt; TDomain, TValue &gt; &amp;object)</td></tr>
<tr class="memitem:a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue &gt; </td></tr>
<tr class="memitem:a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>&lt; TDomain, TValue &gt; &amp;object)</td></tr>
<tr class="memitem:afec460eda081b4dc6922174819cae6cc"><td class="memTemplParams" colspan="2">template&lt;typename Domain , typename V &gt; </td></tr>
<tr class="memitem:afec460eda081b4dc6922174819cae6cc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afec460eda081b4dc6922174819cae6cc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt; Domain, V &gt; &amp;object)</td></tr>
<tr class="memitem:ad67647d42db11b7b3d3533e1cba6c2ba"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename P &gt; </td></tr>
<tr class="memitem:ad67647d42db11b7b3d3533e1cba6c2ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad67647d42db11b7b3d3533e1cba6c2ba">setFromPointsRangeAndPredicate</a> (const I &amp;itb, const I &amp;ite, const O &amp;ito, const P &amp;aPred)</td></tr>
<tr class="memitem:ad57d4465e40fe4c1982ec2e01985be73"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename F &gt; </td></tr>
<tr class="memitem:ad57d4465e40fe4c1982ec2e01985be73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad57d4465e40fe4c1982ec2e01985be73">setFromPointsRangeAndFunctor</a> (const I &amp;itb, const I &amp;ite, const O &amp;ito, const F &amp;aFunctor, const typename F::Value &amp;aThreshold=0)</td></tr>
<tr class="memitem:a202be24e94b5bdfba2d8563d0947f373"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:a202be24e94b5bdfba2d8563d0947f373"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a202be24e94b5bdfba2d8563d0947f373">setFromImage</a> (const I &amp;aImg, const O &amp;ito, const typename I::Value &amp;aThreshold=0)</td></tr>
<tr class="memitem:aecddf53312d4b765f34a022b049627c3"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:aecddf53312d4b765f34a022b049627c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aecddf53312d4b765f34a022b049627c3">setFromImage</a> (const I &amp;aImg, const O &amp;ito, const typename I::Value &amp;low, const typename I::Value &amp;up)</td></tr>
<tr class="memitem:ac1511d84bd2b82df82bea3aefc3af2dd"><td class="memTemplParams" colspan="2">template&lt;typename It , typename Im &gt; </td></tr>
<tr class="memitem:ac1511d84bd2b82df82bea3aefc3af2dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1511d84bd2b82df82bea3aefc3af2dd">imageFromRangeAndValue</a> (const It &amp;itb, const It &amp;ite, Im &amp;aImg, const typename Im::Value &amp;aValue=0)</td></tr>
<tr class="memitem:aff03c6c44f0ec8ad182440aad1b4e86a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I &gt; </td></tr>
<tr class="memitem:aff03c6c44f0ec8ad182440aad1b4e86a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aff03c6c44f0ec8ad182440aad1b4e86a">imageFromRangeAndValue</a> (const R &amp;aRange, I &amp;aImg, const typename I::Value &amp;aValue=0)</td></tr>
<tr class="memitem:a46234d3693677caa52b0ffb6db059d5d"><td class="memTemplParams" colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:a46234d3693677caa52b0ffb6db059d5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a46234d3693677caa52b0ffb6db059d5d">imageFromFunctor</a> (I &amp;aImg, const F &amp;aFun)</td></tr>
<tr class="memitem:a6e6f5a9c305d047a2e9c6315ca17832c"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a6e6f5a9c305d047a2e9c6315ca17832c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6e6f5a9c305d047a2e9c6315ca17832c">imageFromImage</a> (I &amp;aImg1, const I &amp;aImg2)</td></tr>
<tr class="memitem:a5f01a70f2cf84e9c08d1308e77911a08"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a5f01a70f2cf84e9c08d1308e77911a08"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> (I &amp;aImg, S &amp;aSet, const typename I::Point &amp;aPoint, const typename I::Value &amp;aValue)</td></tr>
<tr class="memitem:ac920bc98f866a2e17ee53faddc67ff80"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:ac920bc98f866a2e17ee53faddc67ff80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac920bc98f866a2e17ee53faddc67ff80">insertAndAlwaysSetValue</a> (I &amp;aImg, S &amp;aSet, const typename I::Point &amp;aPoint, const typename I::Value &amp;aValue)</td></tr>
<tr class="memitem:a3f73d6217f05eef8225781a523efc077"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a3f73d6217f05eef8225781a523efc077"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3f73d6217f05eef8225781a523efc077">findAndGetValue</a> (const I &amp;aImg, const S &amp;aSet, const typename I::Point &amp;aPoint, typename I::Value &amp;aValue)</td></tr>
<tr class="memitem:a7272fa4a71b37b89de44110188769338"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage , typename TEmbedder &gt; </td></tr>
<tr class="memitem:a7272fa4a71b37b89de44110188769338"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7272fa4a71b37b89de44110188769338">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html">ImageLinearCellEmbedder</a>&lt; TKSpace, TImage, TEmbedder &gt; &amp;object)</td></tr>
<tr class="memitem:ac3c6d87ade0e0da551f72c4e645771e1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac3c6d87ade0e0da551f72c4e645771e1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board2D.html">Board2D</a> &amp;object)</td></tr>
<tr class="memitem:aa32e43bdffbdc24f45de94ad9102978a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa32e43bdffbdc24f45de94ad9102978a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a> &amp;object)</td></tr>
<tr class="memitem:abb59a7087b1ca526c94078e5cc499672"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abb59a7087b1ca526c94078e5cc499672">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Color.html">Color</a> &amp;aColor)</td></tr>
<tr class="memitem:a0cadab732dfb13c3b84f49566f5b9c11"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int PDefaultColor&gt; </td></tr>
<tr class="memitem:a0cadab732dfb13c3b84f49566f5b9c11"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0cadab732dfb13c3b84f49566f5b9c11">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a>&lt; PValue, PDefaultColor &gt; &amp;object)</td></tr>
<tr class="memitem:a1cfec935d23b12fc18c32eece2a8ab1e"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int PDefaultPreset, int PDefaultFirstColor, int PDefaultLastColor&gt; </td></tr>
<tr class="memitem:a1cfec935d23b12fc18c32eece2a8ab1e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1cfec935d23b12fc18c32eece2a8ab1e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a>&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;object)</td></tr>
<tr class="memitem:a485151b618f71a80d057c3c7d35e84ca"><td class="memTemplParams" colspan="2">template&lt;typename PValue &gt; </td></tr>
<tr class="memitem:a485151b618f71a80d057c3c7d35e84ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a485151b618f71a80d057c3c7d35e84ca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a>&lt; PValue &gt; &amp;object)</td></tr>
<tr class="memitem:a69f3490f30f770c8fc9fc6dd445cd93c"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int DefaultCycles&gt; </td></tr>
<tr class="memitem:a69f3490f30f770c8fc9fc6dd445cd93c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a69f3490f30f770c8fc9fc6dd445cd93c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a>&lt; PValue, DefaultCycles &gt; &amp;object)</td></tr>
<tr class="memitem:a0862dd8a38f8e16ed9bc34ad6ba2bc55"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0862dd8a38f8e16ed9bc34ad6ba2bc55">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a> &amp;object)</td></tr>
<tr class="memitem:a7b632be90297f1d6a81a58c1a0a4bdc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7b632be90297f1d6a81a58c1a0a4bdc3">cross</a> (double dst[3], double srcA[3], double srcB[3])</td></tr>
<tr class="memitem:a5953d43d65a342438b932b5fac6a0334"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5953d43d65a342438b932b5fac6a0334">normalize</a> (double vec[3])</td></tr>
<tr class="memitem:ae515a588c9f74ac323d60f95bc8bedb9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae515a588c9f74ac323d60f95bc8bedb9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Display3D.html">DGtal::Display3D</a> &amp;object)</td></tr>
<tr class="memitem:ac53021bc0d5dc675ed32631396cac05d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac53021bc0d5dc675ed32631396cac05d">operator&gt;&gt;</a> (const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a> &amp;aDisplay3D, <a class="el" href="classDGtal_1_1MeshFromPoints.html">DGtal::MeshFromPoints</a>&lt; <a class="el" href="structDGtal_1_1Display3D_1_1pointD3D.html">Display3D::pointD3D</a> &gt; &amp;aMesh)</td></tr>
<tr class="memitem:aa24e0992d0b4c61469dbf5da726718c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa24e0992d0b4c61469dbf5da726718c4">operator&gt;&gt;</a> (const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a> &amp;aDisplay3D, string aFilename)</td></tr>
<tr class="memitem:a027b1488a4625548cc76d8f70b640f5a"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a027b1488a4625548cc76d8f70b640f5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a027b1488a4625548cc76d8f70b640f5a">operator&lt;&lt;</a> (<a class="el" href="classDGtal_1_1MeshFromPoints.html">MeshFromPoints</a>&lt; TPoint &gt; &amp;mesh, const std::string &amp;filename)</td></tr>
<tr class="memitem:a008281343ea4fc3971b69a6543b9b842"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a008281343ea4fc3971b69a6543b9b842"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a008281343ea4fc3971b69a6543b9b842">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DGtalInventor.html">DGtalInventor</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:adbf9270f5f724d5e51d1356f3372783c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adbf9270f5f724d5e51d1356f3372783c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IVViewer.html">IVViewer</a> &amp;object)</td></tr>
<tr class="memitem:a2d3fcda6867c1a6cae9a2011a8c1b30c"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a2d3fcda6867c1a6cae9a2011a8c1b30c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2d3fcda6867c1a6cae9a2011a8c1b30c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Lattice.html">Lattice</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:ac2a53895055b003622553da7cb636570"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac2a53895055b003622553da7cb636570">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> &amp;object)</td></tr>
<tr class="memitem:a7da2e4ec36c07db836f12a3b829c4961"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a7da2e4ec36c07db836f12a3b829c4961"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7da2e4ec36c07db836f12a3b829c4961">operator&gt;&gt;</a> (<a class="el" href="classDGtal_1_1MeshFromPoints.html">MeshFromPoints</a>&lt; TPoint &gt; &amp;aMesh, const std::string &amp;aFilename)</td></tr>
<tr class="memitem:aee8aa91a2345d8315df394b94de70f99"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:aee8aa91a2345d8315df394b94de70f99"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aee8aa91a2345d8315df394b94de70f99">operator&gt;&gt;</a> (<a class="el" href="classDGtal_1_1MeshFromPoints.html">MeshFromPoints</a>&lt; TPoint &gt; &amp;aMesh, ostream &amp;out)</td></tr>
<tr class="memitem:a61e5d3bce501d46ca6cb4baee8590389"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a61e5d3bce501d46ca6cb4baee8590389"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a61e5d3bce501d46ca6cb4baee8590389">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="memitem:abbf878eedd1e61f021f337b903ac1a5e"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurface &gt; </td></tr>
<tr class="memitem:abbf878eedd1e61f021f337b903ac1a5e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abbf878eedd1e61f021f337b903ac1a5e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a>&lt; TDigitalSurface &gt; &amp;object)</td></tr>
<tr class="memitem:a1c198285c212e189cc6b3775282d971b"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a1c198285c212e189cc6b3775282d971b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c198285c212e189cc6b3775282d971b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:afc39fa68fdb704b43c5f89b871030b30"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:afc39fa68fdb704b43c5f89b871030b30"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afc39fa68fdb704b43c5f89b871030b30">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a65fe5e7517f127b50ab8d9daa779a55e"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a65fe5e7517f127b50ab8d9daa779a55e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a65fe5e7517f127b50ab8d9daa779a55e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a44d1dd3f9097cf9d2b7f280c95e34b1e"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Container &gt; </td></tr>
<tr class="memitem:a44d1dd3f9097cf9d2b7f280c95e34b1e"><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a44d1dd3f9097cf9d2b7f280c95e34b1e">setDimensionsIn</a> (const Container &amp;dimensions)</td></tr>
<tr class="memitem:ae405036e4e10cc9ecee7918e5fb10dd9"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Container &gt; </td></tr>
<tr class="memitem:ae405036e4e10cc9ecee7918e5fb10dd9"><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae405036e4e10cc9ecee7918e5fb10dd9">setDimensionsNotIn</a> (const Container &amp;dimensions)</td></tr>
<tr class="memitem:a484bbc565292ed3fd276d70c3e71afac"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Component &gt; </td></tr>
<tr class="memitem:a484bbc565292ed3fd276d70c3e71afac"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a484bbc565292ed3fd276d70c3e71afac">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; dim, Component &gt; &amp;object)</td></tr>
<tr class="memitem:aa22cc58968d7134d4ec338d8b6d49f47"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:aa22cc58968d7134d4ec338d8b6d49f47"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa22cc58968d7134d4ec338d8b6d49f47">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a294f23451c7c99ae08e19bd5eea76469"><td class="memTemplParams" colspan="2">template&lt;typename Domain &gt; </td></tr>
<tr class="memitem:a294f23451c7c99ae08e19bd5eea76469"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a294f23451c7c99ae08e19bd5eea76469">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a>&lt; Domain &gt; &amp;object)</td></tr>
<tr class="memitem:a133f736b6505cf0359ccc7e8be803c46"><td class="memTemplParams" colspan="2">template&lt;typename Domain &gt; </td></tr>
<tr class="memitem:a133f736b6505cf0359ccc7e8be803c46"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a133f736b6505cf0359ccc7e8be803c46">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a>&lt; Domain &gt; &amp;object)</td></tr>
<tr class="memitem:a64c1c0996bfe10bd42952cad2d72ecdb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64c1c0996bfe10bd42952cad2d72ecdb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a64c1c0996bfe10bd42952cad2d72ecdb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a6f97c9e9c01d4864725d8d606a5535a6"><td class="memTemplParams" colspan="2">template&lt;typename TMapImage &gt; </td></tr>
<tr class="memitem:a6f97c9e9c01d4864725d8d606a5535a6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6f97c9e9c01d4864725d8d606a5535a6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap</a>&lt; TMapImage &gt; &amp;object)</td></tr>
<tr class="memitem:a1c7a202da7d028af6c2565026014318c"><td class="memTemplParams" colspan="2">template&lt;typename T , DGtal::Dimension M, DGtal::Dimension N&gt; </td></tr>
<tr class="memitem:a1c7a202da7d028af6c2565026014318c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c7a202da7d028af6c2565026014318c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a>&lt; T, M, N &gt; &amp;object)</td></tr>
<tr class="memitem:a5684b6b55398b599ed5aaa9a70f3a0cc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5684b6b55398b599ed5aaa9a70f3a0cc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a> &amp;object)</td></tr>
<tr class="memitem:a0c685b28cb1a025847d30274b28d0edd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0c685b28cb1a025847d30274b28d0edd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a> &amp;object)</td></tr>
<tr class="memitem:a2bbdffe7efc4f8af031964cecfe477a7"><td class="memTemplParams" colspan="2">template&lt;typename TRing , typename TAlloc &gt; </td></tr>
<tr class="memitem:a2bbdffe7efc4f8af031964cecfe477a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;r)</td></tr>
<tr class="memitem:aade413b000d41b595aa32414aaa564a9"><td class="memTemplParams" colspan="2">template&lt;int N, typename TRing , class TAlloc &gt; </td></tr>
<tr class="memitem:aade413b000d41b595aa32414aaa564a9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aade413b000d41b595aa32414aaa564a9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; N, TRing, TAlloc &gt; &amp;object)</td></tr>
<tr class="memitem:a948cc02e8fe7e8ab1051bce164421fa8"><td class="memTemplParams" colspan="2">template&lt;int n, typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a948cc02e8fe7e8ab1051bce164421fa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a948cc02e8fe7e8ab1051bce164421fa8">Xe_k</a> (unsigned int k, unsigned int e)</td></tr>
<tr class="memitem:ad099005ab7d493b2ea19026e2fb96a32"><td class="memTemplParams" colspan="2">template&lt;int n, typename Ring &gt; </td></tr>
<tr class="memitem:ad099005ab7d493b2ea19026e2fb96a32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad099005ab7d493b2ea19026e2fb96a32">Xe_k</a> (unsigned int k, unsigned int e)</td></tr>
<tr class="memitem:a770659cf50cd49c0ce6c3d4ab08abb46"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a770659cf50cd49c0ce6c3d4ab08abb46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">mmonomial</a> (unsigned int e)</td></tr>
<tr class="memitem:ad04b582eb75ae0cfc14dfc40d57c03f2"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:ad04b582eb75ae0cfc14dfc40d57c03f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 2, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad04b582eb75ae0cfc14dfc40d57c03f2">mmonomial</a> (unsigned int e, unsigned int f)</td></tr>
<tr class="memitem:a46b41f1ac0f88d213c7fb8bee8931799"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a46b41f1ac0f88d213c7fb8bee8931799"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 3, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a46b41f1ac0f88d213c7fb8bee8931799">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g)</td></tr>
<tr class="memitem:ae6ba6c1f73137c9da0365c16635c92e9"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:ae6ba6c1f73137c9da0365c16635c92e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 4, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae6ba6c1f73137c9da0365c16635c92e9">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g, unsigned int h)</td></tr>
<tr class="memitem:a9ef248272fbf9b379c272e0ec632289c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a9ef248272fbf9b379c272e0ec632289c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9ef248272fbf9b379c272e0ec632289c">mmonomial</a> (unsigned int e)</td></tr>
<tr class="memitem:a9ac70e986a68541f5a9e2b9a4035da2c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a9ac70e986a68541f5a9e2b9a4035da2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 2, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9ac70e986a68541f5a9e2b9a4035da2c">mmonomial</a> (unsigned int e, unsigned int f)</td></tr>
<tr class="memitem:a4f44e0a9fc1e30d29e52646daeca211d"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a4f44e0a9fc1e30d29e52646daeca211d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 3, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4f44e0a9fc1e30d29e52646daeca211d">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g)</td></tr>
<tr class="memitem:a4a679186eed201b0844c7bf6f83e76c8"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a4a679186eed201b0844c7bf6f83e76c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 4, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4a679186eed201b0844c7bf6f83e76c8">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g, unsigned int h)</td></tr>
<tr class="memitem:afd55a2a73cd7b4552dbaf0b62980b323"><td class="memTemplParams" colspan="2">template&lt;int N, int n, typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:afd55a2a73cd7b4552dbaf0b62980b323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afd55a2a73cd7b4552dbaf0b62980b323">derivative</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt; &amp;p)</td></tr>
<tr class="memitem:a9aedf0fbd5b7c5814911d1299be81cb9"><td class="memTemplParams" colspan="2">template&lt;int N, int n, typename Ring &gt; </td></tr>
<tr class="memitem:a9aedf0fbd5b7c5814911d1299be81cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9aedf0fbd5b7c5814911d1299be81cb9">derivative</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, std::allocator&lt; Ring &gt; &gt; &amp;p)</td></tr>
<tr class="memitem:afc4718ecc21bcecf1618414e982b951c"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:afc4718ecc21bcecf1618414e982b951c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afc4718ecc21bcecf1618414e982b951c">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;r)</td></tr>
<tr class="memitem:a57e756b9529892b5019066b6d4a4310c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a57e756b9529892b5019066b6d4a4310c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a57e756b9529892b5019066b6d4a4310c">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;r)</td></tr>
<tr class="memitem:a38fc7e3a7ad4420d8b0b5950ae21c32e"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a38fc7e3a7ad4420d8b0b5950ae21c32e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a38fc7e3a7ad4420d8b0b5950ae21c32e">gcd</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;g)</td></tr>
<tr class="memitem:ab28649140d0b09a9b25515660a3e6f12"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:ab28649140d0b09a9b25515660a3e6f12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab28649140d0b09a9b25515660a3e6f12">gcd</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;g)</td></tr>
<tr class="memitem:a7bf8ccb5fec38dffae46efd2c0d5c2c7"><td class="memTemplParams" colspan="2">template&lt;typename TValue &gt; </td></tr>
<tr class="memitem:a7bf8ccb5fec38dffae46efd2c0d5c2c7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7bf8ccb5fec38dffae46efd2c0d5c2c7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Signal.html">Signal</a>&lt; TValue &gt; &amp;object)</td></tr>
<tr class="memitem:a585a463f4055c1df3774c34bc4d1c5fb"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a585a463f4055c1df3774c34bc4d1c5fb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a585a463f4055c1df3774c34bc4d1c5fb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="memitem:a5ee88b42fe08c64c833f2b785139063c"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a5ee88b42fe08c64c833f2b785139063c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5ee88b42fe08c64c833f2b785139063c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="memitem:a3af9b163e8918cad50ffea5f1195887a"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a3af9b163e8918cad50ffea5f1195887a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3af9b163e8918cad50ffea5f1195887a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MeshFromPoints.html">MeshFromPoints</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="memitem:a8b6273f070d1edcf9c510601044863d4"><td class="memTemplParams" colspan="2">template&lt;typename TSurface , bool isUpward, bool isClosed&gt; </td></tr>
<tr class="memitem:a8b6273f070d1edcf9c510601044863d4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b6273f070d1edcf9c510601044863d4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Point2ShapePredicate.html">Point2ShapePredicate</a>&lt; TSurface, isUpward, isClosed &gt; &amp;object)</td></tr>
<tr class="memitem:a9c9db375c56d37d5a38a7599c7e02e07"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a9c9db375c56d37d5a38a7599c7e02e07"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9c9db375c56d37d5a38a7599c7e02e07">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="memitem:aebacbf3c61709a7e0d1fc250f1f0204f"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TEuclideanShape &gt; </td></tr>
<tr class="memitem:aebacbf3c61709a7e0d1fc250f1f0204f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aebacbf3c61709a7e0d1fc250f1f0204f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a>&lt; TSpace, TEuclideanShape &gt; &amp;object)</td></tr>
<tr class="memitem:abd178d36151704c1413d4ad614e7f774"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd178d36151704c1413d4ad614e7f774"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abd178d36151704c1413d4ad614e7f774">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:accdbde97ed9607a15ec962171d6d933e"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImplicitFunctionDiff1 , typename TEmbedder &gt; </td></tr>
<tr class="memitem:accdbde97ed9607a15ec962171d6d933e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#accdbde97ed9607a15ec962171d6d933e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html">ImplicitFunctionDiff1LinearCellEmbedder</a>&lt; TKSpace, TImplicitFunctionDiff1, TEmbedder &gt; &amp;object)</td></tr>
<tr class="memitem:aeebf10a683d3e958f2b53c11af2e8548"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImplicitFunction , typename TEmbedder &gt; </td></tr>
<tr class="memitem:aeebf10a683d3e958f2b53c11af2e8548"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aeebf10a683d3e958f2b53c11af2e8548">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html">ImplicitFunctionLinearCellEmbedder</a>&lt; TKSpace, TImplicitFunction, TEmbedder &gt; &amp;object)</td></tr>
<tr class="memitem:a8a88c744566a4a1adce2dd7d55256bbd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a88c744566a4a1adce2dd7d55256bbd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8a88c744566a4a1adce2dd7d55256bbd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a670552923873f4f08a0c8d2ecf75cbe9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a670552923873f4f08a0c8d2ecf75cbe9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a670552923873f4f08a0c8d2ecf75cbe9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a31c3aec34372e12bb2a4b530ebefb1b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31c3aec34372e12bb2a4b530ebefb1b6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a31c3aec34372e12bb2a4b530ebefb1b6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a094a29952a05e86998aaf467bb013d1b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a094a29952a05e86998aaf467bb013d1b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a094a29952a05e86998aaf467bb013d1b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a9d6116d3f522841ef300a0a3d0a22dd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d6116d3f522841ef300a0a3d0a22dd6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9d6116d3f522841ef300a0a3d0a22dd6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a1d0842bcae55bdd9b262e906c5b3a79d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d0842bcae55bdd9b262e906c5b3a79d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1d0842bcae55bdd9b262e906c5b3a79d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:ac4e8f6819676918bd7ecac2e88e847f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4e8f6819676918bd7ecac2e88e847f7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac4e8f6819676918bd7ecac2e88e847f7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ball3D.html">Ball3D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a0e209bc654b6b3088e3d880d4eb24a96"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e209bc654b6b3088e3d880d4eb24a96"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0e209bc654b6b3088e3d880d4eb24a96">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a87b130f95ae2c59b8ce9a2d9b3eb00eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87b130f95ae2c59b8ce9a2d9b3eb00eb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a87b130f95ae2c59b8ce9a2d9b3eb00eb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:ae1caecda191f889867656183eabae2f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1caecda191f889867656183eabae2f7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae1caecda191f889867656183eabae2f7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a0da05652e14a44efd06ab37c830fb00c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0da05652e14a44efd06ab37c830fb00c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0da05652e14a44efd06ab37c830fb00c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a6dd73f56ae05b88cb69f61caff00d5ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6dd73f56ae05b88cb69f61caff00d5ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6dd73f56ae05b88cb69f61caff00d5ca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a30df8b8fe139c899b9f825d7e5f6398d"><td class="memTemplParams" colspan="2">template&lt;typename TDomain &gt; </td></tr>
<tr class="memitem:a30df8b8fe139c899b9f825d7e5f6398d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30df8b8fe139c899b9f825d7e5f6398d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Shapes.html">Shapes</a>&lt; TDomain &gt; &amp;object)</td></tr>
<tr class="memitem:a60cb8329ec7e317f1beb03c8b322cf13"><td class="memTemplParams" colspan="2">template&lt;typename TGraph , typename TMarkSet &gt; </td></tr>
<tr class="memitem:a60cb8329ec7e317f1beb03c8b322cf13"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a60cb8329ec7e317f1beb03c8b322cf13">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor</a>&lt; TGraph, TMarkSet &gt; &amp;object)</td></tr>
<tr class="memitem:a45e13e373849988b8c7143a6c6c0b58e"><td class="memTemplParams" colspan="2">template&lt;typename TGraph , typename TMarkSet &gt; </td></tr>
<tr class="memitem:a45e13e373849988b8c7143a6c6c0b58e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a45e13e373849988b8c7143a6c6c0b58e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DepthFirstVisitor.html">DepthFirstVisitor</a>&lt; TGraph, TMarkSet &gt; &amp;object)</td></tr>
<tr class="memitem:a8600426252610144c749a003e93274f6"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TDigitalSet &gt; </td></tr>
<tr class="memitem:a8600426252610144c749a003e93274f6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8600426252610144c749a003e93274f6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a>&lt; TKSpace, TDigitalSet &gt; &amp;object)</td></tr>
<tr class="memitem:a1f3fe65ff2eec5a590b6a2c550725e7e"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceContainer &gt; </td></tr>
<tr class="memitem:a1f3fe65ff2eec5a590b6a2c550725e7e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1f3fe65ff2eec5a590b6a2c550725e7e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &amp;object)</td></tr>
<tr class="memitem:a432b6b35fc11ee6b9c11fb54d193b366"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceTracker &gt; </td></tr>
<tr class="memitem:a432b6b35fc11ee6b9c11fb54d193b366"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a432b6b35fc11ee6b9c11fb54d193b366">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html">DigitalSurface2DSlice</a>&lt; TDigitalSurfaceTracker &gt; &amp;object)</td></tr>
<tr class="memitem:aa8be5db54eccfba7fd8916763cbf00da"><td class="memTemplParams" colspan="2">template&lt;typename TForegroundAdjacency , typename TBackgroundAdjacency &gt; </td></tr>
<tr class="memitem:aa8be5db54eccfba7fd8916763cbf00da"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa8be5db54eccfba7fd8916763cbf00da">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a>&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;object)</td></tr>
<tr class="memitem:ac9e45359f1676fa161c263f50cbee30d"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TAdjacency &gt; </td></tr>
<tr class="memitem:ac9e45359f1676fa161c263f50cbee30d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac9e45359f1676fa161c263f50cbee30d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a>&lt; TDomain, TAdjacency &gt; &amp;object)</td></tr>
<tr class="memitem:aa92bbcb0c90cddb06c7f84134c1e4a5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa92bbcb0c90cddb06c7f84134c1e4a5f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa92bbcb0c90cddb06c7f84134c1e4a5f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Expander.html">Expander</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:ac2a3ce65944bf6a16aeb2ebce2c9cd00"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelPredicate &gt; </td></tr>
<tr class="memitem:ac2a3ce65944bf6a16aeb2ebce2c9cd00"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac2a3ce65944bf6a16aeb2ebce2c9cd00">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;object)</td></tr>
<tr class="memitem:af0a7679f68647399382399dc1608a6dc"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage &gt; </td></tr>
<tr class="memitem:af0a7679f68647399382399dc1608a6dc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af0a7679f68647399382399dc1608a6dc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BoundaryPredicate.html">BoundaryPredicate</a>&lt; TKSpace, TImage &gt; &amp;object)</td></tr>
<tr class="memitem:ac60851b0fad3cc7d11289811fd942728"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage &gt; </td></tr>
<tr class="memitem:ac60851b0fad3cc7d11289811fd942728"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac60851b0fad3cc7d11289811fd942728">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FrontierPredicate.html">FrontierPredicate</a>&lt; TKSpace, TImage &gt; &amp;object)</td></tr>
<tr class="memitem:a1b2bc070ca54bd515c2948faae24b179"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a1b2bc070ca54bd515c2948faae24b179"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1b2bc070ca54bd515c2948faae24b179">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="memitem:aa8c04085996bfcb483774f35e6a6ffda"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate &gt; </td></tr>
<tr class="memitem:aa8c04085996bfcb483774f35e6a6ffda"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa8c04085996bfcb483774f35e6a6ffda">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;object)</td></tr>
<tr class="memitem:a105d0f6359b68e48600e22cf765f4aaa"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a105d0f6359b68e48600e22cf765f4aaa"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a105d0f6359b68e48600e22cf765f4aaa">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a075acfb401c86aea97863e49764f7e74"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a075acfb401c86aea97863e49764f7e74"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a075acfb401c86aea97863e49764f7e74">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:ac9d84c5b0391cb2973795d314b7a26ca"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:ac9d84c5b0391cb2973795d314b7a26ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac9d84c5b0391cb2973795d314b7a26ca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a55f2044bafa880126f92373e30027115"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelPredicate &gt; </td></tr>
<tr class="memitem:a55f2044bafa880126f92373e30027115"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a55f2044bafa880126f92373e30027115">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;object)</td></tr>
<tr class="memitem:a5694066261d35cce4631775ccc2596e4"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate &gt; </td></tr>
<tr class="memitem:a5694066261d35cce4631775ccc2596e4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5694066261d35cce4631775ccc2596e4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;object)</td></tr>
<tr class="memitem:aa8e4002c881f8a192a8185c3a0a80d1e"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , Dimension maxNorm1&gt; </td></tr>
<tr class="memitem:aa8e4002c881f8a192a8185c3a0a80d1e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa8e4002c881f8a192a8185c3a0a80d1e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a>&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;object)</td></tr>
<tr class="memitem:ad3071ce24e8bfd8044515d2e8bf31b0a"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalTopology , typename TDigitalSet &gt; </td></tr>
<tr class="memitem:ad3071ce24e8bfd8044515d2e8bf31b0a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad3071ce24e8bfd8044515d2e8bf31b0a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Object.html">Object</a>&lt; TDigitalTopology, TDigitalSet &gt; &amp;object)</td></tr>
<tr class="memitem:a25bbd127be81b65901f94e0247fbd4b9"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelSet &gt; </td></tr>
<tr class="memitem:a25bbd127be81b65901f94e0247fbd4b9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a25bbd127be81b65901f94e0247fbd4b9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a>&lt; TKSpace, TSurfelSet &gt; &amp;object)</td></tr>
<tr class="memitem:a1f268b8a695128c059e37512d115571f"><td class="memTemplParams" colspan="2">template&lt;Dimension dim&gt; </td></tr>
<tr class="memitem:a1f268b8a695128c059e37512d115571f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1f268b8a695128c059e37512d115571f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; dim &gt; &amp;object)</td></tr>
<tr class="memitem:acbfc586cb4ecd8bb0b1a787a84cb82d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbfc586cb4ecd8bb0b1a787a84cb82d6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acbfc586cb4ecd8bb0b1a787a84cb82d6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a581d2514f85e3cc8a8c5833991207fe4"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceTracker &gt; </td></tr>
<tr class="memitem:a581d2514f85e3cc8a8c5833991207fe4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a581d2514f85e3cc8a8c5833991207fe4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1UmbrellaComputer.html">UmbrellaComputer</a>&lt; TDigitalSurfaceTracker &gt; &amp;object)</td></tr>
<tr class="memitem:a9d0c060685d6e9a49445a562a99c5286"><td class="memTemplParams" colspan="2">template&lt;typename KSpace , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a9d0c060685d6e9a49445a562a99c5286"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9d0c060685d6e9a49445a562a99c5286">testImplicitDigitalSurface</a> (const KSpace &amp;K, const PointPredicate &amp;pp, const typename KSpace::Surfel &amp;bel)</td></tr>
<tr class="memitem:a08886ee117009e48c66e4349c7c47265"><td class="memTemplParams" colspan="2">template&lt;typename KSpace , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a08886ee117009e48c66e4349c7c47265"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a08886ee117009e48c66e4349c7c47265">testLightImplicitDigitalSurface</a> (const KSpace &amp;K, const PointPredicate &amp;pp, const typename KSpace::Surfel &amp;bel)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7df3f0545c8e59b83394c60601c122e3"><td class="memItemLeft" align="right" valign="top">It also possible to remove the <br class="typebreak"/>
visualisation of the <br class="typebreak"/>
transparent clipping plane by <br class="typebreak"/>
adding boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7df3f0545c8e59b83394c60601c122e3">option</a></td></tr>
<tr class="memitem:a3c1454fe50af31341c890919f93b76b6"><td class="memItemLeft" align="right" valign="top">It also possible to remove the <br class="typebreak"/>
visualisation of the <br class="typebreak"/>
transparent clipping plane by <br class="typebreak"/>
adding boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a></td></tr>
<tr class="memitem:aad0fa31bef8d6552db900af1809d787d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aad0fa31bef8d6552db900af1809d787d">trueBF0</a> = <a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a>()</td></tr>
<tr class="memitem:a8c0dbf38da6779899ca99fc25ec8b0be"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c0dbf38da6779899ca99fc25ec8b0be">falseBF0</a> = <a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a>()</td></tr>
<tr class="memitem:a154eac21029f20806b646b025b6d59a0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a154eac21029f20806b646b025b6d59a0">identityBF1</a> = <a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a>()</td></tr>
<tr class="memitem:a31614f15cda0ab53c57cf414e48c149f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a31614f15cda0ab53c57cf414e48c149f">notBF1</a> = <a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a>()</td></tr>
<tr class="memitem:a70c28100eb4618dbb59a4080cbdf383b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a70c28100eb4618dbb59a4080cbdf383b">andBF2</a> = <a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a>()</td></tr>
<tr class="memitem:a14f119bf8a5eb80a58870ebbd33bfb07"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a14f119bf8a5eb80a58870ebbd33bfb07">orBF2</a> = <a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a>()</td></tr>
<tr class="memitem:a29281e7462720aa5d454fa2355baa0f3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a29281e7462720aa5d454fa2355baa0f3">xorBF2</a> = <a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a>()</td></tr>
<tr class="memitem:af22fdd40c268d4270906236e3ce234cb"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af22fdd40c268d4270906236e3ce234cb">impliesBF2</a> = <a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a>()</td></tr>
<tr class="memitem:ae801de7ee4d22c47257dc7e00e0c5dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a> (std::cerr)</td></tr>
<tr class="memitem:a604c07ec391ad12a1f3fb6479993f112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Trace.html">Trace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a> (<a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a>)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Aim: Defines the concept describing a bidirectional const range. </p>
<p><code><a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a></code> is the top-level namespace which contains all <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> functions and types.</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
<dl class="section author"><dt>Author:</dt><dd>Jacques-Olivier Lachaud (<code><a href="#" onclick="location.href='mai'+'lto:'+'jac'+'qu'+'es-'+'ol'+'ivi'+'er'+'.la'+'ch'+'aud'+'@u'+'niv'+'-s'+'avo'+'ie'+'.fr'; return false;">jacqu<span style="display: none;">.nosp@m.</span>es-o<span style="display: none;">.nosp@m.</span>livie<span style="display: none;">.nosp@m.</span>r.la<span style="display: none;">.nosp@m.</span>chaud<span style="display: none;">.nosp@m.</span>@uni<span style="display: none;">.nosp@m.</span>v-sav<span style="display: none;">.nosp@m.</span>oie.<span style="display: none;">.nosp@m.</span>fr</a></code> ) Laboratory of Mathematics (CNRS, UMR 5807), University of Savoie, France</dd></dl>
<dl class="section date"><dt>Date:</dt><dd>2011/09/19</dd></dl>
<p>Documentation file for feature Geometric</p>
<p>This file is part of the <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> library.</p>
<p><a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> Global variables</p>
<p>DescriptionDescription of <b>concept</b> '<b><a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>'</b> </p>
<h3>Refinement of</h3>
<p><a class="el" href="structDGtal_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const range.">CConstSinglePassRange</a></p>
<h3>Provided types :</h3>
<ul>
<li>ConstReverseIterator: the const reverse iterator type, a model of const iterator concept.</li>
</ul>
<table class="doxtable">
<tr>
<td class="CName"><b>Name</b>  </td><td class="CExpression"><b>Expression</b>  </td><td class="CRequirements"><b>Type</b> requirements  </td><td class="CReturnType"><b>Return</b> type  </td><td class="CPrecondition"><b>Precondition</b>  </td><td class="CSemantics"><b>Semantics</b>  </td><td class="CPostCondition"><b>Postcondition</b>  </td><td class="CComplexity"><b>Complexity</b>   </td></tr>
<tr>
<td class="CName">rbegin  </td><td class="CExpression">x.rbegin() const </td><td class="CRequirements"></td><td class="CReturnType">ConstReverseIterator </td><td class="CPrecondition"></td><td class="CSemantics"></td><td class="CPostCondition"></td><td class="CComplexity"></td></tr>
<tr>
<td class="CName">rend  </td><td class="CExpression">x.rend() const </td><td class="CRequirements"></td><td class="CReturnType">ConstReverseIterator </td><td class="CPrecondition"></td><td class="CSemantics"></td><td class="CPostCondition"></td><td class="CComplexity"></td></tr>
</table>
<h3>Invariants</h3>
<h3>Models</h3>
<h3>Notes</h3>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that is checked. T should be a model of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a40f198468aea6d0121b11cd49e599e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function0&lt; bool &gt; <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">DGtal::BoolFunction0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May hold bool functions taking no arguments. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00053">53</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a92f37472d9010932be3fe6d28f94cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function1&lt; bool, bool &gt; <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">DGtal::BoolFunction1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May hold bool functions taking one bool argument. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00058">58</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d57d4419aa9656ae4be838f903b5dd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function2&lt; bool, bool, bool &gt; <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">DGtal::BoolFunction2</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May hold bool functions taking two bool arguments. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00063">63</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1bbf050f10f3c666dc5e170e893d8e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function3&lt; bool, bool, bool, bool &gt; <a class="el" href="namespaceDGtal.html#a1bbf050f10f3c666dc5e170e893d8e57">DGtal::BoolFunction3</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May hold bool functions taking three bool arguments (Useful ?). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00068">68</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8fbe8c8d47ca5c36ced14284ac62613d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a> <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">DGtal::Dimension</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global static type to represent the dimension in <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> </p>

<p>Definition at line <a class="el" href="Common_8h_source.html#l00127">127</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac62de8348789e05494b7515c6525baa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int16_t <a class="el" href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">DGtal::int16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 16-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00071">71</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1e9ac6a329319ae13c51c0c9e92486a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int32_t <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">DGtal::int32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 32-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00073">73</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c09e3f63904ff371f1b99f45069fc63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int64_t <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 94-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00075">75</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac28d51e0b1672afa52b3c218a32a6a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int8_t <a class="el" href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">DGtal::int8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 8-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00069">69</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a30f912c6a9d587320495d627df2719ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint16_t <a class="el" href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">DGtal::uint16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 16-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00062">62</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27c59126488e9c545120667959d2fc4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint32_t <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 32-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00064">64</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab33c0c25b8cc3cd86de343bca34329f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint64_t <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">DGtal::uint64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 64-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00066">66</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f01c0f785c605d021be8e328180f502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint8_t <a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">DGtal::uint8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 8-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00060">60</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a65228f031a436d2f4edd698ae733ba31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">DGtal::BoundEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035"></a>BOUNDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d"></a>UNBOUNDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e"></a>BOUND_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="NumberTraits_8h_source.html#l00055">55</a> of file <a class="el" href="NumberTraits_8h_source.html">NumberTraits.h</a>.</p>
<div class="fragment"><div class="line">{<a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">BOUNDED</a> = 0, <a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">UNBOUNDED</a> = 1, <a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">BOUND_UNKNOWN</a> = 2};</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2">DGtal::ColorGradientPreset</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320"></a>CMAP_CUSTOM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366"></a>CMAP_GRAYSCALE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c"></a>CMAP_SPRING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7"></a>CMAP_SUMMER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533"></a>CMAP_AUTUMN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7"></a>CMAP_WINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf"></a>CMAP_COOL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33"></a>CMAP_COPPER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe"></a>CMAP_HOT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb"></a>CMAP_JET</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="GradientColorMap_8h_source.html#l00060">60</a> of file <a class="el" href="GradientColorMap_8h_source.html">GradientColorMap.h</a>.</p>
<div class="fragment"><div class="line">                           { <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">CMAP_CUSTOM</a> = 0,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">CMAP_GRAYSCALE</a>,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">CMAP_SPRING</a>,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">CMAP_SUMMER</a>,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">CMAP_AUTUMN</a>,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">CMAP_WINTER</a>,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">CMAP_COOL</a>,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">CMAP_COPPER</a>,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">CMAP_HOT</a>,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a> };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5df441c76f46779791d077a80f0b902e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902e">DGtal::Connectedness</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Kinds of connectedness for an object or a graph. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea"></a>DISCONNECTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a"></a>CONNECTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4"></a>UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Topology_8h_source.html#l00050">50</a> of file <a class="el" href="Topology_8h_source.html">Topology.h</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea">DISCONNECTED</a> = 0, <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a">CONNECTED</a> = 1, <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4">UNKNOWN</a> = 2</div>
<div class="line">    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0f37e197740e9d7742426109610c513a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513a">DGtal::DigitalSetBelongTestability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e"></a>LOW_BEL_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d"></a>HIGH_BEL_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00060">60</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><div class="line">{ <a class="code" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">LOW_BEL_DS</a> = 0, <a class="code" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">HIGH_BEL_DS</a> = 16 };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccc">DGtal::DigitalSetIterability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d"></a>LOW_ITER_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc"></a>HIGH_ITER_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00059">59</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><div class="line">{ <a class="code" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">LOW_ITER_DS</a> = 0, <a class="code" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">HIGH_ITER_DS</a> = 8 };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4">DGtal::DigitalSetSize</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70"></a>SMALL_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc"></a>MEDIUM_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0"></a>BIG_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe"></a>WHOLE_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00057">57</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><div class="line">{ <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">SMALL_DS</a> = 0, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">MEDIUM_DS</a> = 1, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">BIG_DS</a> = 2, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">WHOLE_DS</a> = 3 };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae37267b68e31ee8f7531488f7e88426a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426a">DGtal::DigitalSetVariability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3"></a>LOW_VAR_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a"></a>HIGH_VAR_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00058">58</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><div class="line">{ <a class="code" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">LOW_VAR_DS</a> = 0, <a class="code" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">HIGH_VAR_DS</a> = 4 };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083d">DGtal::DigitalTopologyProperties</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible properties of digital topologies. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88"></a>UNKNOWN_DT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0"></a>NOT_JORDAN_DT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179"></a>JORDAN_DT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalTopology_8h_source.html#l00054">54</a> of file <a class="el" href="DigitalTopology_8h_source.html">DigitalTopology.h</a>.</p>
<div class="fragment"><div class="line">                                 { <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">UNKNOWN_DT</a> = 0, </div>
<div class="line">           <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">NOT_JORDAN_DT</a> = 1,</div>
<div class="line">           <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> = 2 };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3">DGtal::DomainDrawMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the drawing mode for domains. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e"></a>GRID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba"></a>PAVING</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Board2D_8h_source.html#l00057">57</a> of file <a class="el" href="Board2D_8h_source.html">Board2D.h</a>.</p>
<div class="fragment"><div class="line">{ <a class="code" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">GRID</a> = 0, <a class="code" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">PAVING</a> = 1 };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6a">DGtal::ImageBelongTestability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12"></a>HIGH_BEL_I</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630"></a>LOW_BEL_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00055">55</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><div class="line">{  <a class="code" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">HIGH_BEL_I</a> = 0, <a class="code" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">LOW_BEL_I</a> = 2 };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7f3384cac6dea91b4d46cc1421854dda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854dda">DGtal::ImageIterability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c"></a>HIGH_ITER_IMAGE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7"></a>LOW_ITER_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00054">54</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><div class="line">{  <a class="code" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c">HIGH_ITER_IMAGE</a> = 0 , <a class="code" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">LOW_ITER_I</a> = 1};</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7">DGtal::ImageSpecificContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388"></a>NORMAL_CONTAINER_I</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d"></a>VTKIMAGEDATA_CONTAINER_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00056">56</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><div class="line">{ <a class="code" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">NORMAL_CONTAINER_I</a> = 0, <a class="code" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">VTKIMAGEDATA_CONTAINER_I</a> = 4 };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9f6cc75dc44e45506a66cd233e0deb41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global enum definition for orientation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553"></a>INSIDE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e"></a>ON</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734"></a>OUTSIDE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Common_8h_source.html#l00132">132</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>
<div class="fragment"><div class="line">{ <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553">INSIDE</a> = 0, <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e">ON</a> = 1, <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734">OUTSIDE</a> = 2};</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a679e16b34aad98ff340decf89d1c86db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">DGtal::SignEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c"></a>SIGNED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32"></a>UNSIGNED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100"></a>SIGN_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="NumberTraits_8h_source.html#l00056">56</a> of file <a class="el" href="NumberTraits_8h_source.html">NumberTraits.h</a>.</p>
<div class="fragment"><div class="line">{<a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">SIGNED</a> = 0, <a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">UNSIGNED</a> = 1, <a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">SIGN_UNKNOWN</a> = 2};</div>
</div><!-- fragment -->
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a54cd4c3ec97c9ec323a52de71339f589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the absolute value of an instance of type T.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the absolute value |a|. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00105">105</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00649">DGtal::Display3D::addClippingPlane()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00241">DGtal::SeparableMetricHelper&lt; Point, IntegerLong, p &gt;::binarySearchHidden()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00203">DGtal::SeparableMetricHelper&lt; Point, IntegerLong, p &gt;::closest()</a>, <a class="el" href="FrechetShortcut_8h_source.html#l00566">DGtal::FrechetShortcut&lt; TIterator, TInteger &gt;::Tools::computeQuadrant()</a>, <a class="el" href="IntegerComputer_8ih_source.html#l00448">DGtal::IntegerComputer&lt; TInteger &gt;::extendedEuclid()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00118">DGtal::SeparableMetricHelper&lt; Point, IntegerLong, p &gt;::F()</a>, <a class="el" href="IntegerComputer_8ih_source.html#l00284">DGtal::IntegerComputer&lt; TInteger &gt;::gcd()</a>, <a class="el" href="IntegerComputer_8ih_source.html#l00303">DGtal::IntegerComputer&lt; TInteger &gt;::getGcd()</a>, <a class="el" href="CircleFrom3Points_8ih_source.html#l00121">DGtal::CircleFrom3Points&lt; TPoint &gt;::getParameters()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00285">DGtal::SeparableMetricHelper&lt; Point, IntegerLong, p &gt;::hiddenBy()</a>, <a class="el" href="FMM_8ih_source.html#l00177">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::initFromBelsRange()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00357">DGtal::Viewer3D::postSelection()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00523">DGtal::SeparableMetricHelper&lt; TPoint, TInternalValue, 1 &gt;::power()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00627">DGtal::SeparableMetricHelper&lt; TPoint, TInternalValue, 0 &gt;::power()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00134">DGtal::SeparableMetricHelper&lt; Point, IntegerLong, p &gt;::reversedF()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00494">DGtal::SeparableMetricHelper&lt; TPoint, TInternalValue, 1 &gt;::reversedF()</a>, and <a class="el" href="IntegerComputer_8ih_source.html#l00264">DGtal::IntegerComputer&lt; TInteger &gt;::staticGcd()</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));</div>
<div class="line">    <span class="keywordflow">if</span> (a&lt;0) </div>
<div class="line">      <span class="keywordflow">return</span> -a;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">return</span> a;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7b632be90297f1d6a81a58c1a0a4bdc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DGtal::cross </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srcA</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srcB</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the cross product of two 3d vectors and return it. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination vector. </td></tr>
    <tr><td class="paramname">srcA</td><td>source vector A. </td></tr>
    <tr><td class="paramname">srcB</td><td>source vector B. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00059">59</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00386">DGtal::Display3D::addKSSurfel()</a>, <a class="el" href="Display3D_8ih_source.html#l00336">DGtal::Display3D::addPolygon()</a>, <a class="el" href="Display3D_8ih_source.html#l00250">DGtal::Display3D::addQuad()</a>, and <a class="el" href="Display3D_8ih_source.html#l00293">DGtal::Display3D::addTriangle()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  dst[0] = srcA[1]*srcB[2] - srcA[2]*srcB[1];</div>
<div class="line">  dst[1] = srcA[2]*srcB[0] - srcA[0]*srcB[2];</div>
<div class="line">  dst[2] = srcA[0]*srcB[1] - srcA[1]*srcB[0];</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afd55a2a73cd7b4552dbaf0b62980b323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, int n, typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, Alloc&gt; DGtal::derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the partial derivative of <em>p</em> with respect to the N-th indeterminate. We assume that 0 &lt;= N &lt; n.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>an arbitrary polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the variable used for derivation.</td></tr>
    <tr><td class="paramname">n</td><td>the number of variables or indeterminates.</td></tr>
    <tr><td class="paramname">Ring</td><td>the type chosen for the polynomial, defines also the type of the coefficents (generally int, float or double).</td></tr>
    <tr><td class="paramname">Alloc</td><td>is an allocator for Ring, for example std::allocator&lt;Ring&gt;; this is also the default parameter. Usually this parameter does not needs to be changed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01964">1964</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>

<p>References <a class="el" href="MPolynomial_8h_source.html#l01899">DGtal::MPolynomialDerivativeComputer&lt; N, n, Ring, Alloc &gt;::computeDerivative()</a>, and <a class="el" href="MPolynomial_8h_source.html#l01098">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::getAllocator()</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;n, Ring, Alloc&gt;</a> res( p.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>() );</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomialDerivativeComputer.html">MPolynomialDerivativeComputer&lt;N, n, Ring, Alloc&gt;::computeDerivative</a>(p, res);</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9aedf0fbd5b7c5814911d1299be81cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, int n, typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the partial derivative of <em>p</em> with respect to the N-th indeterminate. We assume that 0 &lt;= N &lt; n.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>an arbitrary polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the variable used for derivation.</td></tr>
    <tr><td class="paramname">n</td><td>the number of variables or indeterminates.</td></tr>
    <tr><td class="paramname">Ring</td><td>the type chosen for the polynomial, defines also the type of the coefficents (generally int, float or double). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01988">1988</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">   {</div>
<div class="line">     <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;n, Ring, std::allocator&lt;Ring&gt;</a> &gt; res( p.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>() );</div>
<div class="line">     <a class="code" href="classDGtal_1_1MPolynomialDerivativeComputer.html">MPolynomialDerivativeComputer&lt;N, n, Ring, std::allocator&lt;Ring&gt;</a> &gt;</div>
<div class="line">       ::computeDerivative( p, res );</div>
<div class="line">     <span class="keywordflow">return</span> res;</div>
<div class="line">   }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2bbdffe7efc4f8af031964cecfe477a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRing , typename TAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::euclidDiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forward declaration, to be able to declare this as a friend. </p>

<p>Referenced by <a class="el" href="MPolynomial_8h_source.html#l02045">gcd()</a>.</p>

</div>
</div>
<a class="anchor" id="afc4718ecc21bcecf1618414e982b951c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::euclidDiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes q and r such that f = q g + r and degree(r) &lt; degree(g). </p>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l02001">2001</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>

<p>References <a class="el" href="MPolynomial_8h_source.html#l01110">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::degree()</a>, <a class="el" href="MPolynomial_8h_source.html#l01098">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::getAllocator()</a>, <a class="el" href="MPolynomial_8h_source.html#l01120">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::leading()</a>, and <a class="el" href="MPolynomial_8h_source.html#l01016">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::normalize()</a>.</p>
<div class="fragment"><div class="line">   {</div>
<div class="line">     <span class="keywordflow">if</span> (f.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>() &lt; g.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>())</div>
<div class="line">       {</div>
<div class="line">         <span class="comment">// Ignore the trivial case</span></div>
<div class="line">         q = <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, Alloc&gt;</a>(f.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>());</div>
<div class="line">         r = f;</div>
<div class="line">         <span class="keywordflow">return</span>;</div>
<div class="line">       }</div>
<div class="line">    q = <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, Alloc&gt;</a>( <span class="keyword">true</span>, f.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>() - g.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>() + 1, </div>
<div class="line">                                     f.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>() );</div>
<div class="line">    r = f;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = q.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>(); i &gt;= 0; --i)</div>
<div class="line">      {</div>
<div class="line">        q[i] = r[i + g.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>()] / g.<a class="code" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">leading</a>();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = g.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>(); j &gt;= 0; --j)</div>
<div class="line">          r[i + j] -= q[i] * g[j];</div>
<div class="line">      }</div>
<div class="line">    r.<a class="code" href="classDGtal_1_1MPolynomial.html#af326b15174d16edb89e996f758168ffd">normalize</a>();</div>
<div class="line">    <span class="comment">// Note that the degree of q is already correct.</span></div>
<div class="line">   }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a57e756b9529892b5019066b6d4a4310c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::euclidDiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes q and r such that f = q g + r and degree(r) &lt; degree(g). </p>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l02031">2031</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">   {</div>
<div class="line">     euclidDiv&lt;Ring, std::allocator&lt;Ring&gt; &gt;(f, g, q, r);</div>
<div class="line">   }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3f73d6217f05eef8225781a523efc077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::findAndGetValue </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Point &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the value contained in <em>aImg</em> at <em>aPoint</em> if <em>aPoint</em> belongs to <em>aSet</em>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>(returned) value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>'true' if a new point is found and the value read but 'false' otherwise</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
    <tr><td class="paramname">S</td><td>any model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a></td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p>
<div class="fragment"></div><!-- fragment --><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a><em> as follows: </p>
<div class="fragment"></div><!-- fragment --><p></em></p>
<p><em> </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> </dd></dl>
<p></em></p>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00343">343</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00300">FindAndGetValue&lt; I, S, D, V &gt;::implementation()</a>.</p>

<p>Referenced by <a class="el" href="FMMPointFunctors_8ih_source.html#l00113">DGtal::L2FirstOrderLocalDistance&lt; TImage, TSet &gt;::operator()()</a>, <a class="el" href="FMMPointFunctors_8ih_source.html#l00297">DGtal::L2SecondOrderLocalDistance&lt; TImage, TSet &gt;::operator()()</a>, <a class="el" href="FMMPointFunctors_8ih_source.html#l00510">DGtal::LInfLocalDistance&lt; TImage, TSet &gt;::operator()()</a>, <a class="el" href="FMMPointFunctors_8ih_source.html#l00648">DGtal::L1LocalDistance&lt; TImage, TSet &gt;::operator()()</a>, and <a class="el" href="FMMPointFunctors_8ih_source.html#l00961">DGtal::SpeedExtrapolator&lt; TDistanceImage, TSet, TSpeedFunctor &gt;::operator()()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  </div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); </div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CDigitalSet&lt;S&gt; )); </div>
<div class="line">  BOOST_STATIC_ASSERT(( boost::is_same&lt; typename I::Point, typename S::Point &gt;::value ));</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Domain D; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Value V; </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="structFindAndGetValue.html#afea841f1bc58973ac734d8f1ba8b1917">FindAndGetValue&lt;I,S,D,V&gt;::implementation</a>(aImg, aSet, aPoint, aValue); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae6d3175b6c7d86845a0c259f566bd7ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">403</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00458">firstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">nextMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; </div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i,end) ) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">//backward extension</span></div>
<div class="line">    ConstIterator it( i ); ++it; </div>
<div class="line">    ConstReverseIterator rit( it );</div>
<div class="line">    ConstReverseIterator rend( begin );</div>
<div class="line">    ReverseSegmentComputer r( s.getReverse() ); </div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//forward extension</span></div>
<div class="line">    ConstIterator it2( r.end().base() );</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, it2, end);</div>
<div class="line"></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae37d5f56ebcd83255b9c93038deff781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">438</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  s.init(i);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8b81102d807d1ec5629d25c6e13ddae7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00458">458</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aae8ba2a7a4a42e59741df4afed37f449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00475">475</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a18c5282eb177f64a2957c29bf51b0e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00491">491</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  firstMaximalSegment&lt;SC&gt;(s, i, begin, end, </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a38fc7e3a7ad4420d8b0b5950ae21c32e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, Alloc&gt; DGtal::gcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the monic greatest common divisor of f and g using the Euclidean Algorithm. </p>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l02045">2045</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>

<p>References <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv()</a>, <a class="el" href="MPolynomial_8h_source.html#l01098">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::getAllocator()</a>, <a class="el" href="MPolynomial_8h_source.html#l01128">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::isZero()</a>, and <a class="el" href="MPolynomial_8h_source.html#l01120">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::leading()</a>.</p>

<p>Referenced by <a class="el" href="IntegerComputer_8ih_source.html#l00394">DGtal::IntegerComputer&lt; TInteger &gt;::reduce()</a>.</p>
<div class="fragment"><div class="line">   {</div>
<div class="line">     <span class="keywordflow">if</span> (f.<a class="code" href="classDGtal_1_1MPolynomial.html#ac53389b0d7e6647f32b014ca4eaf78e5">isZero</a>())</div>
<div class="line">       {</div>
<div class="line">         <span class="keywordflow">if</span> (g.<a class="code" href="classDGtal_1_1MPolynomial.html#ac53389b0d7e6647f32b014ca4eaf78e5">isZero</a>()) <span class="keywordflow">return</span> f; <span class="comment">// both are zero</span></div>
<div class="line">         <span class="keywordflow">else</span>            <span class="keywordflow">return</span> g / g.<a class="code" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">leading</a>(); <span class="comment">// make g monic</span></div>
<div class="line">       }</div>
<div class="line">     <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, Alloc&gt;</a> </div>
<div class="line">       d1(f / f.<a class="code" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">leading</a>()), </div>
<div class="line">       d2(g / g.<a class="code" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">leading</a>()), </div>
<div class="line">       q(f.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>()), </div>
<div class="line">       r(f.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>());</div>
<div class="line">     <span class="keywordflow">while</span> (!d2.isZero())</div>
<div class="line">       {</div>
<div class="line">         <a class="code" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv</a>(d1, d2, q, r);</div>
<div class="line">         d1.swap(d2);</div>
<div class="line">         d2 = r;</div>
<div class="line">         d2 /= r.leading(); <span class="comment">// make r monic</span></div>
<div class="line">       }</div>
<div class="line">     <span class="keywordflow">return</span> d1;</div>
<div class="line">   }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab28649140d0b09a9b25515660a3e6f12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::gcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the monic greatest common divisor of f and g using the Euclidean Algorithm. </p>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l02074">2074</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> gcd&lt;Ring, std::allocator&lt;Ring&gt; &gt;(f, g);</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8c4fb1b2976e5fc35dc1b4073149408e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for random access category </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">87</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="MostCenteredMaximalSegmentEstimator_8ih_source.html#l00119">DGtal::MostCenteredMaximalSegmentEstimator&lt; SegmentComputer, SCEstimator &gt;::endEval()</a>, <a class="el" href="MostCenteredMaximalSegmentEstimator_8ih_source.html#l00152">DGtal::MostCenteredMaximalSegmentEstimator&lt; SegmentComputer, SCEstimator &gt;::eval()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00150">getMiddleIterator()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line"><span class="comment">//how to compute this with circulators ?</span></div>
<div class="line"><span class="comment">//return itb + ((ite-itb)/2);  </span></div>
<div class="line"><span class="comment">//does not work  </span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(itb, ite, BidirectionalCategory() ); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9cf4e9405b276ba5b8b931f72d180d9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for bidirectional category NB: in O(ite-itb) </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00100">100</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  IC b( itb ); </div>
<div class="line">  IC f( ite ); </div>
<div class="line">  <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>; </div>
<div class="line">  <span class="keywordflow">while</span> (b != f) {</div>
<div class="line">    <span class="keywordflow">if</span> (flag) {</div>
<div class="line">      --f;</div>
<div class="line">      flag = <span class="keyword">false</span>; </div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      ++b; </div>
<div class="line">      flag = <span class="keyword">true</span>; </div>
<div class="line">    } </div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> b;   </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8f53c482fe83e31093accf95ec7190d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for forward category NB: in O(ite-itb) </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00122">122</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  IC i( itb ); </div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; </div>
<div class="line">  <span class="keywordflow">while</span> (i != ite) {</div>
<div class="line">    ++i; </div>
<div class="line">    ++c;</div>
<div class="line">  } </div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = c/2;</div>
<div class="line"></div>
<div class="line">  c = 0; </div>
<div class="line">  i = itb; </div>
<div class="line">  <span class="keywordflow">while</span> (c != k) {</div>
<div class="line">    ++i; </div>
<div class="line">    ++c;</div>
<div class="line">  } </div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> i;   </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a318f9e3e73cd0988af98b3a66a543334"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the middle iterator of a given range, i.e. itb + (ite-itb)/2) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb,ite,begin</td><td>and end iterators of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the middle iterator of the range [itb,ite) </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">any</td><td>iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00150">150</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">getMiddleIterator()</a>.</p>
<div class="fragment"><div class="line">                                                   {</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Category Category; </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(itb, ite, Category() ); </div>
<div class="line">} </div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a46234d3693677caa52b0ffb6db059d5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::imageFromFunctor </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>aFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In a window corresponding to the domain of <em>aImg</em>, copy the values of <em>aFun</em> into <em>aImg</em> </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aFun</td><td>a unary functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
    <tr><td class="paramname">F</td><td>any model of <a class="el" href="structDGtal_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00139">139</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); </div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CPointFunctor&lt;F&gt; ));</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typename</span> I::Domain d = aImg.domain();</div>
<div class="line"></div>
<div class="line">  std::transform(d.begin(), d.end(), aImg.range().outputIterator(), aFun ); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6e6f5a9c305d047a2e9c6315ca17832c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::imageFromImage </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the values of <em>aImg2</em> into <em>aImg1</em> .</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg1</td><td>the image to fill </td></tr>
    <tr><td class="paramname">aImg2</td><td>the image to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00153">153</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); </div>
<div class="line"></div>
<div class="line">  <span class="keyword">typename</span> I::ConstRange r = aImg2.constRange(); </div>
<div class="line">  std::copy( r.begin(), r.end(), aImg1.range().outputIterator() ); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac1511d84bd2b82df82bea3aefc3af2dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It , typename Im &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::imageFromRangeAndValue </td>
          <td>(</td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Im &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Im::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the values of <em>aImg</em> at <em>aValue</em> for each points of the range [ <em>itb</em> , <em>ite</em> )</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aValue</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>any model of forward iterator </td></tr>
    <tr><td class="paramname">Im</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00108">108</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>Referenced by <a class="el" href="ImageHelper_8ih_source.html#l00126">imageFromRangeAndValue()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( boost::InputIterator&lt;It&gt; ));</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CImage&lt;Im&gt; )); </div>
<div class="line"></div>
<div class="line">  <span class="keyword">typename</span> Im::Domain d = aImg.domain(); </div>
<div class="line">  <span class="keywordflow">for</span> (It it = itb; it != ite; ++it)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (d.isInside( *it )) </div>
<div class="line">        aImg.setValue( *it, aValue ); </div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aff03c6c44f0ec8ad182440aad1b4e86a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::imageFromRangeAndValue </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>aRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the values of <em>aImg</em> at <em>aValue</em> for each points of the range <em>aRange</em> </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aRange</td><td>any range </td></tr>
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aValue</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>any model of <a class="el" href="structDGtal_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const range.">CConstSinglePassRange</a> </td></tr>
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00126">126</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00108">imageFromRangeAndValue()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CConstSinglePassRange&lt;R&gt; ));</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); </div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#ac1511d84bd2b82df82bea3aefc3af2dd">imageFromRangeAndValue</a>( aRange.begin(), aRange.end(), aImg, aValue); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac920bc98f866a2e17ee53faddc67ff80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::insertAndAlwaysSetValue </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Point &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert <em>aPoint</em> in <em>aSet</em> and set <em>aValue</em> at <em>aPoint</em> in <em>aImg</em>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>a value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>'true' if a new point was inserted in <em>aSet</em> but 'false' if the same point already exist in <em>aSet</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
    <tr><td class="paramname">S</td><td>any model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a></td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span> found = <span class="keyword">false</span>; </div>
<div class="line">    <span class="keywordflow">if</span> ( aSet.find( aPoint ) != aSet.end() )</div>
<div class="line">      found = <span class="keyword">true</span>;       </div>
<div class="line">    <span class="comment">//always set value</span></div>
<div class="line">    aSet.insert( aPoint );</div>
<div class="line">    aImg.setValue( aPoint, aValue ); </div>
<div class="line">    <span class="keywordflow">return</span> !found; </div>
</div><!-- fragment --><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a><em> as follows: </p>
<div class="fragment"><div class="line">   std::pair&lt;P, V&gt; </div>
<div class="line">   pair( aPoint, aValue );  </div>
<div class="line">   std::pair&lt;Iterator, bool&gt; res </div>
<div class="line">   = aImg.insert( pair );</div>
<div class="line">   <span class="keywordtype">bool</span> flag = res.second; </div>
<div class="line">   <span class="keywordflow">if</span> (flag == <span class="keyword">false</span>) <span class="comment">//set value even in this case</span></div>
<div class="line">   res.first-&gt;second = aValue;</div>
<div class="line">   <span class="keywordflow">return</span> flag; </div>
</div><!-- fragment --><p></em></p>
<p><em> </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> </dd></dl>
<p></em></p>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00281">281</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00230">InsertAndAlwaysSetValue&lt; I, S, D, V &gt;::implementation()</a>.</p>

<p>Referenced by <a class="el" href="FMM_8ih_source.html#l00152">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::initFromBelsRange()</a>, <a class="el" href="FMM_8ih_source.html#l00241">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::initFromIncidentPointsRange()</a>, and <a class="el" href="FMM_8ih_source.html#l00136">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::initFromPointsRange()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  </div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); </div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CDigitalSet&lt;S&gt; )); </div>
<div class="line">  BOOST_STATIC_ASSERT(( boost::is_same&lt; typename I::Point, typename S::Point &gt;::value ));</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Domain D; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Value V; </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="structInsertAndAlwaysSetValue.html#a963a53c702b8be32449f0e12bb0538f0">InsertAndAlwaysSetValue&lt;I,S,D,V&gt;::implementation</a>(aImg, aSet, aPoint, aValue); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5f01a70f2cf84e9c08d1308e77911a08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::insertAndSetValue </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Point &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert <em>aPoint</em> in <em>aSet</em> and if (and only if) <em>aPoint</em> is a newly inserted point. Then set <em>aValue</em> at <em>aPoint</em> in <em>aImg</em>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>a value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>'true' if a new point was inserted in <em>aSet</em> but 'false' if the same point already exist in <em>aSet</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
    <tr><td class="paramname">S</td><td>any model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a></td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span> found = <span class="keyword">true</span>; </div>
<div class="line">    <span class="keywordflow">if</span> ( aSet.find( aPoint ) == aSet.end() )</div>
<div class="line">      { <span class="comment">//if not found</span></div>
<div class="line">        found = <span class="keyword">false</span>; </div>
<div class="line">        aSet.insert( aPoint );</div>
<div class="line">        aImg.setValue( aPoint, aValue ); </div>
<div class="line">      }      </div>
<div class="line">    <span class="keywordflow">return</span> !found; </div>
</div><!-- fragment --><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a><em> as follows: </p>
<div class="fragment"><div class="line">   std::pair&lt;P, V&gt; </div>
<div class="line">   pair( aPoint, aValue );  </div>
<div class="line">   std::pair&lt;Iterator, bool&gt; res </div>
<div class="line">   = aImg.insert( pair ); </div>
<div class="line">   <span class="keywordflow">return</span> res.second;  </div>
</div><!-- fragment --><p></em></p>
<p><em> </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#ac920bc98f866a2e17ee53faddc67ff80">insertAndAlwaysSetValue</a> </dd></dl>
<p></em></p>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00213">213</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00165">InsertAndSetValue&lt; I, S, D, V &gt;::implementation()</a>.</p>

<p>Referenced by <a class="el" href="FMM_8ih_source.html#l00403">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::addNewAcceptedPoint()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); </div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CDigitalSet&lt;S&gt; )); </div>
<div class="line">  BOOST_STATIC_ASSERT(( boost::is_same&lt; typename I::Point, typename S::Point &gt;::value ));</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Domain D; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Value V; </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="structInsertAndSetValue.html#a5d6eba146a4533add7a14f19e8f3f9a2">InsertAndSetValue&lt;I,S,D,V&gt;::implementation</a>(aImg, aSet, aPoint, aValue); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6b49e997d09ccb163eb82529e8970996"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::isEmpty </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IteratorFunctions_8h_source.html#l00075">75</a> of file <a class="el" href="IteratorFunctions_8h_source.html">IteratorFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Preimage2D_8ih_source.html#l00285">DGtal::Preimage2D&lt; Shape &gt;::addBack()</a>, and <a class="el" href="Preimage2D_8ih_source.html#l00227">DGtal::Preimage2D&lt; Shape &gt;::addFront()</a>.</p>
<div class="fragment"><div class="line">                                            {</div>
<div class="line">  <span class="keywordflow">return</span> !detail::isNotEmpty&lt;IC&gt;( itb, ite, <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Type() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6f1b22211474c60437654c3a0decb8ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::isNotEmpty </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IteratorFunctions_8h_source.html#l00081">81</a> of file <a class="el" href="IteratorFunctions_8h_source.html">IteratorFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="L1LengthEstimator_8ih_source.html#l00083">DGtal::L1LengthEstimator&lt; TConstIterator &gt;::eval()</a>, <a class="el" href="TrueLocalEstimatorOnPoints_8ih_source.html#l00111">DGtal::TrueLocalEstimatorOnPoints&lt; TConstIteratorOnPoints, TParametricShape, TParametricShapeFunctor &gt;::eval()</a>, <a class="el" href="MostCenteredMaximalSegmentEstimator_8ih_source.html#l00228">DGtal::MostCenteredMaximalSegmentEstimator&lt; SegmentComputer, SCEstimator &gt;::eval()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, <a class="el" href="MostCenteredMaximalSegmentEstimator_8ih_source.html#l00079">DGtal::MostCenteredMaximalSegmentEstimator&lt; SegmentComputer, SCEstimator &gt;::isValid()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">                                               {</div>
<div class="line">  <span class="keywordflow">return</span> detail::isNotEmpty&lt;IC&gt;( itb, ite, <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Type() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a19f04b5f095862ee00e620f8246df2f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">652</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00706">lastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; </div>
<div class="line"></div>
<div class="line">  <span class="comment">//forward extension</span></div>
<div class="line">  ConstIterator j( i );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, j, end);</div>
<div class="line"></div>
<div class="line">  <span class="comment">//backward extension</span></div>
<div class="line">  ConstIterator it( s.end() );</div>
<div class="line">  ConstReverseIterator rit( it );</div>
<div class="line">  ConstReverseIterator rend( begin );</div>
<div class="line">  ReverseSegmentComputer r( s.getReverse() ); </div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);</div>
<div class="line"></div>
<div class="line">  <span class="comment">//forward extension</span></div>
<div class="line">  ConstIterator it2( r.end().base() );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, it2, end);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8c5dc0554703f63c1ec705f764f2ba3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalSegmentComputer&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">686</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  s.init(i);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a652ebafea1d9e8891f40d9b0af8fcb02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00706">706</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a47282aa7c7fc28d49e7a52a3f8eeee3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00723">723</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afa3e824f983193de48aaf18590edaa52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00739">739</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">   lastMaximalSegment&lt;SC&gt;(s, i, begin, end, </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2034305fadb5376a987519daba4c982a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">352</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00384">longestSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>, <a class="el" href="GreedyDecomposition_8ih_source.html#l00262">DGtal::deprecated::GreedyDecomposition&lt; TSegment &gt;::SegmentIterator::next()</a>, and <a class="el" href="GreedySegmentation_8ih_source.html#l00135">DGtal::GreedySegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::next()</a>.</p>
<div class="fragment"><div class="line"> {</div>
<div class="line">  <span class="keywordflow">if</span> (i != end) {</div>
<div class="line">    s.init(i);</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end, IteratorType() );</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a67994f04a54230cdb524e46dba46a127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00367">367</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  s.init(i);</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end, CirculatorType() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a464c32dc87cc7ded90f601f4657664a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the longest possible segment from [i] </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i,a</td><td>given ConstIterator </td></tr>
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00384">384</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; </div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>( s, i, end, Type() ); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5da3e5d223f3f741760a4e0fc3483c3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::maxDGtal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the max bewteen to instance of type T.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable and EqualityComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value </td></tr>
    <tr><td class="paramname">b</td><td>second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the maximum between a and b. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00085">85</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    BOOST_CONCEPT_ASSERT((boost::EqualityComparable&lt;T&gt;));</div>
<div class="line">    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));</div>
<div class="line">    <span class="keywordflow">if</span> (a&gt;=b) </div>
<div class="line">      <span class="keywordflow">return</span> a;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">return</span> b;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4718031e09102bb8f73a874c47e10aaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">163</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00187">maximalExtension()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">nextMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">                                                                                 {</div>
<div class="line">  <span class="comment">//stop if s.end() == end</span></div>
<div class="line">  <span class="keywordflow">while</span> ( (s.end() != end)</div>
<div class="line">       &amp;&amp; (s.extendForward()) ) {}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a367841808f36fa49eceaa1671718f3ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00173">173</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="comment">//stop if the segment is the whole range</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> SC::ConstIterator newEnd( s.begin() ); </div>
<div class="line">  <span class="keywordflow">while</span> ( (s.extendForward())</div>
<div class="line">    &amp;&amp; (s.end() != newEnd) ) {}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a21c7d5ea8b24456694c6fa5f6a25f4cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls s.extendForward() while possible </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00187">187</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>
<div class="fragment"><div class="line">                                                                  {</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; </div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>( s, end, Type() ); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad4831d5ff3c1c70bd1c6a26403297a9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalRetraction </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls s.retractForward() while s.isExtendableForward() returns false </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00316">316</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">nextMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.end(),end) ) {</div>
<div class="line">    <span class="keywordflow">while</span> ( (! s.isExtendableForward() ) </div>
<div class="line">          &amp;&amp;(s.retractForward() ) )  {}  </div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">while</span> ( s.retractForward() ) {} </div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad8d73948fddeeb1f2e0fa94c4c9b03a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">233</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00298">maximalSymmetricExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">                 {</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">bool</span> flagOk = <span class="keyword">true</span>; </div>
<div class="line">  <span class="keywordtype">bool</span> flagForward = <span class="keyword">true</span>; </div>
<div class="line">  <span class="comment">//while the extension is possible </span></div>
<div class="line">  <span class="comment">//at the front and (then) at the back</span></div>
<div class="line">  <span class="keywordflow">while</span> (flagOk)  {</div>
<div class="line">    <span class="keywordflow">if</span> (flagForward) {</div>
<div class="line">      flagForward = <span class="keyword">false</span>; </div>
<div class="line">      <span class="keywordflow">if</span> ( s.end() != end ) flagOk = s.extendForward();</div>
<div class="line">      <span class="keywordflow">else</span> flagOk = <span class="keyword">false</span>; </div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      flagForward = <span class="keyword">true</span>; </div>
<div class="line">      <span class="keywordflow">if</span> ( s.begin() != begin ) flagOk = s.extendBackward();</div>
<div class="line">      <span class="keywordflow">else</span> flagOk = <span class="keyword">false</span>; </div>
<div class="line">    } </div>
<div class="line">  }</div>
<div class="line">  <span class="comment">//extend one more time if s.begin() == begin</span></div>
<div class="line">  <span class="keywordflow">if</span> (s.begin() != begin ) {</div>
<div class="line">    <span class="keywordflow">if</span> (s.extendBackward()) <span class="keywordflow">return</span> !s.extendForward(); </div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>; </div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">return</span> !flagForward; </div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a04bd5266c4907488dc943c3fd18b72a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00267">267</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">                   {</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">bool</span> flagOk = <span class="keyword">true</span>; </div>
<div class="line">  <span class="keywordtype">bool</span> flagForward = <span class="keyword">true</span>; </div>
<div class="line">  <span class="comment">//while the extensions are possible and</span></div>
<div class="line">  <span class="comment">//the segment does not correspond to the whole range</span></div>
<div class="line">  <span class="keywordflow">while</span> ( (flagOk) &amp;&amp; ( s.end() != s.begin() ) )  {</div>
<div class="line">    <span class="keywordflow">if</span> (flagForward) {</div>
<div class="line">      flagForward = <span class="keyword">false</span>; </div>
<div class="line">      flagOk = s.extendForward(); </div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      flagForward = <span class="keyword">true</span>; </div>
<div class="line">      flagOk = s.extendBackward(); </div>
<div class="line">    } </div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> !flagForward; </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad09a396e60a1ff248a246cc2f365fb31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls alternatively s.extendForward() and s.extendBackward() while it is possible </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of (bidirectional)segment computer </td></tr>
    <tr><td class="paramname">begin,end,begin</td><td>and end iterator of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>'true' if the extension at the front fails first and 'false' if the extension at the back fails first </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00298">298</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">maximalSymmetricExtension()</a>.</p>
<div class="fragment"><div class="line">                                       {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a>( s, begin, end, Type() ); </div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af78ce7935f43397801a6d65785f71df5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::minDGtal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the min bewteen to instance of type T.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable and EqualityComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value </td></tr>
    <tr><td class="paramname">b</td><td>second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the minimum between a and b. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00064">64</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    BOOST_CONCEPT_ASSERT((boost::EqualityComparable&lt;T&gt;));</div>
<div class="line">    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));</div>
<div class="line">    <span class="keywordflow">if</span> (a&lt;=b) </div>
<div class="line">      <span class="keywordflow">return</span> a;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">return</span> b;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a770659cf50cd49c0ce6c3d4ab08abb46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, Alloc&gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in one indeterminate. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01684">1684</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, Alloc&gt;</a> p;</div>
<div class="line">    p[e] = 1;</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad04b582eb75ae0cfc14dfc40d57c03f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;2, Ring, Alloc&gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in two indeterminates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 2-variables polynomial X_0^e X_1^f </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01702">1702</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;2, Ring, Alloc&gt;</a> p;</div>
<div class="line">    p[e][f] = 1;</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a46b41f1ac0f88d213c7fb8bee8931799"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;3, Ring, Alloc&gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in three indeterminates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01720">1720</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;3, Ring, Alloc&gt;</a> p;</div>
<div class="line">    p[e][f][g] = 1;</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae6ba6c1f73137c9da0365c16635c92e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;4, Ring, Alloc&gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in four indeterminates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
    <tr><td class="paramname">h</td><td>the exponent for X_3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g X_3^h </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01740">1740</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;4, Ring, Alloc&gt;</a> p;</div>
<div class="line">    p[e][f][g][h] = 1;</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9ef248272fbf9b379c272e0ec632289c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in one indeterminate. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01756">1756</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, std::allocator&lt;Ring&gt;</a> &gt; p;</div>
<div class="line">    p[e] = 1;</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9ac70e986a68541f5a9e2b9a4035da2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;2, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in two indeterminates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 2-variables polynomial X_0^e X_1^f </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01773">1773</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;2, Ring, std::allocator&lt;Ring&gt;</a> &gt; p;</div>
<div class="line">    p[e][f] = 1;</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4f44e0a9fc1e30d29e52646daeca211d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;3, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in three indeterminates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01791">1791</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;3, Ring, std::allocator&lt;Ring&gt;</a> &gt; p;</div>
<div class="line">    p[e][f][g] = 1;</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4a679186eed201b0844c7bf6f83e76c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;4, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in four indeterminates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
    <tr><td class="paramname">h</td><td>the exponent for X_3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g X_3^h </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01811">1811</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;4, Ring, std::allocator&lt;Ring&gt;</a> &gt; p;</div>
<div class="line">    p[e][f][g][h] = 1;</div>
<div class="line">    <span class="keywordflow">return</span> p;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1b3f25b1f654c74c78819624604e4950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">510</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">getMiddleIterator()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="MostCenteredMaximalSegmentEstimator_8ih_source.html#l00228">DGtal::MostCenteredMaximalSegmentEstimator&lt; SegmentComputer, SCEstimator &gt;::eval()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00600">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; </div>
<div class="line"></div>
<div class="line"> <span class="comment">//get the first maximal segment passing through i</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>( s, i, begin, end, <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line"></div>
<div class="line"> <span class="comment">//get the next maximal segment while i is not at the middle of </span></div>
<div class="line"> <span class="comment">//the current maximal segment. </span></div>
<div class="line"></div>
<div class="line">  ConstIterator k( s.begin() ); </div>
<div class="line">  <span class="keywordflow">while</span> ( k != i ) {</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(s.end(),end) ) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">//backward extension</span></div>
<div class="line">      ConstIterator it( s.end() ); ++it; </div>
<div class="line">      ConstReverseIterator rit( it );</div>
<div class="line">      ConstReverseIterator rend( s.begin() );</div>
<div class="line">      ReverseSegmentComputer r( s.getReverse() ); </div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);</div>
<div class="line">      ConstIterator newBegin = r.end().base(); </div>
<div class="line">      ASSERT( newBegin != s.begin() );</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">while</span> ( ( k != <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(newBegin, s.end() ) )</div>
<div class="line">            &amp;&amp;( k != i ) ) {</div>
<div class="line">        ++k; </div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> ( k != i ) {</div>
<div class="line">   </div>
<div class="line">        <span class="comment">//get the next maximal segment</span></div>
<div class="line">        <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, newBegin, end);  </div>
<div class="line"></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      k = i; </div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad153558eaa4afb851f884b64680f4631"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">566</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="IteratorFunctions_8h_source.html#l00081">isNotEmpty()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">maximalSymmetricExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">if</span> ( (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,end)) || (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,begin)) ) { </div>
<div class="line"></div>
<div class="line">    s.init(i);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//symmetric extension</span></div>
<div class="line">    <span class="keywordflow">if</span> ( (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,end)) &amp;&amp; (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,begin)) ) { </div>
<div class="line">      <a class="code" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a>(s, begin, end); </div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="comment">//forward extension</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);</div>
<div class="line">      </div>
<div class="line">  <span class="comment">//backward extension</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);</div>
<div class="line"></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a07a2cb535d2b0befce8f080d9d1a2414"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00600">600</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa43392e8f5aeba868858b9b2c1e52cf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00617">617</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adb7b7f5908ea811a44f41186c7a01e8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00633">633</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">   mostCenteredMaximalSegment&lt;SC&gt;(s, i, begin, end, </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a91c1293187f38e931f5f353d1a38f71c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>fistMaximalSegment of s.end() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">759</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>

<p>Referenced by <a class="el" href="MaximalSegments_8ih_source.html#l00063">DGtal::deprecated::MaximalSegments&lt; TSegment &gt;::SegmentIterator::firstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00173">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::nextMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00820">nextMaximalSegment()</a>, <a class="el" href="MaximalSegments_8ih_source.html#l00368">DGtal::deprecated::MaximalSegments&lt; TSegment &gt;::SegmentIterator::operator++()</a>, and <a class="el" href="SaturatedSegmentation_8ih_source.html#l00328">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::operator++()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s, s.end(), s.begin(), end, ForwardSegmentComputer() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0f4fc5b05689abd850faa6637a64505c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>fistMaximalSegment of s.end() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00774">774</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s, s.end(), s.begin(), end, <a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6ee548c7f570f6bdb18ce2cc592cb009"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">788</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00316">maximalRetraction()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; </div>
<div class="line"></div>
<div class="line">  <span class="comment">//rectract</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#ad4831d5ff3c1c70bd1c6a26403297a9a">maximalRetraction</a>(s, end); </div>
<div class="line"></div>
<div class="line">  <span class="comment">//intersection test</span></div>
<div class="line">  ConstIterator i( s.begin() ); ++i; </div>
<div class="line">  <span class="comment">//if the intersection between the two </span></div>
<div class="line">  <span class="comment">// consecutive maximal segments is empty </span></div>
<div class="line">  <span class="keywordflow">if</span> ( i == s.end() ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i, end) ) {</div>
<div class="line">      ++i; </div>
<div class="line">      s.init(i);  </div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">//extend</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae9e6d98ecc15fc5062f30060d4452706"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00820">820</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">nextMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{ </div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">nextMaximalSegment</a>(s, end, <a class="code" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>() ); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a325d2a962cd3410424a45f83c1b32b7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00834">834</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">   nextMaximalSegment&lt;SC&gt;(s, end, </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5953d43d65a342438b932b5fac6a0334"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DGtal::normalize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vec</em>[3]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalize the input 3d vector. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>source &amp; destination vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00072">72</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00386">DGtal::Display3D::addKSSurfel()</a>, <a class="el" href="Display3D_8ih_source.html#l00336">DGtal::Display3D::addPolygon()</a>, <a class="el" href="Display3D_8ih_source.html#l00250">DGtal::Display3D::addQuad()</a>, and <a class="el" href="Display3D_8ih_source.html#l00293">DGtal::Display3D::addTriangle()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> squaredLen = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];</div>
<div class="line">  vec[0] /= sqrt (squaredLen);</div>
<div class="line">  vec[1] /= sqrt (squaredLen);</div>
<div class="line">  vec[2] /= sqrt (squaredLen);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2e60731c3d380a3d904efbf5c088cf07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html" title="Aim: Best Linear Unbiased Two step length estimator.">BLUELocalLengthEstimator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html" title="Aim: Best Linear Unbiased Two step length estimator.">BLUELocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b1f11e76731f6b53d58741593de1718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html" title="Aim: Rosen-Proffitt Length Estimator.">RosenProffittLocalLengthEstimator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html" title="Aim: Rosen-Proffitt Length Estimator.">RosenProffittLocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1a0c72f3ea963c433d33b86d1fba535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriter &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriter.html" title="Virtual Class to implement trace writers.">TraceWriter</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriter.html" title="Virtual Class to implement trace writers.">TraceWriter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e210a0da2db0fe767f88859a7ec00ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContourHelper &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ContourHelper.html" title="Aim: a helper class to process sequences of points.">ContourHelper</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ContourHelper.html" title="Aim: a helper class to process sequences of points.">ContourHelper</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ContourHelper_8ih_source.html#l00070">70</a> of file <a class="el" href="ContourHelper_8ih_source.html">ContourHelper.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a027b1488a4625548cc76d8f70b640f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">MeshFromPoints&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'operator&lt;&lt;' for importing objects of class '<a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MeshReader_8ih_source.html#l00276">276</a> of file <a class="el" href="MeshReader_8ih_source.html">MeshReader.ih</a>.</p>

<p>References <a class="el" href="MeshReader_8ih_source.html#l00052">DGtal::MeshReader&lt; TPoint &gt;::importOFFFile()</a>, and <a class="el" href="MeshReader_8ih_source.html#l00182">DGtal::MeshReader&lt; TPoint &gt;::importOFSFile()</a>.</p>
<div class="fragment"><div class="line">                                                                                {</div>
<div class="line">    <span class="keywordtype">string</span> extension = filename.substr(filename.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1);</div>
<div class="line">    <span class="keywordflow">if</span>(extension== <span class="stringliteral">&quot;off&quot;</span>) {</div>
<div class="line">      <a class="code" href="structDGtal_1_1MeshReader.html#a49fbd6686c17e7f37ab34a84a67eb583">DGtal::MeshReader&lt;TPoint&gt;::importOFFFile</a>(filename, mesh);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(extension== <span class="stringliteral">&quot;ofs&quot;</span>) {</div>
<div class="line">      <a class="code" href="structDGtal_1_1MeshReader.html#a7341a7b965c1d7ec7d8243501d367dd9">DGtal::MeshReader&lt; TPoint&gt;::importOFSFile</a>(filename, mesh);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abb0ae3e476260be1ddbbe6c881738e81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriterFile &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b43a30839ecc0499b0b5d2d71952233"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CowPtr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CowPtr.html" title="Aim: Copy on write shared pointer.">CowPtr</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CowPtr.html" title="Aim: Copy on write shared pointer.">CowPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CowPtr_8ih_source.html#l00077">77</a> of file <a class="el" href="CowPtr_8ih_source.html">CowPtr.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1c198285c212e189cc6b3775282d971b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicEmbedder.html" title="Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn...">CanonicEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicEmbedder.html" title="Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn...">CanonicEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CanonicEmbedder_8ih_source.html#l00115">115</a> of file <a class="el" href="CanonicEmbedder_8ih_source.html">CanonicEmbedder.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa5ad29732984e904acf8a15b5f36f391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountedPtr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts.">CountedPtr</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts.">CountedPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CountedPtr_8ih_source.html#l00080">80</a> of file <a class="el" href="CountedPtr_8ih_source.html">CountedPtr.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a105d0f6359b68e48600e22cf765f4aaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l00127">127</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ 0 ];</div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 1; i &lt; dim; ++i )</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ i ];</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac4d5198d8a044649b47cf6ccecf43549"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Clock.html">Clock</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Clock.html">Clock</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Clock.html">Clock</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Clock_8h_source.html#l00160">160</a> of file <a class="el" href="Clock_8h_source.html">Clock.h</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">      <span class="keywordflow">return</span> out;</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a75322b203241e20a106afb814182df80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ClosedIntegerHalfPlane&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html" title="Aim: A half-space specified by a vector N and a constant c. The half-space is the set ...">ClosedIntegerHalfPlane</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html" title="Aim: A half-space specified by a vector N and a constant c. The half-space is the set ...">ClosedIntegerHalfPlane</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ClosedIntegerHalfPlane_8ih_source.html#l00149">149</a> of file <a class="el" href="ClosedIntegerHalfPlane_8ih_source.html">ClosedIntegerHalfPlane.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af0a7679f68647399382399dc1608a6dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoundaryPredicate&lt; TKSpace, TImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">BoundaryPredicate</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">BoundaryPredicate</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="BoundaryPredicate_8ih_source.html#l00128">128</a> of file <a class="el" href="BoundaryPredicate_8ih_source.html">BoundaryPredicate.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1f268b8a695128c059e37512d115571f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelAdjacency&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="SurfelAdjacency_8ih_source.html#l00131">131</a> of file <a class="el" href="SurfelAdjacency_8ih_source.html">SurfelAdjacency.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac60851b0fad3cc7d11289811fd942728"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrontierPredicate&lt; TKSpace, TImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">FrontierPredicate</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">FrontierPredicate</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FrontierPredicate_8ih_source.html#l00127">127</a> of file <a class="el" href="FrontierPredicate_8ih_source.html">FrontierPredicate.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8b8a89999c5ec643ec73f257abe6c488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L1LengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1L1LengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">L1LengthEstimator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1L1LengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">L1LengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="L1LengthEstimator_8ih_source.html#l00145">145</a> of file <a class="el" href="L1LengthEstimator_8ih_source.html">L1LengthEstimator.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a61e5d3bce501d46ca6cb4baee8590389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicCellEmbedder.html" title="Aim: A trivial embedder for unsigned cell, which corresponds to the canonic injection of cell centroi...">CanonicCellEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicCellEmbedder.html" title="Aim: A trivial embedder for unsigned cell, which corresponds to the canonic injection of cell centroi...">CanonicCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CanonicCellEmbedder_8ih_source.html#l00130">130</a> of file <a class="el" href="CanonicCellEmbedder_8ih_source.html">CanonicCellEmbedder.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afc39fa68fdb704b43c5f89b871030b30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html" title="Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids...">CanonicSCellEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html" title="Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids...">CanonicSCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CanonicSCellEmbedder_8ih_source.html#l00130">130</a> of file <a class="el" href="CanonicSCellEmbedder_8ih_source.html">CanonicSCellEmbedder.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abbf878eedd1e61f021f337b903ac1a5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurface &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a>&lt; TDigitalSurface &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html" title="Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell cent...">CanonicDigitalSurfaceEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html" title="Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell cent...">CanonicDigitalSurfaceEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CanonicDigitalSurfaceEmbedder_8ih_source.html#l00130">130</a> of file <a class="el" href="CanonicDigitalSurfaceEmbedder_8ih_source.html">CanonicDigitalSurfaceEmbedder.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9611bc4af426ac90cd62f4f0d147d686"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FPLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its FP (faith...">FPLengthEstimator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its FP (faith...">FPLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FPLengthEstimator_8ih_source.html#l00154">154</a> of file <a class="el" href="FPLengthEstimator_8ih_source.html">FPLengthEstimator.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5b8eb9b80ef38f0b355c23ce44caec57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MLPLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MLPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (give...">MLPLengthEstimator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MLPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (give...">MLPLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MLPLengthEstimator_8ih_source.html#l00153">153</a> of file <a class="el" href="MLPLengthEstimator_8ih_source.html">MLPLengthEstimator.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a71ebae2f928719f51222d9830f580ab6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Measure.html">Measure</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2...">Measure</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2...">Measure</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a855e675db4e5e115051b87a6c79c6f36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurface , typename TNormalVectorEstimator , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a>&lt; TDigitalSurface, TNormalVectorEstimator, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html" title="Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructib...">NormalVectorEstimatorLinearCellEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html" title="Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructib...">NormalVectorEstimatorLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ebfff66f1d6cdbd2b15f83c2ee8c55b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TwoStepLocalLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">TwoStepLocalLengthEstimator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">TwoStepLocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="TwoStepLocalLengthEstimator_8ih_source.html#l00154">154</a> of file <a class="el" href="TwoStepLocalLengthEstimator_8ih_source.html">TwoStepLocalLengthEstimator.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac81440dbce679bb785c1679dc6b226af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DSSLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DSSLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the lengt...">DSSLengthEstimator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DSSLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the lengt...">DSSLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DSSLengthEstimator_8ih_source.html#l00159">159</a> of file <a class="el" href="DSSLengthEstimator_8ih_source.html">DSSLengthEstimator.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa60540f21dc15c6580824e2e370a7600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriterTerm &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriterTerm.html" title="Implements trace prefix for color terminals.">TraceWriterTerm</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriterTerm.html" title="Implements trace prefix for color terminals.">TraceWriterTerm</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="abd178d36151704c1413d4ad614e7f774"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitBall&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitBall.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball in nD...">ImplicitBall</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitBall.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball in nD...">ImplicitBall</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitBall_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitBall_8ih_source.html">ImplicitBall.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0862dd8a38f8e16ed9bc34ad6ba2bc55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomColorMap &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RandomColorMap.html" title="Aim: access to random color from a gradientColorMap.">RandomColorMap</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RandomColorMap.html" title="Aim: access to random color from a gradientColorMap.">RandomColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="RandomColorMap_8ih_source.html#l00157">157</a> of file <a class="el" href="RandomColorMap_8ih_source.html">RandomColorMap.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a756d34159757aef9d0e815a8426071f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OwningOrAliasingPtr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html" title="Aim: This class describes a smart pointer that is, given the constructor called by the user...">OwningOrAliasingPtr</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html" title="Aim: This class describes a smart pointer that is, given the constructor called by the user...">OwningOrAliasingPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="OwningOrAliasingPtr_8ih_source.html#l00160">160</a> of file <a class="el" href="OwningOrAliasingPtr_8ih_source.html">OwningOrAliasingPtr.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac3c6d87ade0e0da551f72c4e645771e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Board2D.html">Board2D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Board2D_8ih_source.html#l00149">149</a> of file <a class="el" href="Board2D_8ih_source.html">Board2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa22cc58968d7134d4ec338d8b6d49f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RegularPointEmbedder.html" title="Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0...">RegularPointEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RegularPointEmbedder.html" title="Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0...">RegularPointEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="RegularPointEmbedder_8ih_source.html#l00189">189</a> of file <a class="el" href="RegularPointEmbedder_8ih_source.html">RegularPointEmbedder.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeebf10a683d3e958f2b53c11af2e8548"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImplicitFunction , typename TEmbedder &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitFunctionLinearCellEmbedder&lt; TKSpace, TImplicitFunction, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder.">ImplicitFunctionLinearCellEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder.">ImplicitFunctionLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitFunctionLinearCellEmbedder_8ih_source.html#l00195">195</a> of file <a class="el" href="ImplicitFunctionLinearCellEmbedder_8ih_source.html">ImplicitFunctionLinearCellEmbedder.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adbf9270f5f724d5e51d1356f3372783c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IVViewer &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IVViewer.html" title="Aim: A facade to represent an inventor window for 3D objects. May be a SoXt or a SoQt examiner viewer...">IVViewer</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IVViewer.html" title="Aim: A facade to represent an inventor window for 3D objects. May be a SoXt or a SoQt examiner viewer...">IVViewer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="IVViewer_8ih_source.html#l00054">54</a> of file <a class="el" href="IVViewer_8ih_source.html">IVViewer.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae4f0a1e7a73fe21a13f6809e3a47ff0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Displays <code>object</code> on the output stream <code>out</code>.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of integer for the modulo computer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramname">object</td><td>the object to display. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ModuloComputer_8h_source.html#l00208">208</a> of file <a class="el" href="ModuloComputer_8h_source.html">ModuloComputer.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7272fa4a71b37b89de44110188769338"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage , typename TEmbedder &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageLinearCellEmbedder&lt; TKSpace, TImage, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html" title="Aim: a cellular embedder for images. (default constructible, copy constructible, assignable). Model of CCellEmbedder.">ImageLinearCellEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html" title="Aim: a cellular embedder for images. (default constructible, copy constructible, assignable). Model of CCellEmbedder.">ImageLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageLinearCellEmbedder_8ih_source.html#l00206">206</a> of file <a class="el" href="ImageLinearCellEmbedder_8ih_source.html">ImageLinearCellEmbedder.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a670552923873f4f08a0c8d2ecf75cbe9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitNorm1Ball&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball for the L_...">ImplicitNorm1Ball</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball for the L_...">ImplicitNorm1Ball</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitNorm1Ball_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitNorm1Ball_8ih_source.html">ImplicitNorm1Ball.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9c9db375c56d37d5a38a7599c7e02e07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StraightLineFrom2Points.html" title="Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any ...">StraightLineFrom2Points</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StraightLineFrom2Points.html" title="Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any ...">StraightLineFrom2Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="StraightLineFrom2Points_8h_source.html#l00210">210</a> of file <a class="el" href="StraightLineFrom2Points_8h_source.html">StraightLineFrom2Points.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8a88c744566a4a1adce2dd7d55256bbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitHyperCube&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create an hypercube in n...">ImplicitHyperCube</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create an hypercube in n...">ImplicitHyperCube</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitHyperCube_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitHyperCube_8ih_source.html">ImplicitHyperCube.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a64c1c0996bfe10bd42952cad2d72ecdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set.">DigitalSetDomain</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set.">DigitalSetDomain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a485151b618f71a80d057c3c7d35e84ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a>&lt; PValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5cfe3192eb33036ed5a6afdce4fa90c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Trace &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Trace.html" title="implementation of basic methods to trace out messages with indentation levels.">Trace</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Trace.html" title="implementation of basic methods to trace out messages with indentation levels.">Trace</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Trace_8ih_source.html#l00258">258</a> of file <a class="el" href="Trace_8ih_source.html">Trace.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1d0842bcae55bdd9b262e906c5b3a79d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Ball2D.html" title="Aim: Model of the concept StarShaped represents any circle in the plane.">Ball2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Ball2D.html" title="Aim: Model of the concept StarShaped represents any circle in the plane.">Ball2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Ball2D_8ih_source.html#l00191">191</a> of file <a class="el" href="Ball2D_8ih_source.html">Ball2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a094a29952a05e86998aaf467bb013d1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitRoundedHyperCube&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a rounded hypercu...">ImplicitRoundedHyperCube</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a rounded hypercu...">ImplicitRoundedHyperCube</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitRoundedHyperCube_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitRoundedHyperCube_8ih_source.html">ImplicitRoundedHyperCube.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7b3757780615da753f109e91c107bbd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSequence , typename TRank &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIteratorWithRankOnSequence&lt; TSequence, TRank &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html" title="Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence...">InputIteratorWithRankOnSequence</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html" title="Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence...">InputIteratorWithRankOnSequence</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="InputIteratorWithRankOnSequence_8ih_source.html#l00204">204</a> of file <a class="el" href="InputIteratorWithRankOnSequence_8ih_source.html">InputIteratorWithRankOnSequence.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a585a463f4055c1df3774c34bc4d1c5fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CircleFrom2Points.html" title="Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two o...">CircleFrom2Points</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CircleFrom2Points.html" title="Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two o...">CircleFrom2Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CircleFrom2Points_8h_source.html#l00231">231</a> of file <a class="el" href="CircleFrom2Points_8h_source.html">CircleFrom2Points.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa8be5db54eccfba7fd8916763cbf00da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TForegroundAdjacency , typename TBackgroundAdjacency &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalTopology&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalTopology_8ih_source.html#l00181">181</a> of file <a class="el" href="DigitalTopology_8ih_source.html">DigitalTopology.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5ee88b42fe08c64c833f2b785139063c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CircleFrom3Points.html" title="Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given...">CircleFrom3Points</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CircleFrom3Points.html" title="Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given...">CircleFrom3Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CircleFrom3Points_8h_source.html#l00236">236</a> of file <a class="el" href="CircleFrom3Points_8h_source.html">CircleFrom3Points.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa32e43bdffbdc24f45de94ad9102978a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cadab732dfb13c3b84f49566f5b9c11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int PDefaultColor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColorBrightnessColorMap&lt; PValue, PDefaultColor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">ColorBrightnessColorMap</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">ColorBrightnessColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ColorBrightnessColorMap_8ih_source.html#l00163">163</a> of file <a class="el" href="ColorBrightnessColorMap_8ih_source.html">ColorBrightnessColorMap.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a075acfb401c86aea97863e49764f7e74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a>&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l00222">222</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ 0 ];</div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 1; i &lt; dim; ++i )</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ i ];</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; ( <span class="keywordtype">object</span>.myPositive ? <span class="charliteral">&#39;+&#39;</span> : <span class="charliteral">&#39;-&#39;</span> );</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa8e4002c881f8a192a8185c3a0a80d1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , Dimension maxNorm1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a>&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MetricAdjacency.html" title="Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinit...">MetricAdjacency</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MetricAdjacency.html" title="Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinit...">MetricAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MetricAdjacency_8ih_source.html#l00251">251</a> of file <a class="el" href="MetricAdjacency_8ih_source.html">MetricAdjacency.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a69f3490f30f770c8fc9fc6dd445cd93c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int DefaultCycles&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a>&lt; PValue, DefaultCycles &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e209bc654b6b3088e3d880d4eb24a96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ellipse2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Ellipse2D.html" title="Aim: Model of the concept StarShaped represents any ellipse in the plane.">Ellipse2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Ellipse2D.html" title="Aim: Model of the concept StarShaped represents any ellipse in the plane.">Ellipse2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Ellipse2D_8ih_source.html#l00236">236</a> of file <a class="el" href="Ellipse2D_8ih_source.html">Ellipse2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae1caecda191f889867656183eabae2f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NGon2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1NGon2D.html" title="Aim: Model of the concept StarShaped represents any regular k-gon in the plane.">NGon2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1NGon2D.html" title="Aim: Model of the concept StarShaped represents any regular k-gon in the plane.">NGon2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="NGon2D_8ih_source.html#l00242">242</a> of file <a class="el" href="NGon2D_8ih_source.html">NGon2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a44bf615980e20b3cd46b582b7141a6a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const experimental::ImageContainerByITKImage&lt; TDomain, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ImageContainerByITKImage_8ih_source.html#l00252">252</a> of file <a class="el" href="ImageContainerByITKImage_8ih_source.html">ImageContainerByITKImage.ih</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a31c3aec34372e12bb2a4b530ebefb1b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html" title="Aim: model of CEuclideanOrientedShape concepts to create a shape from a polynomial.">ImplicitPolynomial3Shape</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html" title="Aim: model of CEuclideanOrientedShape concepts to create a shape from a polynomial.">ImplicitPolynomial3Shape</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a008281343ea4fc3971b69a6543b9b842"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DGtalInventor&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DGtalInventor.html" title="Aim: A stream object based on Open Inventor for exporting or displaying DGtal objects.">DGtalInventor</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DGtalInventor.html" title="Aim: A stream object based on Open Inventor for exporting or displaying DGtal objects.">DGtalInventor</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DGtalInventor_8ih_source.html#l00389">389</a> of file <a class="el" href="DGtalInventor_8ih_source.html">DGtalInventor.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2d3fcda6867c1a6cae9a2011a8c1b30c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lattice&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Lattice.html" title="Aim: Represents an n-dimensional integer lattice in an m-dimensional real vector space.">Lattice</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Lattice.html" title="Aim: Represents an n-dimensional integer lattice in an m-dimensional real vector space.">Lattice</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Lattice_8ih_source.html#l00362">362</a> of file <a class="el" href="Lattice_8ih_source.html">Lattice.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>&lt; TDomain, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageContainerBySTLMap_8h_source.html#l00263">263</a> of file <a class="el" href="ImageContainerBySTLMap_8h_source.html">ImageContainerBySTLMap.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abb59a7087b1ca526c94078e5cc499672"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Color &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple.">Color</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple.">Color</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Color_8ih_source.html#l00054">54</a> of file <a class="el" href="Color_8ih_source.html">Color.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a87b130f95ae2c59b8ce9a2d9b3eb00eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Flower2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Flower2D.html" title="Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.">Flower2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Flower2D.html" title="Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.">Flower2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Flower2D_8ih_source.html#l00212">212</a> of file <a class="el" href="Flower2D_8ih_source.html">Flower2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a311a8c89ec31846a61238a44a48c51c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceEmbedder , typename TNormalVectorEstimator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSurfaceEmbedderWithNormalVectorEstimator&lt; TDigitalSurfaceEmbedder, TNormalVectorEstimator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html" title="Aim: Combines a digital surface embedder with a normal vector estimator to get a model of CDigitalSur...">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html" title="Aim: Combines a digital surface embedder with a normal vector estimator to get a model of CDigitalSur...">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSurfaceEmbedderWithNormalVectorEstimator_8ih_source.html#l00230">230</a> of file <a class="el" href="DigitalSurfaceEmbedderWithNormalVectorEstimator_8ih_source.html">DigitalSurfaceEmbedderWithNormalVectorEstimator.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac9e45359f1676fa161c263f50cbee30d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TAdjacency &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a>&lt; TDomain, TAdjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DomainAdjacency.html" title="Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adja...">DomainAdjacency</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DomainAdjacency.html" title="Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adja...">DomainAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DomainAdjacency_8ih_source.html#l00125">125</a> of file <a class="el" href="DomainAdjacency_8ih_source.html">DomainAdjacency.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a30df8b8fe139c899b9f825d7e5f6398d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Shapes&lt; TDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Shapes.html" title="Aim: A utility class for constructing different shapes (balls, diamonds, and others).">Shapes</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Shapes.html" title="Aim: A utility class for constructing different shapes (balls, diamonds, and others).">Shapes</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DGtal_2shapes_2Shapes_8ih_source.html#l00302">302</a> of file <a class="el" href="DGtal_2shapes_2Shapes_8ih_source.html">DGtal/shapes/Shapes.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9d6116d3f522841ef300a0a3d0a22dd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccFlower2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1AccFlower2D.html" title="Aim: Model of the concept StarShaped represents any accelerated flower in the plane.">AccFlower2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1AccFlower2D.html" title="Aim: Model of the concept StarShaped represents any accelerated flower in the plane.">AccFlower2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="AccFlower2D_8ih_source.html#l00238">238</a> of file <a class="el" href="AccFlower2D_8ih_source.html">AccFlower2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1cfec935d23b12fc18c32eece2a8ab1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int PDefaultPreset, int PDefaultFirstColor, int PDefaultLastColor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GradientColorMap&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GradientColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">GradientColorMap</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GradientColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">GradientColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GradientColorMap_8ih_source.html#l00294">294</a> of file <a class="el" href="GradientColorMap_8ih_source.html">GradientColorMap.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5f14f15bee0a8b951c870363e278a94e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFraction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pattern&lt; TFraction &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Pattern.html" title="Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a...">Pattern</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Pattern.html" title="Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a...">Pattern</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Pattern_8ih_source.html#l00501">501</a> of file <a class="el" href="Pattern_8ih_source.html">Pattern.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac4e8f6819676918bd7ecac2e88e847f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball3D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Ball3D.html" title="Aim: Model of the concept StarShaped3D represents any Sphere in the space.">Ball3D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Ball3D.html" title="Aim: Model of the concept StarShaped3D represents any Sphere in the space.">Ball3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Ball3D_8ih_source.html#l00251">251</a> of file <a class="el" href="Ball3D_8ih_source.html">Ball3D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0da05652e14a44efd06ab37c830fb00c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StarShaped2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="StarShaped2D_8ih_source.html#l00243">243</a> of file <a class="el" href="StarShaped2D_8ih_source.html">StarShaped2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aebacbf3c61709a7e0d1fc250f1f0204f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TEuclideanShape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a>&lt; TSpace, TEuclideanShape &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GaussDigitizer.html" title="Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with...">GaussDigitizer</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GaussDigitizer.html" title="Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with...">GaussDigitizer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GaussDigitizer_8ih_source.html#l00243">243</a> of file <a class="el" href="GaussDigitizer_8ih_source.html">GaussDigitizer.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8b6273f070d1edcf9c510601044863d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSurface , bool isUpward, bool isClosed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2ShapePredicate&lt; TSurface, isUpward, isClosed &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Point2ShapePredicate.html" title="Aim: Predicate returning &#39;true&#39; iff a given point is in the &#39;interior&#39; of a given shape...">Point2ShapePredicate</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Point2ShapePredicate.html" title="Aim: Predicate returning &#39;true&#39; iff a given point is in the &#39;interior&#39; of a given shape...">Point2ShapePredicate</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Point2ShapePredicate_8ih_source.html#l00111">111</a> of file <a class="el" href="Point2ShapePredicate_8ih_source.html">Point2ShapePredicate.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaabd5b098d8beabcd7e4bc7d4316586a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">ArithmeticalDSS3d</a>&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html" title="Aim: Dynamic recognition of a 3d-digital straight segment (DSS)">ArithmeticalDSS3d</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html" title="Aim: Dynamic recognition of a 3d-digital straight segment (DSS)">ArithmeticalDSS3d</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ArithmeticalDSS3d_8h_source.html#l00283">283</a> of file <a class="el" href="ArithmeticalDSS3d_8h_source.html">ArithmeticalDSS3d.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out);</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0c685b28cb1a025847d30274b28d0edd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeasureOfStraightLines &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MeasureOfStraightLines.html" title="The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines a...">MeasureOfStraightLines</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MeasureOfStraightLines.html" title="The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines a...">MeasureOfStraightLines</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MeasureOfStraightLines_8ih_source.html#l00392">392</a> of file <a class="el" href="MeasureOfStraightLines_8ih_source.html">MeasureOfStraightLines.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2129e2cee3ca511648fd20bcf90635f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealNumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>thatStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Statistic&lt; RealNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>that_object_to_display</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Statistic.html" title="Aim: This class processes a set of sample values for one variable and can then compute different stat...">Statistic</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">thatStream</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">that_object_to_display</td><td>the object of class '<a class="el" href="classDGtal_1_1Statistic.html" title="Aim: This class processes a set of sample values for one variable and can then compute different stat...">Statistic</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Statistic_8ih_source.html#l00421">421</a> of file <a class="el" href="Statistic_8ih_source.html">Statistic.ih</a>.</p>

<p>References <a class="el" href="Statistic_8ih_source.html#l00384">DGtal::Statistic&lt; RealNumberType &gt;::selfDisplay()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  that_object_to_display.selfDisplay( thatStream );</div>
<div class="line">  <span class="keywordflow">return</span> thatStream;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9353d51816abd73c77d05aa44b5298ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer , typename TNewDomain , typename TFunctorD , typename TNewValue , typename TFunctorV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ConstImageAdapter_8ih_source.html#l00070">70</a> of file <a class="el" href="ConstImageAdapter_8ih_source.html">ConstImageAdapter.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a432b6b35fc11ee6b9c11fb54d193b366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceTracker &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSurface2DSlice&lt; TDigitalSurfaceTracker &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html" title="Aim: Represents a 2-dimensional slice in a DigitalSurface. In a sense, it is a 4-connected contour...">DigitalSurface2DSlice</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html" title="Aim: Represents a 2-dimensional slice in a DigitalSurface. In a sense, it is a 4-connected contour...">DigitalSurface2DSlice</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSurface2DSlice_8ih_source.html#l00254">254</a> of file <a class="el" href="DigitalSurface2DSlice_8ih_source.html">DigitalSurface2DSlice.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="accdbde97ed9607a15ec962171d6d933e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImplicitFunctionDiff1 , typename TEmbedder &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitFunctionDiff1LinearCellEmbedder&lt; TKSpace, TImplicitFunctionDiff1, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder and CWithGradientMap.">ImplicitFunctionDiff1LinearCellEmbedder</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder and CWithGradientMap.">ImplicitFunctionDiff1LinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitFunctionDiff1LinearCellEmbedder_8ih_source.html#l00235">235</a> of file <a class="el" href="ImplicitFunctionDiff1LinearCellEmbedder_8ih_source.html">ImplicitFunctionDiff1LinearCellEmbedder.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a581d2514f85e3cc8a8c5833991207fe4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceTracker &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UmbrellaComputer&lt; TDigitalSurfaceTracker &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1UmbrellaComputer.html" title="Aim: Useful for computing umbrellas on &#39;DigitalSurface&#39;s, ie set of n-1 cells around a n-3 cell...">UmbrellaComputer</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1UmbrellaComputer.html" title="Aim: Useful for computing umbrellas on &#39;DigitalSurface&#39;s, ie set of n-1 cells around a n-3 cell...">UmbrellaComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="UmbrellaComputer_8ih_source.html#l00359">359</a> of file <a class="el" href="UmbrellaComputer_8ih_source.html">UmbrellaComputer.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e7ca3a483107d4b69dfa47cf7919663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TFunctor , typename TReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ConstRangeAdapter.html">ConstRangeAdapter</a>&lt; TIterator, TFunctor, TReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ConstRangeAdapter.html" title="Aim: model of CConstBidirectionalRange that adapts any range of elements bounded by two iterators [it...">ConstRangeAdapter</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ConstRangeAdapter.html" title="Aim: model of CConstBidirectionalRange that adapts any range of elements bounded by two iterators [it...">ConstRangeAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ConstRangeAdapter_8h_source.html#l00306">306</a> of file <a class="el" href="ConstRangeAdapter_8h_source.html">ConstRangeAdapter.h</a>.</p>
<div class="fragment"><div class="line">   {</div>
<div class="line">     <span class="keywordtype">object</span>.selfDisplay( out ); </div>
<div class="line">     <span class="keywordflow">return</span> out; </div>
<div class="line">   } </div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8600426252610144c749a003e93274f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TDigitalSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a>&lt; TKSpace, TDigitalSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TDigitalSet</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetBoundary_8ih_source.html#l00310">310</a> of file <a class="el" href="DigitalSetBoundary_8ih_source.html">DigitalSetBoundary.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3611cd19b341d3f70a23a0023e6aff2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Image&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Image_8ih_source.html#l00065">65</a> of file <a class="el" href="Image_8ih_source.html">Image.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad5f4caac3598001543faa58512905fa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">experimental::ImageContainerByITKImage</a>&lt; T, TV &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ImageContainerByITKImage'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ImageContainerByITKImage' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="aa92bbcb0c90cddb06c7f84134c1e4a5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Expander.html">Expander</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Expander.html" title="Aim: This class is useful to visit an object by adjacencies, layer by layer.">Expander</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Expander.html" title="Aim: This class is useful to visit an object by adjacencies, layer by layer.">Expander</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="aba713edeb51f787070eff9f9edc210c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>//To move elsewhere ? Overloads 'operator&lt;&lt;' for displaying STL pairs. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the STL pair to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ConstRangeAdapter_8h_source.html#l00320">320</a> of file <a class="el" href="ConstRangeAdapter_8h_source.html">ConstRangeAdapter.h</a>.</p>
<div class="fragment"><div class="line">   {</div>
<div class="line">     out &lt;&lt; <span class="keywordtype">object</span>.first &lt;&lt; <span class="stringliteral">&quot;|&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.second; </div>
<div class="line">     <span class="keywordflow">return</span> out; </div>
<div class="line">   } </div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3af9b163e8918cad50ffea5f1195887a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshFromPoints&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MeshFromPoints_8ih_source.html#l00268">268</a> of file <a class="el" href="MeshFromPoints_8ih_source.html">MeshFromPoints.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a25bbd127be81b65901f94e0247fbd4b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a>&lt; TKSpace, TSurfelSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">SetOfSurfels</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">SetOfSurfels</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelSet</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetOfSurfels_8ih_source.html#l00296">296</a> of file <a class="el" href="SetOfSurfels_8ih_source.html">SetOfSurfels.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2f5edcc946b7d5701677dd3acac2860a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int L, typename TWord &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Labels.html">Labels</a>&lt; L, TWord &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Labels.html" title="Aim: Stores a set of labels in {O..L-1} as a sequence of bits.">Labels</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Labels.html" title="Aim: Stores a set of labels in {O..L-1} as a sequence of bits.">Labels</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Labels_8ih_source.html#l00417">417</a> of file <a class="el" href="Labels_8ih_source.html">Labels.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa5fc9d51f585b97ec5094a8a7792ea44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer , typename TNewDomain , typename TFunctorD , typename TNewValue , typename TFunctorV , typename TFunctorVm1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV, TFunctorVm1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageAdapter_8ih_source.html#l00070">70</a> of file <a class="el" href="ImageAdapter_8ih_source.html">ImageAdapter.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa8c04085996bfcb483774f35e6a6ffda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TPointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImplicitDigitalSurface_8ih_source.html#l00321">321</a> of file <a class="el" href="ImplicitDigitalSurface_8ih_source.html">ImplicitDigitalSurface.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6dd73f56ae05b88cb69f61caff00d5ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StarShaped3D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="StarShaped3D_8ih_source.html#l00330">330</a> of file <a class="el" href="StarShaped3D_8ih_source.html">StarShaped3D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a294f23451c7c99ae08e19bd5eea76469"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetBySTLSet&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSetBySTLSet_8ih_source.html#l00459">459</a> of file <a class="el" href="DigitalSetBySTLSet_8ih_source.html">DigitalSetBySTLSet.ih</a>.</p>

<p>References <a class="el" href="DigitalSetBySTLSet_8ih_source.html#l00417">DGtal::DigitalSetBySTLSet&lt; TDomain &gt;::selfDisplay()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a133f736b6505cf0359ccc7e8be803c46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetBySTLVector&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSetBySTLVector_8ih_source.html#l00514">514</a> of file <a class="el" href="DigitalSetBySTLVector_8ih_source.html">DigitalSetBySTLVector.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acbfc586cb4ecd8bb0b1a787a84cb82d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SurfelNeighborhood.html" title="Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a SurfelAdjacency so as to determine adjacent surfels (either looking for them from interior to exterior or inversely).">SurfelNeighborhood</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SurfelNeighborhood.html" title="Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a SurfelAdjacency so as to determine adjacent surfels (either looking for them from interior to exterior or inversely).">SurfelNeighborhood</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2a3ce65944bf6a16aeb2ebce2c9cd00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ExplicitDigitalSurface_8ih_source.html#l00321">321</a> of file <a class="el" href="ExplicitDigitalSurface_8ih_source.html">ExplicitDigitalSurface.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a62707785131f3a712ab96fdc6525f956"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GeometricalDCA&lt; TConstIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GeometricalDCA.html" title="Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edg...">GeometricalDCA</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GeometricalDCA.html" title="Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edg...">GeometricalDCA</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GeometricalDCA_8ih_source.html#l00635">635</a> of file <a class="el" href="GeometricalDCA_8ih_source.html">GeometricalDCA.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6f97c9e9c01d4864725d8d606a5535a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMapImage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetFromMap&lt; TMapImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSetFromMap_8ih_source.html#l00360">360</a> of file <a class="el" href="DigitalSetFromMap_8ih_source.html">DigitalSetFromMap.ih</a>.</p>

<p>References <a class="el" href="DigitalSetFromMap_8ih_source.html#l00330">DGtal::DigitalSetFromMap&lt; TMapImage &gt;::selfDisplay()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7bf8ccb5fec38dffae46efd2c0d5c2c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Signal&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Signal.html" title="Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is onl...">Signal</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Signal.html" title="Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is onl...">Signal</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Signal_8ih_source.html#l00607">607</a> of file <a class="el" href="Signal_8ih_source.html">Signal.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a352f8e878ed0810de6b9166501d8f33a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIteratorOnPoints , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinomialConvolver&lt; TConstIteratorOnPoints, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="BinomialConvolver_8ih_source.html#l00335">335</a> of file <a class="el" href="BinomialConvolver_8ih_source.html">BinomialConvolver.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af36416f9fdefcffddd2b2953f551257b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GeometricalDSS&lt; TConstIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GeometricalDSS.html" title="Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid ...">GeometricalDSS</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GeometricalDSS.html" title="Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid ...">GeometricalDSS</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GeometricalDSS_8ih_source.html#l00528">528</a> of file <a class="el" href="GeometricalDSS_8ih_source.html">GeometricalDSS.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0213a561c03e9d90b12581abcf2ea54d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrderedAlphabet &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1OrderedAlphabet.html" title="Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be ...">OrderedAlphabet</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1OrderedAlphabet.html" title="Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be ...">OrderedAlphabet</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="OrderedAlphabet_8ih_source.html#l00148">148</a> of file <a class="el" href="OrderedAlphabet_8ih_source.html">OrderedAlphabet.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aed3c31b50222da39a5484940fa7c7987"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphericalAccumulator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SphericalAccumulator.html" title="Aim: implements an accumulator (as histograms for 1D scalars) adapted to spherical point samples...">SphericalAccumulator</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SphericalAccumulator.html" title="Aim: implements an accumulator (as histograms for 1D scalars) adapted to spherical point samples...">SphericalAccumulator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="SphericalAccumulator_8ih_source.html#l00322">322</a> of file <a class="el" href="SphericalAccumulator_8ih_source.html">SphericalAccumulator.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5694066261d35cce4631775ccc2596e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TPointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LightImplicitDigitalSurface_8ih_source.html#l00380">380</a> of file <a class="el" href="LightImplicitDigitalSurface_8ih_source.html">LightImplicitDigitalSurface.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1c7a202da7d028af6c2565026014318c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , DGtal::Dimension M, DGtal::Dimension N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimpleMatrix&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SimpleMatrix.html" title="Aim: implements basic MxN Matrix services (M,N&gt;=1).">SimpleMatrix</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SimpleMatrix.html" title="Aim: implements basic MxN Matrix services (M,N&gt;=1).">SimpleMatrix</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="SimpleMatrix_8ih_source.html#l00417">417</a> of file <a class="el" href="SimpleMatrix_8ih_source.html">SimpleMatrix.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a55f2044bafa880126f92373e30027115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LightExplicitDigitalSurface_8ih_source.html#l00389">389</a> of file <a class="el" href="LightExplicitDigitalSurface_8ih_source.html">LightExplicitDigitalSurface.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa0e2794580b8d7d35c4b4761f264d08e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFraction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StandardDSLQ0&lt; TFraction &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="StandardDSLQ0_8ih_source.html#l00644">644</a> of file <a class="el" href="StandardDSLQ0_8ih_source.html">StandardDSLQ0.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac2a53895055b003622553da7cb636570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Viewer3D_8ih_source.html#l00119">119</a> of file <a class="el" href="Viewer3D_8ih_source.html">Viewer3D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a97a5060ed0aa5b031edef61dd369aafd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TInternalInteger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COBAGenericNaivePlane&lt; TSpace, TInternalInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1COBAGenericNaivePlane.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1...">COBAGenericNaivePlane</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1COBAGenericNaivePlane.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1...">COBAGenericNaivePlane</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="COBAGenericNaivePlane_8ih_source.html#l00408">408</a> of file <a class="el" href="COBAGenericNaivePlane_8ih_source.html">COBAGenericNaivePlane.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af1add10c7a26535a4feb8d370bd6fb4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preimage2D&lt; Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Preimage2D.html" title="Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O...">Preimage2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Preimage2D.html" title="Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O...">Preimage2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Preimage2D_8ih_source.html#l00514">514</a> of file <a class="el" href="Preimage2D_8ih_source.html">Preimage2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6ba93e4cd388ebab2cb5ec533a303962"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FP&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FP_8ih_source.html#l00496">496</a> of file <a class="el" href="FP_8ih_source.html">FP.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a60cb8329ec7e317f1beb03c8b322cf13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TGraph , typename TMarkSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BreadthFirstVisitor&lt; TGraph, TMarkSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="BreadthFirstVisitor_8ih_source.html#l00262">262</a> of file <a class="el" href="BreadthFirstVisitor_8ih_source.html">BreadthFirstVisitor.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45e13e373849988b8c7143a6c6c0b58e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TGraph , typename TMarkSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DepthFirstVisitor&lt; TGraph, TMarkSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DepthFirstVisitor.html" title="Aim: This class is useful to perform a depth-first exploration of a graph given a starting point or s...">DepthFirstVisitor</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DepthFirstVisitor.html" title="Aim: This class is useful to perform a depth-first exploration of a graph given a starting point or s...">DepthFirstVisitor</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DepthFirstVisitor_8ih_source.html#l00252">252</a> of file <a class="el" href="DepthFirstVisitor_8ih_source.html">DepthFirstVisitor.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6f39f856a5dc3683cd3fdb8e22afa143"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridCurve&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes, in a cellular space of dimension n, a closed of open sequence of signed d-cells (or d...">GridCurve</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes, in a cellular space of dimension n, a closed of open sequence of signed d-cells (or d...">GridCurve</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GridCurve_8ih_source.html#l00423">423</a> of file <a class="el" href="GridCurve_8ih_source.html">GridCurve.ih</a>.</p>

<p>References <a class="el" href="GridCurve_8ih_source.html#l00392">DGtal::GridCurve&lt; TKSpace &gt;::selfDisplay()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  aObject.selfDisplay ( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a52995248ae36d8cd61977cf8e37c63bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SegmentComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a>&lt; SegmentComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.">GreedySegmentation</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.">GreedySegmentation</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3c376126e05e1f797bb688366dd30f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TSet , typename TPointPredicate , typename TPointFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FMM.html">FMM</a>&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FMM_8ih_source.html#l00501">501</a> of file <a class="el" href="FMM_8ih_source.html">FMM.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a86a932423c11c531c9ecfe4631704aab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SegmentComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>&lt; SegmentComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SaturatedSegmentation.html" title="Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range gi...">SaturatedSegmentation</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SaturatedSegmentation.html" title="Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range gi...">SaturatedSegmentation</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="afec460eda081b4dc6922174819cae6cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt; Domain, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageContainerBySTLVector_8h_source.html#l00537">537</a> of file <a class="el" href="ImageContainerBySTLVector_8h_source.html">ImageContainerBySTLVector.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae591e8cecb39b8f25c2ffa65929ce1d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TInternalInteger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COBANaivePlane&lt; TSpace, TInternalInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1COBANaivePlane.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlane</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1COBANaivePlane.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlane</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="COBANaivePlane_8ih_source.html#l00807">807</a> of file <a class="el" href="COBANaivePlane_8ih_source.html">COBANaivePlane.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a196a8c122d6e58d73ecd46c249b8b849"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntegerComputer&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IntegerComputer.html" title="Aim: This class gathers several types and methods to make computation with integers.">IntegerComputer</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IntegerComputer.html" title="Aim: This class gathers several types and methods to make computation with integers.">IntegerComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="IntegerComputer_8ih_source.html#l00610">610</a> of file <a class="el" href="IntegerComputer_8ih_source.html">IntegerComputer.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5684b6b55398b599ed5aaa9a70f3a0cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AngleLinearMinimizer &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1AngleLinearMinimizer.html" title="Aim: Used to minimize the angle variation between different angles while taking into accounts min and...">AngleLinearMinimizer</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1AngleLinearMinimizer.html" title="Aim: Used to minimize the angle variation between different angles while taking into accounts min and...">AngleLinearMinimizer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="AngleLinearMinimizer_8ih_source.html#l00213">213</a> of file <a class="el" href="AngleLinearMinimizer_8ih_source.html">AngleLinearMinimizer.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c2216f99d3bb51af40e13a811bfd846"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LatticePolytope2D.html">LatticePolytope2D</a>&lt; TSpace, TSequence &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane...">LatticePolytope2D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane...">LatticePolytope2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="LatticePolytope2D_8ih_source.html#l00902">902</a> of file <a class="el" href="LatticePolytope2D_8ih_source.html">LatticePolytope2D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65fe5e7517f127b50ab8d9daa779a55e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="HyperRectDomain_8ih_source.html#l00178">178</a> of file <a class="el" href="HyperRectDomain_8ih_source.html">HyperRectDomain.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad3071ce24e8bfd8044515d2e8bf31b0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalTopology , typename TDigitalSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Object.html">Object</a>&lt; TDigitalTopology, TDigitalSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Object_8ih_source.html#l01005">1005</a> of file <a class="el" href="Object_8ih_source.html">Object.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1f3fe65ff2eec5a590b6a2c550725e7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSurface_8ih_source.html#l00909">909</a> of file <a class="el" href="DigitalSurface_8ih_source.html">DigitalSurface.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a156fb1231cef8a4755062c0319f5b0eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue , unsigned int N, unsigned int M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexedListWithBlocks&lt; TValue, N, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IndexedListWithBlocks.html" title="Aim: Represents a mixed list/array structure which is useful in some context. It is essentially a lis...">IndexedListWithBlocks</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IndexedListWithBlocks.html" title="Aim: Represents a mixed list/array structure which is useful in some context. It is essentially a lis...">IndexedListWithBlocks</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValue</td><td>the type for the values stored in the list. </td></tr>
    <tr><td class="paramname">N</td><td>the number of value stored in the first block. </td></tr>
    <tr><td class="paramname">M</td><td>the number of value stored in the further blocks. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IndexedListWithBlocks_8ih_source.html#l00678">678</a> of file <a class="el" href="IndexedListWithBlocks_8ih_source.html">IndexedListWithBlocks.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae515a588c9f74ac323d60f95bc8bedb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Display3D.html">DGtal::Display3D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00908">908</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a36a2459f7913ffe2255193bdfc4536d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ArithmeticalDSS_8h_source.html#l00773">773</a> of file <a class="el" href="ArithmeticalDSS_8h_source.html">ArithmeticalDSS.h</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out);</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adcd8d9d47caf12b58c0270ee77c7ec5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue , typename THashKey &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1ImageContainerByHashTree.html">ImageContainerByHashTree</a>&lt; TDomain, TValue, THashKey &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">ImageContainerByHashTree</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">ImageContainerByHashTree</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageContainerByHashTree_8h_source.html#l00799">799</a> of file <a class="el" href="ImageContainerByHashTree_8h_source.html">ImageContainerByHashTree.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordtype">object</span>.selfDisplay( out);</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a484bbc565292ed3fd276d70c3e71afac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Component &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; dim, Component &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator &lt;&lt;. </p>

</div>
</div>
<a class="anchor" id="a1b2bc070ca54bd515c2948faae24b179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l01030">1030</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afb8e4d60f980875ee264a4470c0cd39d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrechetShortcut&lt; TIterator, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FrechetShortcut.html" title="Aim: On-line computation Computation of the longest shortcut according to the Fréchet distance for a ...">FrechetShortcut</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FrechetShortcut.html" title="Aim: On-line computation Computation of the longest shortcut according to the Fréchet distance for a ...">FrechetShortcut</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FrechetShortcut_8ih_source.html#l00913">913</a> of file <a class="el" href="FrechetShortcut_8ih_source.html">FrechetShortcut.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab3a7c82e86886176e1633ffa720003cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CombinatorialDSS.html">CombinatorialDSS</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CombinatorialDSS.html" title="Aim:">CombinatorialDSS</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CombinatorialDSS.html" title="Aim:">CombinatorialDSS</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a85c3c4d290e6b5c6de7e46b431d4c4fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreemanChain&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>aObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FreemanChain_8ih_source.html#l01338">1338</a> of file <a class="el" href="FreemanChain_8ih_source.html">FreemanChain.ih</a>.</p>

<p>References <a class="el" href="FreemanChain_8ih_source.html#l00613">DGtal::FreemanChain&lt; TInteger &gt;::selfDisplay()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  aObject.selfDisplay ( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7d3cb1a90041cd25855944e723d44f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TData , unsigned int L, typename TWord , unsigned int N, unsigned int M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LabelledMap&lt; TData, L, TWord, N, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LabelledMap.html" title="Aim: Represents a map label -&gt; data, where the label is an integer between 0 and a constant L-1...">LabelledMap</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LabelledMap.html" title="Aim: Represents a map label -&gt; data, where the label is an integer between 0 and a constant L-1...">LabelledMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TData</td><td>the type for the datas stored in the list. </td></tr>
    <tr><td class="paramname">N</td><td>the number of data stored in the first block. </td></tr>
    <tr><td class="paramname">M</td><td>the number of data stored in the further blocks. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LabelledMap_8ih_source.html#l01215">1215</a> of file <a class="el" href="LabelledMap_8ih_source.html">LabelledMap.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac9d84c5b0391cb2973795d314b7a26ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a>&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l01707">1707</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aade413b000d41b595aa32414aaa564a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename TRing , class TAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPolynomial&lt; N, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a>'. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MPolynomial_8ih_source.html#l00074">74</a> of file <a class="el" href="MPolynomial_8ih_source.html">MPolynomial.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7da2e4ec36c07db836f12a3b829c4961"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MeshFromPoints.html">MeshFromPoints</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>'operator&gt;&gt;' for exporting objects of class '<a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a>'. This operator automatically selects the good method according to the filename extension (off, obj).</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMesh,:</td><td>the mesh to be exported. </td></tr>
    <tr><td class="paramname">aFilename,:</td><td>the filename of the file to be exported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true, if the export was successful. </dd></dl>

<p>Definition at line <a class="el" href="MeshWriter_8ih_source.html#l00135">135</a> of file <a class="el" href="MeshWriter_8ih_source.html">MeshWriter.ih</a>.</p>

<p>References <a class="el" href="MeshWriter_8ih_source.html#l00093">DGtal::MeshWriter&lt; TPoint &gt;::export2OBJ()</a>, and <a class="el" href="MeshWriter_8ih_source.html#l00047">DGtal::MeshWriter&lt; TPoint &gt;::export2OFF()</a>.</p>
<div class="fragment"><div class="line">                                                                                 {</div>
<div class="line">  <span class="keywordtype">string</span> extension = aFilename.substr(aFilename.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1);</div>
<div class="line">  ofstream out;</div>
<div class="line">  out.open(aFilename.c_str());</div>
<div class="line">  <span class="keywordflow">if</span>(extension== <span class="stringliteral">&quot;off&quot;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1MeshWriter.html#af0662c6d5b23e071d5fb5a0209190d82">DGtal::MeshWriter&lt;TPoint&gt;::export2OFF</a>(out, aMesh, <span class="keyword">true</span>);</div>
<div class="line">  }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(extension== <span class="stringliteral">&quot;obj&quot;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1MeshWriter.html#a423f57d1ef6e41e6f3bda1d7744bb96f">DGtal::MeshWriter&lt;TPoint&gt;::export2OBJ</a>(out, aMesh);</div>
<div class="line">  }</div>
<div class="line">  out.close();</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">} </div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aee8aa91a2345d8315df394b94de70f99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MeshFromPoints.html">MeshFromPoints</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'operator&gt;&gt;' for exporting objects of class '<a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a>' in OFF format.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMesh,:</td><td>the mesh to be exported. </td></tr>
    <tr><td class="paramname">out,:</td><td>the output of the OFF exportation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true, if the export was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ac53021bc0d5dc675ed32631396cac05d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a> &amp;&#160;</td>
          <td class="paramname"><em>aDisplay3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MeshFromPoints.html">DGtal::MeshFromPoints</a>&lt; <a class="el" href="structDGtal_1_1Display3D_1_1pointD3D.html">Display3D::pointD3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator "&gt;&gt;" to export a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> into a <a class="el" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">MeshFromPoints</a></p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDisplay3D,:</td><td>the <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> to be exported. </td></tr>
    <tr><td class="paramname">aMesh,:</td><td>(return) the resulting mesh. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00918">918</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>

<p>References <a class="el" href="Display3D_8ih_source.html#l00768">DGtal::Display3D::exportToMesh()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  aDisplay3D.<a class="code" href="classDGtal_1_1Display3D.html#a747f698991704bf02ae6fb6af104095f">exportToMesh</a>(aMesh);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa24e0992d0b4c61469dbf5da726718c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a> &amp;&#160;</td>
          <td class="paramname"><em>aDisplay3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>aFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator "&gt;&gt;" to export a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> directly a file</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDisplay3D,:</td><td>the <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> to be exported. </td></tr>
    <tr><td class="paramname">aMesh,:</td><td>(return) the resulting mesh. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00927">927</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>

<p>References <a class="el" href="Trace_8ih_source.html#l00211">DGtal::Trace::info()</a>, and <a class="el" href="Common_8h_source.html#l00140">trace</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="comment">// exporting with a mesh containing color (parameter constructor to true):</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1MeshFromPoints.html" title="Aim: This class is defined to represent a surface mesh through a set a vertex and a set of faces repr...">DGtal::MeshFromPoints&lt;Display3D::pointD3D&gt;</a> mesh(<span class="keyword">true</span>);</div>
<div class="line">  aDisplay3D &gt;&gt; mesh;</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; <span class="stringliteral">&quot;generating faces done.&quot;</span> &lt;&lt; endl;</div>
<div class="line">  mesh &gt;&gt; aFilename;</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; <span class="stringliteral">&quot;file exported in file: &quot;</span> &lt;&lt; aFilename &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a462eaaf587bc04ebd2e6141bed3fc21e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">197</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00222">oppositeEndMaximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">previousMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">                                                                                              {</div>
<div class="line">  <span class="comment">//extend one more time if s.begin() == begin</span></div>
<div class="line">  <span class="keywordflow">while</span> ( (s.begin() != begin)</div>
<div class="line">       &amp;&amp; (s.extendBackward()) ) {}</div>
<div class="line">  <span class="keywordflow">if</span> (s.begin() == begin) s.extendBackward();</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9f50b26bc3256332ab287e1bb2a3e7cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00208">208</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line">                                                                                                {</div>
<div class="line">  <span class="comment">//stop if the segment is the whole range</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> SC::ConstIterator newBegin( s.end() ); </div>
<div class="line">  <span class="keywordflow">while</span> ( (s.extendBackward())</div>
<div class="line">       &amp;&amp; (s.begin() != newBegin) ) {}</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a567c997ae858c829256cc8a13c04d230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls s.extendBackward() while possible </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of (bidirectional) segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00222">222</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><div class="line">                                                                               {</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; </div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>( s, begin, Type() ); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a137f26d321873e90065142afff6fa928"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalRetraction </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls s.retractBackward() while s.isExtendableBackward() returns false </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00334">334</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">previousMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) ) {</div>
<div class="line">    <span class="keywordflow">while</span> ( (! s.isExtendableBackward() ) </div>
<div class="line">          &amp;&amp;(s.retractBackward() ) ) {}  </div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">while</span> ( s.retractBackward() ) {} </div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adabb9ea04f81cba914f3ac178439ffd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>lastMaximalSegment of &ndash;s.begin() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">852</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00917">previousMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) )</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s, --s.begin(), begin, s.end(), <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8e35d35160afaea835678e7bf4a3458c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>lastMaximalSegment of &ndash;s.begin() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00868">868</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) )</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s, --s.begin(), begin, s.end(), <a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afa1f75e59b72ea5e69760c965e20b3ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">883</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00334">oppositeEndMaximalRetraction()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; </div>
<div class="line"></div>
<div class="line">  <span class="comment">//rectract</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a137f26d321873e90065142afff6fa928">oppositeEndMaximalRetraction</a>(s, begin); </div>
<div class="line"></div>
<div class="line">  <span class="comment">//intersection test</span></div>
<div class="line">  ConstIterator i( s.end() ); --i; </div>
<div class="line">  <span class="comment">//if the intersection between the two </span></div>
<div class="line">  <span class="comment">// consecutive maximal segments is empty </span></div>
<div class="line">  <span class="keywordflow">if</span> ( i == s.begin() ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i, begin) ) {</div>
<div class="line">      --i; </div>
<div class="line">      s.init(i);  </div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">//extend</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad14e74091568436294698404dc08c9c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00917">917</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{ </div>
<div class="line">  <a class="code" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a>(s, end, <a class="code" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>() ); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af03fbf680fc202a21ef0801ee9240934"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00931">931</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a>(s, begin, </div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a44d1dd3f9097cf9d2b7f280c95e34b1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt; dim &gt; DGtal::setDimensionsIn </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a bitset having true for each dimension presents in dimensions. </dd></dl>

<p>Definition at line <a class="el" href="PointVector_8ih_source.html#l00042">42</a> of file <a class="el" href="PointVector_8ih_source.html">PointVector.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  std::bitset&lt;dim&gt; t1;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">typename</span> Container::const_iterator it=dimensions.begin();</div>
<div class="line">  it!=dimensions.end(); ++it )</div>
<div class="line">    {</div>
<div class="line">      ASSERT( *it&lt;dim );</div>
<div class="line">      t1.set(*it);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> t1;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae405036e4e10cc9ecee7918e5fb10dd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt; dim &gt; DGtal::setDimensionsNotIn </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a bitset having true for each dimension not presents in dimensions. </dd></dl>

<p>Definition at line <a class="el" href="PointVector_8ih_source.html#l00056">56</a> of file <a class="el" href="PointVector_8ih_source.html">PointVector.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  std::bitset&lt;dim&gt; t1; t1.set();</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">typename</span> Container::const_iterator it=dimensions.begin();</div>
<div class="line">  it!=dimensions.end(); ++it )</div>
<div class="line">    {</div>
<div class="line">      ASSERT( *it&lt;dim );</div>
<div class="line">      t1.reset(*it);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> t1;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a202be24e94b5bdfba2d8563d0947f373"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::setFromImage </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points lying within the domain of the image <em>aImg</em> whose value (in the image) is less than or equal to <em>aThreshold</em> </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>any image </td></tr>
    <tr><td class="paramname">ito</td><td>set inserter </td></tr>
    <tr><td class="paramname">aThreshold</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a> </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00071">71</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00054">setFromPointsRangeAndFunctor()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CConstImage&lt;I&gt; )); </div>
<div class="line"></div>
<div class="line">  <span class="keyword">typename</span> I::Domain d = aImg.domain(); </div>
<div class="line">  <a class="code" href="namespaceDGtal.html#ad57d4465e40fe4c1982ec2e01985be73">setFromPointsRangeAndFunctor</a>(d.begin(), d.end(), ito, aImg, aThreshold); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aecddf53312d4b765f34a022b049627c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::setFromImage </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points lying within the domain of the image <em>aImg</em> whose value (in the image) lies between <em>low</em> and <em>up</em> (both included)</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>any image </td></tr>
    <tr><td class="paramname">ito</td><td>set inserter </td></tr>
    <tr><td class="paramname">low</td><td>lower value </td></tr>
    <tr><td class="paramname">up</td><td>upper value</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a> </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00083">83</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CConstImage&lt;I&gt; )); </div>
<div class="line">  ASSERT( low &lt; up ); </div>
<div class="line"></div>
<div class="line">  <span class="comment">//domain</span></div>
<div class="line">  <span class="keyword">typename</span> I::Domain d = aImg.domain(); </div>
<div class="line">  <span class="comment">//predicate from two thresholders and an image</span></div>
<div class="line">  <span class="keyword">typedef</span> Thresholder&lt;typename I::Value,true,false&gt; T1; </div>
<div class="line">  T1 t1( low ); </div>
<div class="line">  <span class="keyword">typedef</span> Thresholder&lt;typename I::Value,false,false&gt; T2; </div>
<div class="line">  T2 t2( up ); </div>
<div class="line">  <span class="keyword">typedef</span> PredicateCombiner&lt;T1,T2,OrBoolFct2 &gt; P; </div>
<div class="line">  P p( t1, t2, OrBoolFct2() ); </div>
<div class="line">  Composer&lt;I, P, bool&gt; aPred(aImg, p); </div>
<div class="line">  <span class="comment">//call</span></div>
<div class="line">  std::remove_copy_if(d.begin(), d.end(), ito, aPred); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad57d4465e40fe4c1982ec2e01985be73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::setFromPointsRangeAndFunctor </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>aFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename F::Value &amp;&#160;</td>
          <td class="paramname"><em>aThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points of the range [<em>itb</em> , <em>ite</em> ) such that their associated value (returned by <em>aFunctor</em> ) is less than or equal to <em>aThreshold</em> </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator on points </td></tr>
    <tr><td class="paramname">aFunctor</td><td>any functor on points </td></tr>
    <tr><td class="paramname">aThreshold</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of input iterator </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
    <tr><td class="paramname">F</td><td>any model of <a class="el" href="structDGtal_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00054">54</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>Referenced by <a class="el" href="ImageHelper_8ih_source.html#l00071">setFromImage()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CPointFunctor&lt;F&gt; )); </div>
<div class="line">  BOOST_CONCEPT_ASSERT(( boost::InputIterator&lt;I&gt; ));</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( boost::OutputIterator&lt;O,typename F::Point&gt; ));</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span> Thresholder&lt;typename F::Value,false,false&gt; T; </div>
<div class="line">  T t( aThreshold ); </div>
<div class="line">  Composer&lt;F, T, bool&gt; aPred(aFunctor, t); </div>
<div class="line">  std::remove_copy_if(itb, ite, ito, aPred); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad67647d42db11b7b3d3533e1cba6c2ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::setFromPointsRangeAndPredicate </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>aPred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>useful functions </p>
<p>Fill a set through the inserter <em>ito</em> with the points of the range [<em>itb</em> , <em>ite</em> ) such that <em>aPred</em> is true</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator on points </td></tr>
    <tr><td class="paramname">aPred</td><td>any predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of input iterator </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
    <tr><td class="paramname">P</td><td>any model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00040">40</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( CPointPredicate&lt;P&gt; )); </div>
<div class="line">  BOOST_CONCEPT_ASSERT(( boost::InputIterator&lt;I&gt; ));</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( boost::OutputIterator&lt;O,typename P::Point&gt; ));</div>
<div class="line"></div>
<div class="line">  NotPointPredicate&lt;P&gt; nPred( aPred ); </div>
<div class="line">  std::remove_copy_if(itb, ite, ito, nPred); </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9d0c060685d6e9a49445a562a99c5286"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KSpace , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::testImplicitDigitalSurface </td>
          <td>(</td>
          <td class="paramtype">const KSpace &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename KSpace::Surfel &amp;&#160;</td>
          <td class="paramname"><em>bel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">49</a> of file <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html">testImplicitDigitalSurface-benchmark.cpp</a>.</p>

<p>References <a class="el" href="Trace_8ih_source.html#l00117">DGtal::Trace::beginBlock()</a>, <a class="el" href="Trace_8ih_source.html#l00142">DGtal::Trace::endBlock()</a>, <a class="el" href="Trace_8ih_source.html#l00211">DGtal::Trace::info()</a>, and <a class="el" href="Common_8h_source.html#l00140">trace</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Point <a class="code" href="structPoint3D.html">Point</a>;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Surfel Surfel;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface&lt;KSpace,PointPredicate&gt;</a> Boundary;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::SurfelConstIterator ConstIterator;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::Tracker Tracker;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbok = 0;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb = 0;</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Testing block ... ImplicitDigitalSurface&quot;</span> );</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;ImplicitDigitalSurface instanciation&quot;</span> );</div>
<div class="line">    Boundary boundary( K, pp,</div>
<div class="line">                       <a class="code" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency&lt;KSpace::dimension&gt;</a>( <span class="keyword">true</span> ), bel,</div>
<div class="line">                       <span class="keyword">true</span> );</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Counting the number of surfels (breadth first traversal)&quot;</span> );</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbsurfels = 0;</div>
<div class="line">    <span class="keywordflow">for</span> ( ConstIterator it = boundary.begin(), it_end = boundary.end();</div>
<div class="line">          it != it_end; ++it )</div>
<div class="line">      {</div>
<div class="line">        ++nbsurfels;</div>
<div class="line">      }</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; nbsurfels &lt;&lt; <span class="stringliteral">&quot; surfels found.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    nb++, nbok += nbsurfels == 354382 ? 1 : 0;</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; nbok &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; nb &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line">                   &lt;&lt; <span class="stringliteral">&quot;nbsurfels == 354382&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();</div>
<div class="line">    <span class="keywordflow">return</span> nbok == nb;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a08886ee117009e48c66e4349c7c47265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KSpace , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::testLightImplicitDigitalSurface </td>
          <td>(</td>
          <td class="paramtype">const KSpace &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename KSpace::Surfel &amp;&#160;</td>
          <td class="paramname"><em>bel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">49</a> of file <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html">testLightImplicitDigitalSurface-benchmark.cpp</a>.</p>

<p>References <a class="el" href="Trace_8ih_source.html#l00117">DGtal::Trace::beginBlock()</a>, <a class="el" href="Trace_8ih_source.html#l00142">DGtal::Trace::endBlock()</a>, <a class="el" href="Trace_8ih_source.html#l00211">DGtal::Trace::info()</a>, and <a class="el" href="Common_8h_source.html#l00140">trace</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Point <a class="code" href="structPoint3D.html">Point</a>;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Surfel Surfel;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface&lt;KSpace,PointPredicate&gt;</a> Boundary;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::SurfelConstIterator ConstIterator;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::Tracker Tracker;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbok = 0;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb = 0;</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Testing block ... LightImplicitDigitalSurface&quot;</span> );</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;LightImplicitDigitalSurface instanciation&quot;</span> );</div>
<div class="line">    Boundary boundary( K, pp,</div>
<div class="line">                       <a class="code" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency&lt;KSpace::dimension&gt;</a>( <span class="keyword">true</span> ), bel );</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Counting the number of surfels (breadth first traversal)&quot;</span> );</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbsurfels = 0;</div>
<div class="line">    <span class="keywordflow">for</span> ( ConstIterator it = boundary.begin(), it_end = boundary.end();</div>
<div class="line">          it != it_end; ++it )</div>
<div class="line">      {</div>
<div class="line">        ++nbsurfels;</div>
<div class="line">      }</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; nbsurfels &lt;&lt; <span class="stringliteral">&quot; surfels found.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    nb++, nbok += nbsurfels == 354382 ? 1 : 0;</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; nbok &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; nb &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line">                   &lt;&lt; <span class="stringliteral">&quot;nbsurfels == 354382&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();</div>
<div class="line">    <span class="keywordflow">return</span> nbok == nb;</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a948cc02e8fe7e8ab1051bce164421fa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, Alloc&gt; DGtal::Xe_k </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial X_k^e </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the index of the variable (X_k) </td></tr>
    <tr><td class="paramname">e</td><td>the exponent for X_k </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of indetermionates. </td></tr>
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01652">1652</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1Xe__kComputer.html">Xe_kComputer&lt;n, Ring, Alloc&gt;</a>().<span class="keyword">get</span>( k, e );</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad099005ab7d493b2ea19026e2fb96a32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::Xe_k </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial X_k^e </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the index of the variable (X_k) </td></tr>
    <tr><td class="paramname">e</td><td>the exponent for X_k </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of indetermionates. </td></tr>
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01668">1668</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1Xe__kComputer.html">Xe_kComputer&lt;n, Ring, std::allocator&lt;Ring&gt;</a> &gt;().<span class="keyword">get</span>( k, e );</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a70c28100eb4618dbb59a4080cbdf383b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> DGtal::andBF2 = <a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function and (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00149">149</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Expander_8ih_source.html#l00175">DGtal::Expander&lt; TObject &gt;::computeNextLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c1454fe50af31341c890919f93b76b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">It also possible to remove the visualisation of the transparent clipping plane by adding boolean DGtal::false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="moduleDisplay3D_8dox_source.html#l00359">359</a> of file <a class="el" href="moduleDisplay3D_8dox_source.html">moduleDisplay3D.dox</a>.</p>

<p>Referenced by <a class="el" href="Board2D_8cpp_source.html#l00054">DGtal::Board2D::Board2D()</a>, <a class="el" href="DigitalSurface_8ih_source.html#l00446">DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt;::computeFace()</a>, <a class="el" href="Expander_8ih_source.html#l00060">DGtal::Expander&lt; TObject &gt;::Expander()</a>, <a class="el" href="GeometricalDCA_8ih_source.html#l00043">DGtal::GeometricalDCA&lt; TConstIterator &gt;::GeometricalDCA()</a>, <a class="el" href="GeometricalDSS_8ih_source.html#l00043">DGtal::GeometricalDSS&lt; TConstIterator &gt;::GeometricalDSS()</a>, <a class="el" href="GreedyDecomposition_8ih_source.html#l00055">DGtal::deprecated::GreedyDecomposition&lt; TSegment &gt;::SegmentIterator::SegmentIterator()</a>, <a class="el" href="Statistic_8ih_source.html#l00052">DGtal::Statistic&lt; RealNumberType &gt;::Statistic()</a>, and <a class="el" href="Surfaces_8ih_source.html#l00925">DGtal::Surfaces&lt; TKSpace &gt;::sWriteBoundary()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c0dbf38da6779899ca99fc25ec8b0be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a> DGtal::falseBF0 = <a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function (0 bool args) returning false. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00092">92</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a154eac21029f20806b646b025b6d59a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a> DGtal::identityBF1 = <a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function identity (1 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00111">111</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="af22fdd40c268d4270906236e3ce234cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> DGtal::impliesBF2 = <a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function implies (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00164">164</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31614f15cda0ab53c57cf414e48c149f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a> DGtal::notBF1 = <a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function NOT (1 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00116">116</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7df3f0545c8e59b83394c60601c122e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">It also possible to remove the visualisation of the transparent clipping plane by adding boolean DGtal::option</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="moduleDisplay3D_8dox_source.html#l00359">359</a> of file <a class="el" href="moduleDisplay3D_8dox_source.html">moduleDisplay3D.dox</a>.</p>

</div>
</div>
<a class="anchor" id="a14f119bf8a5eb80a58870ebbd33bfb07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> DGtal::orBF2 = <a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function or (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00154">154</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a604c07ec391ad12a1f3fb6479993f112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Trace.html">Trace</a> DGtal::trace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Common_8h_source.html#l00140">140</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00336">DGtal::Display3D::addPolygon()</a>, <a class="el" href="Display3D_8ih_source.html#l00250">DGtal::Display3D::addQuad()</a>, <a class="el" href="Display3D_8ih_source.html#l00293">DGtal::Display3D::addTriangle()</a>, <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00836">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::checkIntegrity()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00069">DGtal::DistanceTransformation&lt; TSpace, TPointPredicate, p, IntegerLong &gt;::checkTypesValidity()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00148">DGtal::DistanceTransformation&lt; TSpace, TPointPredicate, p, IntegerLong &gt;::computeFirstStep()</a>, <a class="el" href="VoronoiMap_8ih_source.html#l00099">DGtal::VoronoiMap&lt; TSpace, TPointPredicate, p &gt;::computeOtherSteps()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00180">DGtal::DistanceTransformation&lt; TSpace, TPointPredicate, p, IntegerLong &gt;::computeOtherSteps()</a>, <a class="el" href="ReverseDistanceTransformation_8ih_source.html#l00190">DGtal::ReverseDistanceTransformation&lt; Image, p, IntegerShort &gt;::computeSteps()</a>, <a class="el" href="ConstImageAdapter_8h_source.html#l00133">DGtal::ConstImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV &gt;::ConstImageAdapter()</a>, <a class="el" href="Display3DFactory_8ih_source.html#l00041">DGtal::Display3DFactory::draw()</a>, <a class="el" href="Display3DFactory_8ih_source.html#l00104">DGtal::Display3DFactory::drawAsFaces()</a>, <a class="el" href="MeshWriter_8ih_source.html#l00093">DGtal::MeshWriter&lt; TPoint &gt;::export2OBJ()</a>, <a class="el" href="MeshWriter_8ih_source.html#l00047">DGtal::MeshWriter&lt; TPoint &gt;::export2OFF()</a>, <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00757">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::getAverageCollisions()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00285">DGtal::SeparableMetricHelper&lt; Point, IntegerLong, p &gt;::hiddenBy()</a>, <a class="el" href="Image_8h_source.html#l00099">DGtal::Image&lt; TImageContainer &gt;::Image()</a>, <a class="el" href="ImageAdapter_8h_source.html#l00141">DGtal::ImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV, TFunctorVm1 &gt;::ImageAdapter()</a>, <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00063">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::ImageContainerByHashTree()</a>, <a class="el" href="LongvolReader_8ih_source.html#l00040">DGtal::LongvolReader&lt; TImageContainer &gt;::importLongvol()</a>, <a class="el" href="MeshReader_8ih_source.html#l00052">DGtal::MeshReader&lt; TPoint &gt;::importOFFFile()</a>, <a class="el" href="MeshReader_8ih_source.html#l00182">DGtal::MeshReader&lt; TPoint &gt;::importOFSFile()</a>, <a class="el" href="PNMReader_8ih_source.html#l00052">DGtal::PNMReader&lt; TImageContainer &gt;::importPGM()</a>, <a class="el" href="PNMReader_8ih_source.html#l00171">DGtal::PNMReader&lt; TImageContainer &gt;::importPGM3D()</a>, <a class="el" href="RawReader_8ih_source.html#l00040">DGtal::RawReader&lt; TImageContainer &gt;::importRaw8()</a>, <a class="el" href="VolReader_8ih_source.html#l00044">DGtal::VolReader&lt; TImageContainer &gt;::importVol()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00779">DGtal::Viewer3D::keyPressEvent()</a>, <a class="el" href="Board2D_8ih_source.html#l00067">DGtal::Board2D::operator&lt;&lt;()</a>, <a class="el" href="ConstImageAdapter_8h_source.html#l00146">DGtal::ConstImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV &gt;::operator=()</a>, <a class="el" href="ImageAdapter_8h_source.html#l00154">DGtal::ImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV, TFunctorVm1 &gt;::operator=()</a>, <a class="el" href="Image_8h_source.html#l00163">DGtal::Image&lt; TImageContainer &gt;::operator=()</a>, <a class="el" href="Display3D_8ih_source.html#l00927">operator&gt;&gt;()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00357">DGtal::Viewer3D::postSelection()</a>, <a class="el" href="Board3DTo2D_8cpp_source.html#l00232">DGtal::Board3DTo2D::saveCairo()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00342">DGtal::Viewer3D::sortPolygonFromCamera()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00329">DGtal::Viewer3D::sortQuadFromCamera()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00299">DGtal::Viewer3D::sortSurfelFromCamera()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00315">DGtal::Viewer3D::sortTriangleFromCamera()</a>, <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">testImplicitDigitalSurface()</a>, and <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">testLightImplicitDigitalSurface()</a>.</p>

</div>
</div>
<a class="anchor" id="ae801de7ee4d22c47257dc7e00e0c5dd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> DGtal::traceWriterTerm</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> Global variables </p>

<p>Definition at line <a class="el" href="Common_8h_source.html#l00139">139</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad0fa31bef8d6552db900af1809d787d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a> DGtal::trueBF0 = <a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function (0 bool args) returning true. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00087">87</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29281e7462720aa5d454fa2355baa0f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> DGtal::xorBF2 = <a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function xor (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00159">159</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 19 2012 19:10:46 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
