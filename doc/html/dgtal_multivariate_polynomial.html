<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: Multivariate polynomials.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.6.devel</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Multivariate polynomials. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_mpolynomial_sec1">Multivariate polynomial</a><ul><li class="level2"><a href="#dgtal_mpolynomial_sec1_1">What is a multivariate polynomial ?</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_2">The class MPolynomial</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_3">Interface of the class MPolynomial</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_4">How monomials and coefficients are stored ?</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_5">Computing partial derivatives</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_6">Computing euclidean division and greatest commond divisor (gcd)</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_mpolynomial_sec2">Efficiency considerations.</a><ul><li class="level2"><a href="#dgtal_mpolynomial_sec2_1">Best suited polynomials</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec2_2">Repetitive evaluations in space</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec3">Input and output for multivariate polynomials</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Felix Fontein (University of Zurich, <a href="http://spielwiese.fontein.de">http://spielwiese.fontein.de</a>) and adapted by Jacques-Olivier Lachaud.</dd></dl>
<p>Part of the pagePolynomialModule.</p>
<p>This part of the manual describes how to define multivariate polynomials, like \( xy^2-yz \), \( x^4-y^2z^2+z^4 \), etc.</p>
<h1><a class="anchor" id="dgtal_mpolynomial_sec1"></a>
Multivariate polynomial</h1>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_1"></a>
What is a multivariate polynomial ?</h2>
<p>A <em>multivariate</em> <em>monomial</em> is a product of powers of zero, one or several variables, like \( 1, x, x^2, xy, y^3, xy^2z, x^4y^4z^4 \). Sometimes the coefficient in front of the monomial is also included in the definition of the monomial. A <em>multivariate</em> <em>polynomial</em> is a sum of products of a coefficient with a multivariate monomial.</p>
<p>A <em>polynomial</em> is a special case of multivariate polynomial where there is only one variable. The terms <em>variable</em> and <em>indeterminate</em> are synonymous. When you define a multivariate polynomial, you must precise its number of variables. The variables are numbered from 0 to <em>n</em> - 1, if <em>n</em> is the number of variables.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_2"></a>
The class MPolynomial</h2>
<p>The class <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> is the base class for representing arbitrary multivariate polynomials, i.e. an element of \( K[X_0, ..., X_{-1}] \), where <em>K</em> is some ring. The class MPolynomial&lt;n,K&gt; is parameterized by <em>n</em>, the number of indeterminates, and by <em>K</em>, the type of the coefficients, which should be at least a ring.</p>
<p>If you wish to declare a monovariate polynomial P1(x) over the <code>int</code> ring and a 2-variate polynomial P2(x,y) over the <code>double</code> field, you write the following lines:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/math/MPolynomial.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MPolynomial&lt;1,<span class="keywordtype">int</span>&gt; P1;</div>
<div class="line">MPolynomial&lt;2,double&gt; P2;</div>
</div><!-- fragment --><p>In fact, the complete polynomial type is <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n, K, A&gt;, where A is an allocator for K, for example std::allocator&lt;K&gt;; this is also the default parameter. Usually this parameter does not needs to be changed.</p>
<p>This is implemented recursively: <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n, K&gt; is a polynomial in one indeterminate with coefficients in <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n-1, K&gt;. The last instance, <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;0, K&gt;, is essentially equal to K.</p>
<p>Generally, a multivariate polynomial is created by summing multivariate monomials and constants. The following snippet creates the 3-variate polynomial "durchblick", \( Pd(x,y,z) = x^3y+xz^3+y^3z+z^3+5z \). </p>
<div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; Pd</div>
<div class="line">= mmonomial&lt;double&gt;( 3, 1, 0 )</div>
<div class="line">+ mmonomial&lt;double&gt;( 1, 0, 3 )</div>
<div class="line">+ mmonomial&lt;double&gt;( 0, 3, 1 )</div>
<div class="line">+ mmonomial&lt;double&gt;( 0, 0, 3 )</div>
<div class="line">+ 5 * mmonomial&lt;double&gt;( 0, 0, 1 );</div>
</div><!-- fragment --><p>A constant multivariate polynomial is created simply with: </p>
<div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; Pc = 1.0;</div>
</div><!-- fragment --><p>Creation is thus accomplished using the functions mmonomial&lt;K, A&gt;(e_0, ..., e_{n-1}), where A again is std::allocator&lt;K&gt; by default. This creates a polynomial of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n, K, A&gt; which consists of exactly one monomial X_0^{e_0} * ... * X_{n-1}^{e_{n-1}} having coefficient 1.</p>
<p>Otherwise, polynomials are created through operations, derivations, etc.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_3"></a>
Interface of the class MPolynomial</h2>
<p>Let us describe the interface:</p>
<ul>
<li><a class="el" href="classDGtal_1_1MPolynomial.html#ac53389b0d7e6647f32b014ca4eaf78e5">MPolynomial::isZero</a>: Every polynomial has a predicate isZero(), testing whether the polynomial is the zero polynomial. Note that it is not the same to be a zero polynomial in <em>n</em> variables or to be a zero polynomial in <em>n'</em> variables, <em>n</em> != <em>n'</em>.</li>
<li>Moreover, it has basic arithmetic, i.e. addition, subtraction, multiplication; this is realized via operator overloading. Assignment and comparison operators are also provided.</li>
<li><a class="el" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">MPolynomial::degree</a>, <a class="el" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">MPolynomial::leading</a>: Polynomials have a degree function <code>degree()</code>, returning the degree as a polynomial in the first indeterminate, as well as a method <code>leading()</code>, returning the leading term (which is of type <code>const</code> <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a>&lt;n-1, K&gt; &amp;). Note that the degree of the zero polynomial is -1. For instance, \( 1 + xy^2 + x^4yz \) is a degree 4 polynomial in <em>x</em>. Its leading term is \( x^4yz \).</li>
</ul>
<div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; Q = mmonomial&lt;double&gt;( 0, 0, 0 )</div>
<div class="line">+ mmonomial&lt;double&gt;( 1, 2, 0 ) + mmonomial&lt;double&gt;( 4, 1, 1 );</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Q(x,y,z)=1+xy^2+x^4yz = &quot;</span> &lt;&lt; Q &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; degree = &quot;</span> &lt;&lt; Q.degree() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; leading= &quot;</span> &lt;&lt; Q.leading() &lt;&lt; std::endl;</div>
</div><!-- fragment --><pre class="fragment">Q(x,y,z)=1+xy^2+x^4yz = (1 + 1 X_1^2 X_0 + 1 X_2 X_1 X_0^4)
 degree = 4
 leading= 1 X_1 X_0
</pre><ul>
<li><p class="startli"><a class="el" href="classDGtal_1_1MPolynomial.html#a4e66d961247088815cbfde51c638ef9f">MPolynomial::operator[]</a>: The i-th coefficient can be obtained by writing f[i] if f is of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n, K&gt;; then f[i] is of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n - 1, K&gt;. In case i is larger than the degree of f, a zero polynomial will be returned, and in case f is not constant, the internal space for the coefficients will be enlarged to have space for the i-th coefficient. Note that one should call f.normalize() afterwards if one accessed f[i] for non-const f to ensure that degree and leading coefficients will be computed correctly afterwards.</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         Q[0]         = &quot;</span> &lt;&lt; Q[ 0 ] &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         Q[1]         = &quot;</span> &lt;&lt; Q[ 1 ] &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         Q[2]         = &quot;</span> &lt;&lt; Q[ 2 ] &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         Q[3]         = &quot;</span> &lt;&lt; Q[ 3 ] &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         Q[4]         = &quot;</span> &lt;&lt; Q[ 4 ] &lt;&lt; std::endl;</div>
</div><!-- fragment --><p class="startli">You may notice that Q[i] are n-1-variate polynomials, i.e., x,y stands for the former y,z variables.</p>
<pre class="fragment">         Q[0]         = 1
         Q[1]         = 1 X_0^2
         Q[2]         = 0
         Q[3]         = 0
         Q[4]         = 1 X_1 X_0</pre></li>
</ul>
<ul>
<li>MPolynomial::operator(): The polynomial can be evaluated using operator(). If f is of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n, K, A&gt;, then f(x) with x of type S will return an object of type <a class="el" href="classDGtal_1_1MPolynomialEvaluator.html">MPolynomialEvaluator</a> &lt;n, K, A, S&gt;. This object can be casted to <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n-1, S&gt; to obtain f with the first indeterminate evaluated as x. Note that S must be a type to which elements of K can be casted. One can also continue evaluating with the <a class="el" href="classDGtal_1_1MPolynomialEvaluator.html">MPolynomialEvaluator</a> &lt;n, K, A, S&gt; object, yielding <a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl.html">MPolynomialEvaluatorImpl</a> &lt;k, K, ..., A, S&gt; objects, k &lt; n. These object hierarchy ensures that polynomial evaluation is efficient, i.e. after (good enough) optimization of the compiler, is essentially a block of code of (n-k+1) nested for-loops.</li>
</ul>
<pre class="fragment">double v = Q(1)(2)(3); // evaluation at (x,y,z)=(1,2,3)
</pre><ul>
<li>Polynomials can be written to std::ostream's using operator&lt;&lt;. There is also a member function MPolynomial::selfDisplay(std::ostream &amp;) const. Note that the first indeterminate in MPolynomial&lt;n, K&gt; is denoted by X_0, and the last by X_{n-1}.</li>
</ul>
<ul>
<li>Finally, there is a method swap() to swap two polynomial's contents. The polynomials have to be of the same type.This is for instance useful in some algorithms of the STL.</li>
</ul>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_4"></a>
How monomials and coefficients are stored ?</h2>
<p>The coefficients are stored in a std::vector &lt;K&gt;; while <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;1, K&gt; uses std::vector&lt;K&gt;, <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n, K&gt; for n &gt; 1 uses std::vector &lt;<a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n-1, K&gt; *&gt;, i.e. pointers to coefficients are stored. This is implemented using the "intelligent" vector <a class="el" href="classDGtal_1_1IVector.html">IVector</a> &lt;K&gt; template.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_5"></a>
Computing partial derivatives</h2>
<p>The library also offers to compute partial derivatives. Given a polynomial f of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;n, K&gt;, one can compute the partial derivative with respect to the j-th variable of f by writing derivative &lt;j&gt;(f). Note that K is required to allow multiplication by int's for this to work.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Q(x,y,z)=1+xy^2+x^4yz = &quot;</span> &lt;&lt; Q &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; dQ/dx        = &quot;</span> &lt;&lt; derivative&lt;0&gt;(Q) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         dQ/dy        = &quot;</span> &lt;&lt; derivative&lt;1&gt;(Q) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         dQ/dz        = &quot;</span> &lt;&lt; derivative&lt;2&gt;(Q) &lt;&lt; std::endl;</div>
</div><!-- fragment --><pre class="fragment">Q(x,y,z)=1+xy^2+x^4yz = (1 + 1 X_1^2 X_0 + 1 X_2 X_1 X_0^4)
         dQ/dx        = (1 X_1^2 + 4 X_2 X_1 X_0^3) // y^2+4zyx^3
         dQ/dy        = (2 X_1 X_0 + 1 X_2 X_0^4)   // 2yx+zx^4
         dQ/dz        = 1 X_1 X_0^4                 // yx^4
</pre><p>You may have a look at example <a class="el" href="polynomial-derivative_8cpp_source.html">polynomial-derivative.cpp</a> to see how to get derivatives of simple polynomials:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/math/MPolynomial.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/MPolynomialReader.h&quot;</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> Ring;</div>
<div class="line">  <span class="keyword">typedef</span> MPolynomial&lt;1, Ring&gt; MyPolynomial;</div>
</div><!-- fragment --><div class="fragment"><div class="line">  std::string polynomialString( argv[ 1 ] );</div>
<div class="line">  std::istringstream polynomialIStream( polynomialString );</div>
<div class="line">  MyPolynomial P;</div>
<div class="line">  polynomialIStream &gt;&gt; P;</div>
<div class="line">  MyPolynomial P1 = derivative&lt;0&gt;( P );</div>
<div class="line">  MyPolynomial P2 = derivative&lt;0&gt;( P1 );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;P(X_0)   = &quot;</span> &lt;&lt; P &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;P&#39;(X_0)  = &quot;</span> &lt;&lt; P1 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;P&#39;&#39;(X_0) = &quot;</span> &lt;&lt; P2 &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Along the same lines, the example <a class="el" href="polynomial2-derivative_8cpp_source.html">polynomial2-derivative.cpp</a> computes first- and second-order partial derivatives of a 2-variate polynomial.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/math/MPolynomial.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/MPolynomialReader.h&quot;</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> Ring;</div>
<div class="line">  <span class="keyword">typedef</span> MPolynomial&lt;2, Ring&gt; MyPolynomial;</div>
</div><!-- fragment --><div class="fragment"><div class="line">  std::string polynomialString( argv[ 1 ] );</div>
<div class="line">  std::istringstream polynomialIStream( polynomialString );</div>
<div class="line">  MyPolynomial P;</div>
<div class="line">  polynomialIStream &gt;&gt; P;</div>
<div class="line">  MyPolynomial P1_0 = derivative&lt;0&gt;( P );</div>
<div class="line">  MyPolynomial P2_0 = derivative&lt;0&gt;( P1_0 );</div>
<div class="line">  MyPolynomial P0_1 = derivative&lt;1&gt;( P );</div>
<div class="line">  MyPolynomial P0_2 = derivative&lt;1&gt;( P0_1 );</div>
<div class="line">  MyPolynomial P1_1 = derivative&lt;1&gt;( P1_0 );</div>
<div class="line">  MyPolynomial P1_1b= derivative&lt;0&gt;( P0_1 );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;P(X_0,X_1)        = &quot;</span> &lt;&lt; P &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;dP/dX_0(X_0,X_1)  = &quot;</span> &lt;&lt; P1_0 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;dP/dX_1(X_0,X_1)  = &quot;</span> &lt;&lt; P0_1 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;d/dX_1 dP/dX_0(X_0,X_1) = &quot;</span> &lt;&lt; P1_1 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;d/dX_0 dP/dX_1(X_0,X_1) = &quot;</span> &lt;&lt; P1_1b &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;d/dX_0 dP/dX_0(X_0,X_1) = &quot;</span> &lt;&lt; P2_0 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;d/dX_1 dP/dX_1(X_0,X_1) = &quot;</span> &lt;&lt; P0_2 &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="dgtal_mpolynomial_sec1_6"></a>
Computing euclidean division and greatest commond divisor (gcd)</h2>
<p>Finally, there exist functions euclidDiv(f, g, q, r), requiring parameters f, g of the const <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;1, K&gt; &amp; and q, r of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;1, K&gt; &amp;. This function computes q, r of f, g such that degree(r) &lt; degree(g) and f = q*g + r, i.e. it does long division of f by g, storing the quotient in q and the remainder in r. Note that <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv()</a> only works if K is a field, or if everything appearing is divisible by g.leading().</p>
<p>There is another function, gcd(f, g), accepting f, g of type const <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;1, K&gt; &amp; and returning a <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> &lt;1, K&gt; object. It computes the monic greatest common divisor of f and g using the euclidean algorithm. In every step, the remainder is made monic. This function is ignoring potential round-off errors, and this function needs that K is (kind of) a field. Use with care.</p>
<h1><a class="anchor" id="dgtal_mpolynomial_sec2"></a>
Efficiency considerations.</h1>
<h2><a class="anchor" id="dgtal_mpolynomial_sec2_1"></a>
Best suited polynomials</h2>
<p>The class is tuned so as to be efficient for rather dense polynomials. More precisely, this class is not space nor time efficient for a polynomial like \( 1+x+x^{100000} \). This class is rather efficient for low-degree polynomials, even if there are many monomials. In fact, it factors the computation of the first variables.</p>
<p>For instance, \( x^2y^2+x^2z^2+x^4y^2z+x^4y^2z^3 \) is represented as \( x^2(1(z^2)+y^2(1))+x^4(y^2(z+z^3)) \). As one can see, \( x^2 \) is computed once, which is nice, but \( y^2 \) is computed twice. When you design a polynomial, you should choose the variable order well so as to choose the one that factors at best computations.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec2_2"></a>
Repetitive evaluations in space</h2>
<p>Consider the following simple code, which integrates some information in cubic part of the space:</p>
<div class="fragment"><div class="line">  MPolynomial&lt;3, double&gt; P = mmonomial&lt;double&gt;( 3, 1, 0 )</div>
<div class="line">    + mmonomial&lt;double&gt;( 1, 0, 3 )</div>
<div class="line">    + mmonomial&lt;double&gt;( 0, 3, 1 )</div>
<div class="line">    + mmonomial&lt;double&gt;( 0, 0, 3 )</div>
<div class="line">    + 5 * mmonomial&lt;double&gt;( 0, 0, 1 );</div>
<div class="line">  <span class="keywordtype">double</span> total = 0.0;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> x = -1.0; x &lt; 1.0; x += step )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> y = -1.0; y &lt; 1.0; y += step )</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> z = -1.0; z &lt; 1.0; z += step )</div>
<div class="line">            total += P(x)(y)(z);</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>This function takes 206ms for a step 0.01, for 8000000 evaluations.</p>
<p>In fact, you can factor evaluations of the first variables at the beginning of the inner loops. </p>
<div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; P = <span class="comment">//...</span></div>
<div class="line">  <span class="keywordtype">double</span> total1 = 0.0;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> x = -1.0; x &lt; 1.0; x += step )</div>
<div class="line">    {</div>
<div class="line">      MPolynomial&lt;2, double&gt; PX = P( x );</div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> y = -1.0; y &lt; 1.0; y += step )</div>
<div class="line">        {</div>
<div class="line">          MPolynomial&lt;1, double&gt; PXY = PX( y );</div>
<div class="line">          <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> z = -1.0; z &lt; 1.0; z += step )</div>
<div class="line">            total1 += PXY( z );</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>This function takes 69ms for a step 0.01, for 8000000 evaluations. The C version where the function is explicitely compiled takes 22ms.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec3"></a>
Input and output for multivariate polynomials</h2>
<p>You may simply output a polynomial an output stream with the usual operator&lt;&lt;.</p>
<div class="fragment"><div class="line">MPolynomial&lt;3,int&gt; Q = mmonomial&lt;int&gt;(0,0,0) + mmonomial&lt;int&gt;(1,2,0) + mmonomial&lt;int&gt;(4,1,1);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Q(x,y,z)=1+xy^2+x^4yz = &quot;</span> &lt;&lt; Q &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>You may also input a polynomial from an input stream with the usual operator&gt;&gt;. However, it is required to include file "MPolynomialReader.h".</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/MPolynomialReader.h&quot;</span></div>
<div class="line">...</div>
<div class="line">string s = <span class="stringliteral">&quot;1+xy^2+x^4yz&quot;</span>.</div>
<div class="line">std::istringstream sin( s );</div>
<div class="line">MPolynomial&lt;3,int&gt; P;</div>
<div class="line">sin &gt;&gt; P;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; <span class="stringliteral">&quot;- Read &quot;</span> &lt;&lt; P &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>You may read successively several polynomials from the input stream: you just have to separate them with newlines. The input stream is read as long as the input is valid for the multivariate polynomial grammar.</p>
<p>If you wish to handle better error recovery when creating a polynomial, you can use the method MPolynomialReader::read directly. You may look at example <a class="el" href="polynomial-read_8cpp_source.html">polynomial-read.cpp</a> for a more concrete example.</p>
<p>In input, you may write the variables either simply <code>x</code>, <code>y</code>, <code>z</code>, <code>t</code> for the first four variables, or more generically <code>X_0</code>, <code>X_1</code>, , <code>X_m</code>, where <code>m</code> is an integer number that is smaller than the number of variables of the polynomial.</p>
<p>For instance, you may test <a class="el" href="polynomial-derivative_8cpp_source.html">polynomial-derivative.cpp</a> and <a class="el" href="polynomial2-derivative_8cpp_source.html">polynomial2-derivative.cpp</a> as follows:</p>
<pre class="fragment">$ ./examples/math/polynomial-derivative "1+x+x^2-3*x^4"
P(X_0)   = (1 + 1 X_0 + 1 X_0^2 + -3 X_0^4)
P'(X_0)  = (1 + 2 X_0 + -12 X_0^3)
P''(X_0) = (2 + -36 X_0^2)
$ ./examples/math/polynomial-derivative "(2 + -36 X_0^2)"
P(X_0)   = (2 + -36 X_0^2)
P'(X_0)  = -72 X_0
P''(X_0) = -72
</pre><pre class="fragment">$ ./examples/math/polynomial2-derivative "(x-3)^2 + (y-2)^2 - 4"
P(X_0,X_1)        = ((9 + -4 X_1 + 1 X_1^2) + -6 X_0 + 1 X_0^2)
dP/dX_0(X_0,X_1)  = (-6 + 2 X_0)
dP/dX_1(X_0,X_1)  = (-4 + 2 X_1)
d/dX_1 dP/dX_0(X_0,X_1) = 0
d/dX_0 dP/dX_1(X_0,X_1) = 0
d/dX_0 dP/dX_0(X_0,X_1) = 2
d/dX_1 dP/dX_1(X_0,X_1) = 2
</pre><dl class="section see"><dt>See also:</dt><dd><a class="el" href="polynomial-read_8cpp_source.html">polynomial-read.cpp</a>, <a class="el" href="polynomial-derivative_8cpp_source.html">polynomial-derivative.cpp</a>, <a class="el" href="polynomial2-derivative_8cpp_source.html">polynomial2-derivative.cpp</a>. </dd>
<dd>
<a class="el" href="trackImplicitPolynomialSurfaceToOFF_8cpp_source.html">trackImplicitPolynomialSurfaceToOFF.cpp</a>. </dd>
<dd>
<a class="el" href="testMPolynomial_8cpp_source.html">testMPolynomial.cpp</a>, <a class="el" href="testMPolynomialReader_8cpp_source.html">testMPolynomialReader.cpp</a>. </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 19 2012 19:10:45 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
