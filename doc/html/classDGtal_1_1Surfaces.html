<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: DGtal::Surfaces&lt; TKSpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.6.devel</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::Surfaces&lt; TKSpace &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae254510c81f339dbb5bd4b33ed9f5f3e"><td class="memItemLeft" align="right" valign="top">typedef TKSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a></td></tr>
<tr class="memitem:a91dd49aa1b8c90ceaf595448ce30ebb3"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a></td></tr>
<tr class="memitem:ab58accd9ff51d3cb85f7f4d7e7ed80c5"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a></td></tr>
<tr class="memitem:a6e02ccfe37b82b2d278d066161f4d1d2"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Cell&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a></td></tr>
<tr class="memitem:a5eaebd043923d70cecb81470431be557"><td class="memItemLeft" align="right" valign="top">typedef KSpace::SCell&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a></td></tr>
<tr class="memitem:aea3655c1310aed70fc5fcedaef454d21"><td class="memItemLeft" align="right" valign="top">typedef KSpace::DirIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a40685150ee27be46185eed33b49582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a4a40685150ee27be46185eed33b49582">~Surfaces</a> ()</td></tr>
<tr class="memitem:a80771c760a6b1ae094343a2e8011dad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a80771c760a6b1ae094343a2e8011dad3">selfDisplay</a> (std::ostream &amp;out) const </td></tr>
<tr class="memitem:a93d3b1bb0ae25b25a2f02b32096c8ea4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a93d3b1bb0ae25b25a2f02b32096c8ea4">isValid</a> () const </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab7cb9762acdb10a8e91ac27f936c7ff9"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:ab7cb9762acdb10a8e91ac27f936c7ff9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ab7cb9762acdb10a8e91ac27f936c7ff9">findABel</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const PointPredicate &amp;pp, unsigned int nbtries=1000)  throw (DGtal::InputException)</td></tr>
<tr class="memitem:a8108a13a0e55b8b218a4b94ba6b9bebf"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a8108a13a0e55b8b218a4b94ba6b9bebf"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a8108a13a0e55b8b218a4b94ba6b9bebf">findABel</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const PointPredicate &amp;pp, <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x1, <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x2)</td></tr>
<tr class="memitem:a24fcfb2a607d919c84250bc9965cb86b"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a24fcfb2a607d919c84250bc9965cb86b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a24fcfb2a607d919c84250bc9965cb86b">trackBoundary</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:ae917f93333eb382dd285d660388c9ba7"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:ae917f93333eb382dd285d660388c9ba7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ae917f93333eb382dd285d660388c9ba7">trackClosedBoundary</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a997c3b0bfec1b627a9822d4a1352f4ba"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:a997c3b0bfec1b627a9822d4a1352f4ba"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a997c3b0bfec1b627a9822d4a1352f4ba">trackSurface</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a08c4dba52a1b96479aec48d646f4d469"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:a08c4dba52a1b96479aec48d646f4d469"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a08c4dba52a1b96479aec48d646f4d469">trackClosedSurface</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a4b4a4cd531b56d91d0ec1931f81b3884"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a4b4a4cd531b56d91d0ec1931f81b3884"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a4b4a4cd531b56d91d0ec1931f81b3884">track2DBoundary</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:adc9eb26aaad975e24dc43045b7e926e1"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:adc9eb26aaad975e24dc43045b7e926e1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#adc9eb26aaad975e24dc43045b7e926e1">track2DSliceBoundary</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;trackDir, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a158d2fa1b8d32e7a48452cb6efb3044a"><td class="memTemplParams" colspan="2">template&lt;typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:a158d2fa1b8d32e7a48452cb6efb3044a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a158d2fa1b8d32e7a48452cb6efb3044a">track2DSurface</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;sp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a64703c857b00eea04d5b3fc4323437cc"><td class="memTemplParams" colspan="2">template&lt;typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:a64703c857b00eea04d5b3fc4323437cc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a64703c857b00eea04d5b3fc4323437cc">track2DSliceSurface</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;trackDir, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;sp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:aeea1a2dc0f7d5c3c86028f2643290486"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:aeea1a2dc0f7d5c3c86028f2643290486"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aeea1a2dc0f7d5c3c86028f2643290486">track2DBoundaryPoints</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &amp;aVectorOfPoints, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a6b5d23e7d194d2c22d97de7853723d20"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a6b5d23e7d194d2c22d97de7853723d20"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a6b5d23e7d194d2c22d97de7853723d20">extractAllPointContours4C</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &gt; &amp;aVectPointContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; 2 &gt; &amp;aSAdj)</td></tr>
<tr class="memitem:a5565d229014c6d68ad32d64ad69e6eaf"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a5565d229014c6d68ad32d64ad69e6eaf"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a5565d229014c6d68ad32d64ad69e6eaf">extractAll2DSCellContours</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;aVectSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp)</td></tr>
<tr class="memitem:a7c70171234046344fa0b089373424171"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a7c70171234046344fa0b089373424171"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a7c70171234046344fa0b089373424171">extractAllConnectedSCell</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;aVectConnectedSCell, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp, bool forceOrientCellExterior=<a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a>)</td></tr>
<tr class="memitem:a29fc6a36477080451c0951082ec7a456"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a29fc6a36477080451c0951082ec7a456"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a29fc6a36477080451c0951082ec7a456">orientSCellExterior</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aVectOfSCell, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp)</td></tr>
<tr class="memitem:a77140694e5697b73346f9e7e0e1a52fa"><td class="memTemplParams" colspan="2">template&lt;typename CellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a77140694e5697b73346f9e7e0e1a52fa"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a77140694e5697b73346f9e7e0e1a52fa">uMakeBoundary</a> (CellSet &amp;aBoundary, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="memitem:ad00979785283bbf3ac3767016f9f759f"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:ad00979785283bbf3ac3767016f9f759f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ad00979785283bbf3ac3767016f9f759f">sMakeBoundary</a> (SCellSet &amp;aBoundary, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="memitem:a051a425aad5367ebf261d774e2d8244a"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a051a425aad5367ebf261d774e2d8244a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a051a425aad5367ebf261d774e2d8244a">uWriteBoundary</a> (OutputIterator &amp;out_it, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="memitem:aec4221c2c86b9a35cda45fa6da5a2de9"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename PointPredicate &gt; </td></tr>
<tr class="memitem:aec4221c2c86b9a35cda45fa6da5a2de9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aec4221c2c86b9a35cda45fa6da5a2de9">sWriteBoundary</a> (OutputIterator &amp;out_it, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af256c2b3c2af32a9b20e011748382e1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#af256c2b3c2af32a9b20e011748382e1b">Surfaces</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8cab7368470487cee8c10921739f5f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a8cab7368470487cee8c10921739f5f23">Surfaces</a> (const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;other)</td></tr>
<tr class="memitem:a31d72cf1ccdf33632636c890e5816d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a31d72cf1ccdf33632636c890e5816d1d">operator=</a> (const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;other)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TKSpace&gt;<br/>
class DGtal::Surfaces&lt; TKSpace &gt;</h3>

<p>Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells). </p>
<p>Description of template class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a>' </p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the type of cellular grid space (e.g. a <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>).</td></tr>
  </table>
  </dd>
</dl>
<p>Note that many methods requires a surfel adjacency so as to know how connected surfels are linked (first by the interior or first by the exterior). Secondly, many methods are parameterized by a PointPredicate which describes the shape as a characteristic function. This is to be more generic than a simple DigitalSet. With this approach, shapes can be defined implicitly.</p>
<p>Essentially a backport from <a href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="topology_23dKSSurfaceExtraction_8cpp-example.html#_a3">topology/3dKSSurfaceExtraction.cpp</a>, <a class="el" href="topology_2ctopo-2-3d_8cpp-example.html#_a14">topology/ctopo-2-3d.cpp</a>, <a class="el" href="topology_2ctopo-2_8cpp-example.html#_a11">topology/ctopo-2.cpp</a>, <a class="el" href="topology_2volScanBoundary_8cpp-example.html#_a9">topology/volScanBoundary.cpp</a>, <a class="el" href="topology_2volToOFF_8cpp-example.html#_a12">topology/volToOFF.cpp</a>, and <a class="el" href="topology_2volTrackBoundary_8cpp-example.html#_a10">topology/volTrackBoundary.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00078">78</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a6e02ccfe37b82b2d278d066161f4d1d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Cell <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00085">85</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="aea3655c1310aed70fc5fcedaef454d21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::DirIterator <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00087">87</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91dd49aa1b8c90ceaf595448ce30ebb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Integer <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00083">83</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae254510c81f339dbb5bd4b33ed9f5f3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TKSpace <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00082">82</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab58accd9ff51d3cb85f7f4d7e7ed80c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Point <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00084">84</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5eaebd043923d70cecb81470431be557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::SCell <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00086">86</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4a40685150ee27be46185eed33b49582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::~<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00056">56</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af256c2b3c2af32a9b20e011748382e1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Forbidden by default (protected to avoid g++ warnings). </p>

</div>
</div>
<a class="anchor" id="a8cab7368470487cee8c10921739f5f23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone. Forbidden by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5565d229014c6d68ad32d64ad69e6eaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAll2DSCellContours </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSurfelAdj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract all contours as a vector containing the set of contours composed of SCell. Each contour is represented by a vector of signed surfels whose elements represents a boundary component of a digital shape defined by the predicate [pp]. The algorithms tracks surfels along the boundary of the shape.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of contour represented by a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00649">649</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  std::set&lt;SCell&gt; bdry;</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#ad00979785283bbf3ac3767016f9f759f">sMakeBoundary</a>( bdry, aKSpace, pp, </div>
<div class="line">                 aKSpace.lowerBound(), aKSpace.upperBound() );</div>
<div class="line">  aVectSCellContour2D.clear();</div>
<div class="line">  <span class="keywordflow">while</span>( ! bdry.empty() )</div>
<div class="line">    {</div>
<div class="line">      std::vector&lt;SCell&gt; aContour;</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> aCell = *(bdry.begin()); </div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a4b4a4cd531b56d91d0ec1931f81b3884">track2DBoundary</a>( aContour, aKSpace, aSurfelAdj, pp, aCell );</div>
<div class="line">      aVectSCellContour2D.push_back( aContour );</div>
<div class="line">      <span class="comment">// removing cells from boundary;</span></div>
<div class="line">      <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; aContour.size(); i++ )</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> sc = aContour.at(i);</div>
<div class="line">          bdry.erase(sc);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7c70171234046344fa0b089373424171"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAllConnectedSCell </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectConnectedSCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSurfelAdj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceOrientCellExterior</em> = <code><a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract all surfel elements associated to each connected components of the given DigitalSet. The connected surfel set are given as result in a vector containing all components. The orientation of the resulting SCell indicates the exterior orientation according the positive axis.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectConnectedSCell</td><td>(modified) a vector containing for each connected components a vector of the sequence of connected SCells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">forceOrientCellExterior</td><td>if 'true', used to change the default cell orientation in order to get the direction of shape exterior (default =false). This is used only for displaying cells with <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>. This mechanism should evolve shortly. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00701">701</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  set&lt;SCell&gt; bdry;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#ad00979785283bbf3ac3767016f9f759f">sMakeBoundary</a>( bdry, aKSpace, pp,</div>
<div class="line">                 aKSpace.lowerBound(), aKSpace.upperBound() );</div>
<div class="line">  aVectConnectedSCell.clear();</div>
<div class="line">  <span class="keywordflow">while</span>(!bdry.empty()){</div>
<div class="line">    set&lt;SCell&gt;  aConnectedSCellSet;</div>
<div class="line">    <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> aCell = *(bdry.begin()); </div>
<div class="line">    <a class="code" href="classDGtal_1_1Surfaces.html#a24fcfb2a607d919c84250bc9965cb86b">trackBoundary</a>(aConnectedSCellSet, aKSpace, aSurfelAdj, pp, aCell );</div>
<div class="line">    <span class="comment">//transform into vector&lt;SCell&gt;</span></div>
<div class="line">    vector&lt;SCell&gt; vCS;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">typename</span> set&lt;SCell&gt;::iterator it = aConnectedSCellSet.begin(); it!= aConnectedSCellSet.end(); ++it){</div>
<div class="line">      vCS.push_back(*it); </div>
<div class="line">      <span class="comment">// removing cells from boundary;      </span></div>
<div class="line">      bdry.erase(*it);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>(forceOrientCellExterior){</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a29fc6a36477080451c0951082ec7a456">orientSCellExterior</a>(vCS, aKSpace, pp);</div>
<div class="line">    }</div>
<div class="line">    aVectConnectedSCell.push_back(vCS);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6b5d23e7d194d2c22d97de7853723d20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAllPointContours4C </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectPointContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSAdj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts all the boundaries of a 2D shape (specified by a predicate on point) in a 2D KSpace. The boundaries are returned as a vector of vector of points.</p>
<p>Extract all 4-connected contours as a vector containing the sequence of contour Points. Each contour is represented by a vector of points defined by the sequence of pointels extracted from the boundary surfels. Calls extractAll2DSCellContours.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectPointContour2D</td><td>(modified) a vector of contour represented by a vector of cells (which are all surfels), containing the ordered list of the boundary component of [pp].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aSAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00738">738</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  aVectPointContour2D.clear();</div>
<div class="line">  </div>
<div class="line">  std::vector&lt; std::vector&lt;SCell&gt; &gt; vectContoursBdrySCell;</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5565d229014c6d68ad32d64ad69e6eaf">extractAll2DSCellContours</a>( vectContoursBdrySCell,</div>
<div class="line">                             aKSpace, aSAdj, pp );</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; vectContoursBdrySCell.size(); i++){</div>
<div class="line">    std::vector&lt; Point &gt; aContour;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt; vectContoursBdrySCell.at(i).size(); j++){</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> sc = vectContoursBdrySCell.at(i).at(j);</div>
<div class="line">      <span class="keywordtype">float</span> x = (float) </div>
<div class="line">        ( <a class="code" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits&lt;typename TKSpace::Integer&gt;::castToInt64_t</a>( sc.myCoordinates[0] ) &gt;&gt; 1 );</div>
<div class="line">      <span class="keywordtype">float</span> y = (float) </div>
<div class="line">        ( <a class="code" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits&lt;typename TKSpace::Integer&gt;::castToInt64_t</a>( sc.myCoordinates[1] ) &gt;&gt; 1 );</div>
<div class="line">      <span class="keywordtype">bool</span> xodd = ( sc.myCoordinates[ 0 ] &amp; 1 );</div>
<div class="line">      <span class="keywordtype">bool</span> yodd = ( sc.myCoordinates[ 1 ] &amp; 1 );</div>
<div class="line">      <span class="keywordtype">double</span> x0 = !xodd ? x  - 0.5 : (!aKSpace.sSign(sc)? x  - 0.5: x  + 0.5) ;</div>
<div class="line">      <span class="keywordtype">double</span> y0 = !yodd ? y  - 0.5 : (!aKSpace.sSign(sc)? y  - 0.5: y + 0.5);</div>
<div class="line">      <span class="keywordtype">double</span> x1 = !xodd ? x  - 0.5 : (aKSpace.sSign(sc)? x  - 0.5: x  + 0.5) ;</div>
<div class="line">      <span class="keywordtype">double</span> y1 = !yodd ? y  - 0.5 : (aKSpace.sSign(sc)? y  - 0.5: y  + 0.5);      </div>
<div class="line">      </div>
<div class="line">      <a class="code" href="structPoint3D.html">Point</a> ptA((<span class="keyword">const</span> <span class="keywordtype">int</span>)(x0+0.5), (<span class="keyword">const</span> <span class="keywordtype">int</span>)(y0-0.5));</div>
<div class="line">      <a class="code" href="structPoint3D.html">Point</a> ptB((<span class="keyword">const</span> <span class="keywordtype">int</span>)(x1+0.5), (<span class="keyword">const</span> <span class="keywordtype">int</span>)(y1-0.5)) ;</div>
<div class="line">      aContour.push_back(ptA);</div>
<div class="line">      <span class="keywordflow">if</span>(sc== vectContoursBdrySCell.at(i).at(vectContoursBdrySCell.at(i).size()-1)){</div>
<div class="line">        aContour.push_back(ptB);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    aVectPointContour2D.push_back(aContour);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab7cb9762acdb10a8e91ac27f936c7ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::findABel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nbtries</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="classDGtal_1_1InputException.html">DGtal::InputException</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a bel in some digital set by random tries then dichotomy.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">nbries</td><td>the maximum number of random tries (default 1000).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>a signed surfel separating a digital point in [dset] from a face adjacent digital point outside [dset] or throws an <a class="el" href="classDGtal_1_1InputException.html">InputException</a> if none was found after [nbtries] iterations. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00065">65</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1InputException.html">DGtal::InputException</a> dgtalerror;</div>
<div class="line">  <a class="code" href="structPoint3D.html">Point</a> sizes = K.upperBound() - K.lowerBound();</div>
<div class="line">  <a class="code" href="structPoint3D.html">Point</a> x1 = K.lowerBound();</div>
<div class="line">  <a class="code" href="structPoint3D.html">Point</a> x2;</div>
<div class="line">  <span class="comment">// (1) Find two candidates in the space.</span></div>
<div class="line">  <span class="keywordtype">bool</span> val_v1 = pp( x1 ); <span class="comment">// dset.find( x1 ) != dset.end();</span></div>
<div class="line">  <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a> r;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nbtries; ++j )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )</div>
<div class="line">  {</div>
<div class="line">    r = rand();</div>
<div class="line">    x2[ i ] = ( r % sizes[ i ] ) + K.min( i );</div>
<div class="line">  }</div>
<div class="line">      <span class="keywordtype">bool</span> val_v2 = pp( x2 ); <span class="comment">// dset.find( x2 ) != dset.end();</span></div>
<div class="line">      <span class="keywordflow">if</span> ( val_v2 != val_v1 )</div>
<div class="line">        {</div>
<div class="line">          found = <span class="keyword">true</span>;</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">if</span> ( ! found ) <span class="keywordflow">throw</span> dgtalerror;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1Surfaces.html#ab7cb9762acdb10a8e91ac27f936c7ff9">findABel</a>( K, pp, x1, x2 );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8108a13a0e55b8b218a4b94ba6b9bebf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::findABel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a>&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a bel in some digital set given two hints (one point inside, one point outside).</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">x1</td><td>a point within the bounds of K and such that pp( x1 ) != pp( x2 ).</td></tr>
    <tr><td class="paramname">x2</td><td>a point within the bounds of K and such that pp( x1 ) != pp( x2 ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>a signed surfel separating a digital point in [dset] from a face adjacent digital point outside [dset] or throws an <a class="el" href="classDGtal_1_1InputException.html">InputException</a> if none was found after [nbtries] iterations. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00102">102</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));</div>
<div class="line">  <span class="comment">// (1) Checks the two candidates in the space.</span></div>
<div class="line">  <span class="keywordtype">bool</span> val_v1 = pp( x1 ); <span class="comment">// dset.find( x1 ) != dset.end();</span></div>
<div class="line">  ASSERT( val_v1 != pp( x2 ) );</div>
<div class="line">  <span class="comment">// (2) Find two candidates on the same axis.</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> d = 0;</div>
<div class="line">  <span class="keywordtype">bool</span> alreadyOnSameAxis = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> ( x1[ i ] != x2[ i ] )</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> j = i + 1; j &lt; K.dimension; ++j )</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">if</span> ( x1[ j ] != x2[ j ] )</div>
<div class="line">                {</div>
<div class="line">                  alreadyOnSameAxis = <span class="keyword">false</span>;</div>
<div class="line">                  <a class="code" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a> c = x2[ j ];</div>
<div class="line">                  x2[ j ] = x1[ j ];</div>
<div class="line">                  <span class="keywordtype">bool</span> val_v2 = pp( x2 ); <span class="comment">// dset.find( x2 ) != dset.end();</span></div>
<div class="line">                  <span class="keywordflow">if</span> ( val_v2 != val_v1 )</div>
<div class="line">                    { <span class="comment">// v2 is updated.</span></div>
<div class="line">                      d = i;</div>
<div class="line">                    }</div>
<div class="line">                  <span class="keywordflow">else</span></div>
<div class="line">                    { <span class="comment">// v1 is updated.</span></div>
<div class="line">                      x1 = x2;</div>
<div class="line">                      x2[ j ] = c;</div>
<div class="line">                      d = j;</div>
<div class="line">                    }</div>
<div class="line">                } <span class="comment">// if ( x1[ j ] != x2[ j ] )</span></div>
<div class="line">            } <span class="comment">// for ( Dimension j = i + 1; j &lt; K.dimension; ++j )</span></div>
<div class="line">          <span class="keywordflow">if</span> ( alreadyOnSameAxis )</div>
<div class="line">            d = i;</div>
<div class="line">        } <span class="comment">// if ( x1[ i ] != x2[ i ] )</span></div>
<div class="line">    } <span class="comment">// for ( Dimension i = 0; i &lt; K.dimension; ++i )</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// (3) Check result.</span></div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> ( ( i == d ) &amp;&amp; ( x1[ i ] == x2[ i ] ) )</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 1a along &quot;</span> </div>
<div class="line">                  &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">if</span> ( ( i != d ) &amp;&amp; ( x1[ i ] != x2[ i ] ) )</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 1b along &quot;</span></div>
<div class="line">                  &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// (4) Dichotomy</span></div>
<div class="line">  <a class="code" href="structPoint3D.html">Point</a> xmid = x1;</div>
<div class="line">  <span class="keywordflow">while</span> ( <span class="keyword">true</span> )</div>
<div class="line">    {</div>
<div class="line">      xmid[ d ] = ( x1[ d ] + x2[ d ] ) / 2;</div>
<div class="line">      <span class="keywordflow">if</span> ( ( xmid[ d ] == x1[ d ] ) || ( xmid[ d ] == x2[ d ] ) )</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordtype">bool</span> val_mid = pp( xmid ); <span class="comment">// dset.find( xmid ) != dset.end();</span></div>
<div class="line">      <span class="keywordflow">if</span> ( val_mid != val_v1 )</div>
<div class="line">        x2[ d ] = xmid[ d ];</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        x1[ d ] = xmid[ d ];</div>
<div class="line">    }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// (5) Check result.</span></div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// std::cerr &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; x1=&quot; &lt;&lt; x1[ i ] &lt;&lt; &quot; x2=&quot; &lt;&lt; x2[ i ]</span></div>
<div class="line">      <span class="comment">//     &lt;&lt; std::endl;</span></div>
<div class="line">      <span class="keywordflow">if</span> ( ( i == d ) &amp;&amp; ( x1[ i ] != x2[ i ] - 1 ) )</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 2a along &quot;</span> </div>
<div class="line">                  &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">if</span> ( ( i != d ) &amp;&amp; ( x1[ i ] != x2[ i ] ) )</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 2a along &quot;</span></div>
<div class="line">                  &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// (6) Computes bel.</span></div>
<div class="line">  <span class="keywordflow">if</span> ( val_v1 )</div>
<div class="line">    <span class="keywordflow">return</span> K.sIncident( K.sSpel( x1, K.POS ), d, true );</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> K.sIncident( K.sSpel( x1, K.NEG ), d, true );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a93d3b1bb0ae25b25a2f02b32096c8ea4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the validity/consistency of the object. </p>
<dl class="section return"><dt>Returns:</dt><dd>'true' if the object is valid, 'false' otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l01017">1017</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a31d72cf1ccdf33632636c890e5816d1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&amp; <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>a reference on 'this'. Forbidden by default. </dd></dl>

</div>
</div>
<a class="anchor" id="a29fc6a36477080451c0951082ec7a456"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::orientSCellExterior </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectOfSCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Orient the SCell positively in the direction of the exterior of the DigitalSet aShape. It simply check if the direct incident Cell in the first upper dimension (obtain with sDirectIncident) belongs to the DigitalSet or not.</p>
<p>This method is used to change the default cell orientation in order to get the direction of shape exterior (default =false). This is used only for displaying cells with <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>. This mechanism should evolve shortly.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectOfSCell</td><td>(modified) a vector containing the SCell to be oriented positively in the direction of the exterior.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00679">679</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">                                                                                                    {</div>
<div class="line">  <span class="keywordflow">for</span>( <span class="keyword">typename</span> vector&lt;SCell&gt;::iterator it = aVectOfSCell.begin();</div>
<div class="line">       it!=aVectOfSCell.end(); it++){</div>
<div class="line">    <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> incidUpperDim = aKSpace.sDirectIncident(*it, aKSpace.sOrthDir(*it)); </div>
<div class="line">    <span class="keywordflow">if</span>( pp( aKSpace.sCoords(incidUpperDim) )){</div>
<div class="line">      aKSpace.sSetSign (*it, !aKSpace.sDirect(*it, aKSpace.sOrthDir(*it)) ); </div>
<div class="line">    }<span class="keywordflow">else</span>{</div>
<div class="line">      aKSpace.sSetSign (*it, aKSpace.sDirect(*it, !aKSpace.sOrthDir(*it)) ); </div>
<div class="line">    }  </div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a80771c760a6b1ae094343a2e8011dad3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::selfDisplay </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes/Displays the object on an output stream. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l01005">1005</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;[Surfaces]&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad00979785283bbf3ac3767016f9f759f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::sMakeBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>aBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a set of signed surfels whose elements represents all the boundary components of a digital shape described by the predicate [pp].</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;). </td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aBoundary</td><td>(modified) a set of cells (which are all surfels), the boundary component of [aSpelSet].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space. </td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00859">859</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;</div>
<div class="line">  <span class="keywordtype">bool</span> in_here, in_further;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_low_uid = aKSpace.uSpel( aLowerBound );</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_up_uid = aKSpace.uGetDecr( aKSpace.uSpel( aUpperBound ), k);</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> p = dir_low_uid;</div>
<div class="line">      <span class="keywordflow">do</span> </div>
<div class="line">        {</div>
<div class="line">          in_here = pp( aKSpace.uCoords(p) );</div>
<div class="line">          in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );</div>
<div class="line">          <span class="keywordflow">if</span> ( in_here != in_further ) <span class="comment">// boundary element</span></div>
<div class="line">            { <span class="comment">// add it to the set.</span></div>
<div class="line">              aBoundary.insert( aKSpace.sIncident( aKSpace.signs( p, in_here ),</div>
<div class="line">                                                   k, true ));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">while</span> ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aec4221c2c86b9a35cda45fa6da5a2de9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::sWriteBoundary </td>
          <td>(</td>
          <td class="paramtype">OutputIterator &amp;&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes on the output iterator <em>out_it</em> the signed surfels whose elements represents all the boundary elements of a digital shape described by the predicate [pp].</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIterator</td><td>any output iterator (like std::back_insert_iterator&lt; std::vector&lt;SCell&gt; &gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_it</td><td>any output iterator for writing the signed cells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00925">925</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="moduleDisplay3D_8dox_source.html#l00359">DGtal::false</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k;</div>
<div class="line">  <span class="comment">// bool in_here, in_further;</span></div>
<div class="line">  <span class="keywordtype">bool</span> in_here, in_before;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Space <a class="code" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Space</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain&lt;Space&gt;</a> <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Domain</a>;</div>
<div class="line">  std::vector&lt; Dimension &gt; axes( aKSpace.dimension ); </div>
<div class="line">  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )</div>
<div class="line">    axes[ k ] = k;</div>
<div class="line">  <span class="comment">// We look for surfels in every direction.</span></div>
<div class="line">  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// When looking for surfels, the visiting must follow the k-th</span></div>
<div class="line">      <span class="comment">// axis first so as to reuse the predicate &quot;pp( p )&quot;.</span></div>
<div class="line">      std::swap( axes[ 0 ], axes[ k ] );</div>
<div class="line">      <a class="code" href="structPoint3D.html">Point</a> low = aLowerBound; ++low[ k ];</div>
<div class="line">      <a class="code" href="structPoint3D.html">Point</a> up = aUpperBound;</div>
<div class="line">      Domain domain( low, up );</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a> x = low[ k ];</div>
<div class="line">      <span class="keyword">typename</span> Domain::ConstSubRange range = domain.subRange( axes );</div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keyword">typename</span> Domain::ConstSubRange::ConstIterator</div>
<div class="line">              it = range.begin(), it_end = range.end();</div>
<div class="line">            it != it_end; ++it )</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="structPoint3D.html">Point</a> &amp; p = *it;</div>
<div class="line">          <span class="keywordflow">if</span> ( p[ k ] == x)</div>
<div class="line">            {</div>
<div class="line">              in_here = pp( p );</div>
<div class="line">              <a class="code" href="structPoint3D.html">Point</a> p2( p ); --p2[ k ];</div>
<div class="line">              in_before = pp( p2 );</div>
<div class="line">            }</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            { </div>
<div class="line">              in_before = in_here;</div>
<div class="line">              in_here = pp( p );</div>
<div class="line">            }</div>
<div class="line">          <span class="keywordflow">if</span> ( in_here != in_before ) <span class="comment">// boundary element</span></div>
<div class="line">            { <span class="comment">// writes it into the output iterator.</span></div>
<div class="line">              *out_it++ = aKSpace.sIncident( aKSpace.sSpel( p, in_here ),</div>
<div class="line">                                             k, <a class="code" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a> );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// for ( k = 0; k &lt; aKSpace.dimension; ++k )</span></div>
<div class="line">  <span class="comment">//   {</span></div>
<div class="line">  <span class="comment">//     Cell dir_low_uid = aKSpace.uSpel( aLowerBound );</span></div>
<div class="line">  <span class="comment">//     Cell dir_up_uid = aKSpace.uGetDecr( aKSpace.uSpel( aUpperBound ), k);</span></div>
<div class="line">  <span class="comment">//     Cell p = dir_low_uid;</span></div>
<div class="line">  <span class="comment">//     do </span></div>
<div class="line">  <span class="comment">//       {</span></div>
<div class="line">  <span class="comment">//         in_here = pp( aKSpace.uCoords(p) );</span></div>
<div class="line">  <span class="comment">//         in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );</span></div>
<div class="line">  <span class="comment">//         if ( in_here != in_further ) // boundary element</span></div>
<div class="line">  <span class="comment">//           { // writes it into the output iterator.</span></div>
<div class="line">  <span class="comment">//             *out_it++ = aKSpace.sIncident( aKSpace.signs( p, in_here ),</span></div>
<div class="line">  <span class="comment">//                                            k, true );</span></div>
<div class="line">  <span class="comment">//           }</span></div>
<div class="line">  <span class="comment">//       }</span></div>
<div class="line">  <span class="comment">//     while ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );</span></div>
<div class="line">  <span class="comment">//   }</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4b4a4cd531b56d91d0ec1931f81b3884"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DBoundary </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts the boundary of a 2D shape (specified by a predicate on point) in a 2D KSpace. The boundary is returned as a vector of surfels. The surfels are guaranteed to be in the direct orientation ordering.</p>
<p>Creates a vector of signed surfels whose elements represents a 2D boundary component of a digital shape described by a PointPredicate. The algorithm tracks surfels along the boundary of the shape by starting from the given [start_surfel]. It only tracks the boundary of a 2D shape.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00345">345</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00350">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));</div>
<div class="line">  ASSERT( K.dimension == 2 );</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b= start_surfel;  <span class="comment">// current surfel</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span></div>
<div class="line">  ASSERT( K.sIsSurfel( start_surfel ) );</div>
<div class="line">  <span class="comment">// std::set&lt;SCell&gt; setSurface;</span></div>
<div class="line">  <span class="comment">// setSurface.insert(start_surfel);</span></div>
<div class="line">  aSCellContour2D.clear(); <span class="comment">// boundary being extracted.</span></div>
<div class="line">  aSCellContour2D.push_back(start_surfel);</div>
<div class="line">  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">  <span class="comment">// search along indirect orientation.</span></div>
<div class="line">  <span class="keywordtype">bool</span> hasPrevNeighbor =  <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">while</span> ( hasPrevNeighbor )</div>
<div class="line">    {</div>
<div class="line">      hasPrevNeighbor=<span class="keyword">false</span>;</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *(K.sDirs( b ));</div>
<div class="line">      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">      <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir,  </div>
<div class="line">                                           ! K.sDirect( b, track_dir ) ) )</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> ( bn != start_surfel )</div>
<div class="line">            <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span></div>
<div class="line">            {</div>
<div class="line">              hasPrevNeighbor=<span class="keyword">true</span>;</div>
<div class="line">              aSCellContour2D.push_back( bn );</div>
<div class="line">              <span class="comment">// setSurface.insert(bn);</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      b = bn;</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// since the contour is not necessary closed we search in the other direction.</span></div>
<div class="line">  reverse(aSCellContour2D.begin(), aSCellContour2D.end());</div>
<div class="line">  <span class="keywordflow">if</span> ( b != start_surfel )</div>
<div class="line">    { <span class="comment">// the contour is necessarily open.</span></div>
<div class="line">      b = start_surfel; </div>
<div class="line">      <span class="keywordtype">bool</span> hasNextNeighbor =  <span class="keyword">true</span>;</div>
<div class="line">      <span class="keywordflow">while</span> ( hasNextNeighbor )</div>
<div class="line">        {</div>
<div class="line">          hasNextNeighbor=<span class="keyword">false</span>;</div>
<div class="line">          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *(K.sDirs( b ));</div>
<div class="line">          SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, </div>
<div class="line">                                               K.sDirect( b, track_dir ) ) )</div>
<div class="line">            {</div>
<div class="line">              <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span></div>
<div class="line">              <span class="comment">// {</span></div>
<div class="line">              aSCellContour2D.push_back( bn );</div>
<div class="line">              hasNextNeighbor=<span class="keyword">true</span>;</div>
<div class="line">              <span class="comment">// setSurface.insert(bn);</span></div>
<div class="line">              <span class="comment">// }</span></div>
<div class="line">            }</div>
<div class="line">          b=bn;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeea1a2dc0f7d5c3c86028f2643290486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DBoundaryPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectorOfPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts the boundary of a 2D shape (specified by a predicate on point) in a 2D KSpace. The boundary is returned as a vector of points.</p>
<p>This method uses random tries to find a first linel separating an interior pixel from an exterior one. It then follows direct orientations to extract the 4-connected set of points.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectorOfPoints</td><td>(returns) the sequence of points of the boundary component of the digitized shape containing [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00618">618</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  aVectorOfPoints.clear();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Getting the consecutive surfels of the 2D boundary</span></div>
<div class="line">  std::vector&lt;SCell&gt; vectBdrySCell;</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a4b4a4cd531b56d91d0ec1931f81b3884">Surfaces&lt;KSpace&gt;::track2DBoundary</a>( vectBdrySCell,</div>
<div class="line">                                     K, surfel_adj, pp, start_surfel );</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;SCell&gt;::const_iterator SCellConstIterator;</div>
<div class="line">  <span class="keywordflow">for</span> ( SCellConstIterator it = vectBdrySCell.begin(),</div>
<div class="line">          it_end = vectBdrySCell.end(); </div>
<div class="line">        it != it_end; ++it )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track = *( K.sDirs( *it ) );</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> pointel = K.sIndirectIncident( *it, track );</div>
<div class="line">      aVectorOfPoints.push_back( K.sCoords( pointel ) );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adc9eb26aaad975e24dc43045b7e926e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DSliceBoundary </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;&#160;</td>
          <td class="paramname"><em>trackDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a 2D slice of the boundary of a nD shape (specified by a predicate on point) in a nD KSpace. The boundary is returned as a vector of surfels. The surfels are guaranteed to be in the direct orientation ordering.</p>
<p>Creates a vector of signed surfels whose elements represents a 2D boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape by starting from the given [start_surfel], along the direction specified by [trackDir]. More precisely, it is the boundary of the slice of the shape along directions [trackDir] and the orthogonal direction of [start_surfel].</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space (dimension is arbitrary).</td></tr>
    <tr><td class="paramname">trackDir</td><td>the initial track direction at [start_surfel], should be different from the orthogonal direction of [start_surfel].</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00417">417</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00350">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b= start_surfel;  <span class="comment">// current surfel</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span></div>
<div class="line">  ASSERT( K.sIsSurfel( start_surfel ) );</div>
<div class="line">  <span class="comment">// std::set&lt;SCell&gt; setSurface;</span></div>
<div class="line">  <span class="comment">// setSurface.insert(start_surfel);</span></div>
<div class="line">  aSCellContour2D.clear(); <span class="comment">// boundary being extracted.</span></div>
<div class="line">  aSCellContour2D.push_back(start_surfel);</div>
<div class="line">  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> orthDir = K.sOrthDir( start_surfel );</div>
<div class="line">  <span class="keywordtype">bool</span> hasPrevNeighbor =  <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">while</span> ( hasPrevNeighbor )</div>
<div class="line">    {</div>
<div class="line">      hasPrevNeighbor=<span class="keyword">false</span>;</div>
<div class="line">      <span class="comment">// search a tracking direction compatible with track/orth direction</span></div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = K.sOrthDir( b ) == orthDir ? trackDir : orthDir;</div>
<div class="line">      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">      <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir,</div>
<div class="line">                                           !K.sDirect( b, track_dir ) ) )</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> ( bn != start_surfel )</div>
<div class="line">            <span class="comment">//    if ( setSurface.find( bn ) == setSurface.end() )</span></div>
<div class="line">            {</div>
<div class="line">              hasPrevNeighbor=<span class="keyword">true</span>;</div>
<div class="line">              aSCellContour2D.push_back( bn );</div>
<div class="line">              <span class="comment">// setSurface.insert(bn);</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      b = bn;</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// since the contour is not necessary closed we search in the other direction.</span></div>
<div class="line">  reverse(aSCellContour2D.begin(), aSCellContour2D.end());</div>
<div class="line">  <span class="keywordflow">if</span> ( b != start_surfel )</div>
<div class="line">    { <span class="comment">// the contour is necessarily open.</span></div>
<div class="line">      b = start_surfel; </div>
<div class="line">      <span class="keywordtype">bool</span> hasNextNeighbor =  <span class="keyword">true</span>;</div>
<div class="line">      <span class="keywordflow">while</span> ( hasNextNeighbor )</div>
<div class="line">        {</div>
<div class="line">          hasNextNeighbor=<span class="keyword">false</span>;</div>
<div class="line">          <span class="comment">// search a tracking direction compatible with constant direction</span></div>
<div class="line">          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = K.sOrthDir( b ) == orthDir ? trackDir : orthDir;</div>
<div class="line">          SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, </div>
<div class="line">                                               K.sDirect( b, track_dir ) ) )</div>
<div class="line">            {</div>
<div class="line">              <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span></div>
<div class="line">              <span class="comment">// {</span></div>
<div class="line">              aSCellContour2D.push_back( bn );</div>
<div class="line">              <span class="comment">// setSurface.insert(bn);</span></div>
<div class="line">              hasNextNeighbor=<span class="keyword">true</span>;</div>
<div class="line">              <span class="comment">// }</span></div>
<div class="line">            }</div>
<div class="line">          b=bn;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a64703c857b00eea04d5b3fc4323437cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DSliceSurface </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;&#160;</td>
          <td class="paramname"><em>trackDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a 2D slice of a n-1 digital surface (specified by a predicate on surfel) in a nD KSpace. The boundary is returned as a vector of surfels. The surfels (of dimension n-1) are guaranteed to be in the direct orientation ordering.</p>
<p>Creates a vector of signed surfels whose elements represents a component of a slice of digital surface described by a SurfelPredicate. The algorithm tracks surfels along the surface by starting from the given <em>start_surfel</em> and by moving along the directions <em>trackDir</em> and the orthogonal direction to <em>start_surfel</em>. All surfels are returned so as to follow the direct orientation. If the surface is open, the first surfel is at one extremity (the indirect extremity) while the last surfel is at the other extremity. Otherwise, the first surfel is <em>start_surfel</em>.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a>, meaning a functor taking a Surfel (SCell) and returning 'true' whenever the surfel belongs to the digital surface. Models include <a class="el" href="classDGtal_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">FrontierPredicate</a> and <a class="el" href="classDGtal_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">BoundaryPredicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of surfels that forms the connected component of the digital surface slice containing surfel <em>start_surfel</em> and the direction <em>trackDir</em>.</td></tr>
    <tr><td class="paramname">K</td><td>any space (dimension is arbitrary).</td></tr>
    <tr><td class="paramname">trackDir</td><td>the initial track direction at [start_surfel], should be different from the orthogonal direction of [start_surfel].</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">sp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a>, for instance a <a class="el" href="classDGtal_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">FrontierPredicate</a> or a <a class="el" href="classDGtal_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">BoundaryPredicate</a>.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel such that sp(start_surfel) is true. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00552">552</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00414">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnSurfelPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate&lt;SurfelPredicate&gt;</a> ));</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b= start_surfel;  <span class="comment">// current surfel</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span></div>
<div class="line">  ASSERT( K.sIsSurfel( start_surfel ) );</div>
<div class="line">  aSCellContour.clear(); <span class="comment">// boundary being extracted.</span></div>
<div class="line">  aSCellContour.push_back(start_surfel);</div>
<div class="line">  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> orthDir = K.sOrthDir( start_surfel );</div>
<div class="line">  <span class="keywordtype">bool</span> hasPrevNeighbor =  <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">while</span> ( hasPrevNeighbor )</div>
<div class="line">    {</div>
<div class="line">      hasPrevNeighbor=<span class="keyword">false</span>;</div>
<div class="line">      <span class="comment">// search a tracking direction compatible with track/orth direction</span></div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = K.sOrthDir( b ) == orthDir ? trackDir : orthDir;</div>
<div class="line">      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">      <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir,</div>
<div class="line">                                            !K.sDirect( b, track_dir ) ) )</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> ( bn != start_surfel )</div>
<div class="line">            {</div>
<div class="line">              hasPrevNeighbor=<span class="keyword">true</span>;</div>
<div class="line">              aSCellContour.push_back( bn );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      b = bn;</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// since the contour is not necessary closed we search in the other direction.</span></div>
<div class="line">  reverse( aSCellContour.begin(), aSCellContour.end() );</div>
<div class="line">  <span class="keywordflow">if</span> ( b != start_surfel )</div>
<div class="line">    { <span class="comment">// the contour is necessarily open.</span></div>
<div class="line">      b = start_surfel; </div>
<div class="line">      <span class="keywordtype">bool</span> hasNextNeighbor =  <span class="keyword">true</span>;</div>
<div class="line">      <span class="keywordflow">while</span> ( hasNextNeighbor )</div>
<div class="line">        {</div>
<div class="line">          hasNextNeighbor=<span class="keyword">false</span>;</div>
<div class="line">          <span class="comment">// search a tracking direction compatible with constant direction</span></div>
<div class="line">          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = K.sOrthDir( b ) == orthDir ? trackDir : orthDir;</div>
<div class="line">          SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir, </div>
<div class="line">                                                K.sDirect( b, track_dir ) ) )</div>
<div class="line">            {</div>
<div class="line">              aSCellContour.push_back( bn );</div>
<div class="line">              hasNextNeighbor=<span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">          b=bn;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a158d2fa1b8d32e7a48452cb6efb3044a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DSurface </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a 1d-contour (specified by a predicate on surfel) in a 2D KSpace. The boundary is returned as a vector of surfels. The surfels are guaranteed to be in the direct orientation ordering.</p>
<p>Creates a vector of signed surfels whose elements represents a component of a digital surface described by a SurfelPredicate. The algorithm tracks surfels along the surface by starting from the given <em>start_surfel</em>. All surfels are returned so as to follow the direct orientation. If the surface is open, the first surfel is at one extremity (the indirect extremity) while the last surfel is at the other extremity. Otherwise, the first surfel is <em>start_surfel</em>.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a>, meaning a functor taking a Surfel (SCell) and returning 'true' whenever the surfel belongs to the digital surface. Models include <a class="el" href="classDGtal_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">FrontierPredicate</a> and <a class="el" href="classDGtal_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">BoundaryPredicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of surfels that forms the connected component containing surfel [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">sp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a>, for instance a <a class="el" href="classDGtal_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">FrontierPredicate</a> or a <a class="el" href="classDGtal_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">BoundaryPredicate</a>.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel such that sp(start_surfel) is true. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00489">489</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00414">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnSurfelPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate&lt;SurfelPredicate&gt;</a> ));</div>
<div class="line">  ASSERT( KSpace::dimension == 2 );</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b= start_surfel;  <span class="comment">// current surfel</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span></div>
<div class="line">  ASSERT( K.sIsSurfel( start_surfel ) );</div>
<div class="line">  aSCellContour.clear(); <span class="comment">// boundary being extracted.</span></div>
<div class="line">  aSCellContour.push_back(start_surfel);</div>
<div class="line">  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">  <span class="comment">// search along indirect orientation.</span></div>
<div class="line">  <span class="keywordtype">bool</span> hasPrevNeighbor =  <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">while</span> ( hasPrevNeighbor )</div>
<div class="line">    {</div>
<div class="line">      hasPrevNeighbor=<span class="keyword">false</span>;</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *(K.sDirs( b ));</div>
<div class="line">      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">      <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir,  </div>
<div class="line">                                            ! K.sDirect( b, track_dir ) ) )</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> ( bn != start_surfel )</div>
<div class="line">            {</div>
<div class="line">              hasPrevNeighbor=<span class="keyword">true</span>;</div>
<div class="line">              aSCellContour.push_back( bn );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      b = bn;</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// since the contour is not necessary closed we search in the other direction.</span></div>
<div class="line">  reverse( aSCellContour.begin(), aSCellContour.end() );</div>
<div class="line">  <span class="keywordflow">if</span> ( b != start_surfel )</div>
<div class="line">    { <span class="comment">// the contour is necessarily open.</span></div>
<div class="line">      b = start_surfel; </div>
<div class="line">      <span class="keywordtype">bool</span> hasNextNeighbor =  <span class="keyword">true</span>;</div>
<div class="line">      <span class="keywordflow">while</span> ( hasNextNeighbor )</div>
<div class="line">        {</div>
<div class="line">          hasNextNeighbor=<span class="keyword">false</span>;</div>
<div class="line">          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *(K.sDirs( b ));</div>
<div class="line">          SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir, </div>
<div class="line">                                                K.sDirect( b, track_dir ) ) )</div>
<div class="line">            {</div>
<div class="line">              aSCellContour.push_back( bn );</div>
<div class="line">              hasNextNeighbor=<span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">          b=bn;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a24fcfb2a607d919c84250bc9965cb86b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts the boundary of a nD digital shape (specified by a predicate on point), closed or open, in a nD KSpace. The boundary is returned as a set of surfels.</p>
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00191">191</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00350">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span></div>
<div class="line">  ASSERT( K.sIsSurfel( start_surfel ) );</div>
<div class="line">  surface.clear(); <span class="comment">// boundary being extracted.</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );</div>
<div class="line">  std::queue&lt;SCell&gt; qbels;</div>
<div class="line">  qbels.push( start_surfel );</div>
<div class="line">  surface.insert( start_surfel );</div>
<div class="line">  <span class="comment">// For all pending bels</span></div>
<div class="line">  <span class="keywordflow">while</span> ( ! qbels.empty() )</div>
<div class="line">    {</div>
<div class="line">      b = qbels.front();</div>
<div class="line">      qbels.pop();</div>
<div class="line">      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;</div>
<div class="line">          <span class="comment">// ----- 1st pass with positive orientation ------</span></div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, <span class="keyword">true</span> ) )</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )</div>
<div class="line">                {</div>
<div class="line">                  surface.insert( bn );</div>
<div class="line">                  qbels.push( bn );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">          <span class="comment">// ----- 2nd pass with negative orientation ------</span></div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, <span class="keyword">false</span> ) )</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )</div>
<div class="line">                {</div>
<div class="line">                  surface.insert( bn );</div>
<div class="line">                  qbels.push( bn );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span></div>
<div class="line">    } <span class="comment">// while ( ! qbels.empty() )</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae917f93333eb382dd285d660388c9ba7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackClosedBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts the <b>closed</b> boundary of a nD digital shape (specified by a predicate on point), in a nD KSpace. The boundary is returned as a set of surfels.</p>
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape. It follows only direct orientations, so that it is faster than trackBoundary but requires the object to be fully inside the space. Follows the idea of Artzy, Frieder and Herman algorithm [Artzy:1981-cgip], but in nD.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00782">782</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00350">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span></div>
<div class="line">  ASSERT( K.sIsSurfel( start_surfel ) );</div>
<div class="line">  surface.clear(); <span class="comment">// boundary being extracted.</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );</div>
<div class="line">  std::queue&lt;SCell&gt; qbels;</div>
<div class="line">  qbels.push( start_surfel );</div>
<div class="line">  surface.insert( start_surfel );</div>
<div class="line">  <span class="comment">// For all pending bels</span></div>
<div class="line">  <span class="keywordflow">while</span> ( ! qbels.empty() )</div>
<div class="line">    {</div>
<div class="line">      b = qbels.front();</div>
<div class="line">      qbels.pop();</div>
<div class="line">      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;</div>
<div class="line">          <span class="comment">// ----- One pass, look for direct orientation ------</span></div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, </div>
<div class="line">                                               K.sDirect( b, track_dir ) ) )</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )</div>
<div class="line">                {</div>
<div class="line">                  surface.insert( bn );</div>
<div class="line">                  qbels.push( bn );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span></div>
<div class="line">    } <span class="comment">// while ( ! qbels.empty() )</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a08c4dba52a1b96479aec48d646f4d469"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename SurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackClosedSurface </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a <b>closed</b> n-1 digital surface (specified by a predicate on surfel) in a nD KSpace. The surface is returned as a set of surfels.</p>
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital surface described by a SurfelPredicate. The algorithms tracks surfels along the surface. This is an optimized version of trackSurface, which is valid only when the tracked surface is closed.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">SurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a> describing whether a surfel belongs or not to the surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">sp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a>.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be part of the surface, ie. 'sp(start_surfel)==true'. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00298">298</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00414">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnSurfelPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate&lt;SurfelPredicate&gt;</a> ));</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span></div>
<div class="line">  ASSERT( K.sIsSurfel( start_surfel ) );</div>
<div class="line">  surface.clear(); <span class="comment">// boundary being extracted.</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );</div>
<div class="line">  std::queue&lt;SCell&gt; qbels;</div>
<div class="line">  qbels.push( start_surfel );</div>
<div class="line">  surface.insert( start_surfel );</div>
<div class="line">  <span class="comment">// For all pending bels</span></div>
<div class="line">  <span class="keywordflow">while</span> ( ! qbels.empty() )</div>
<div class="line">    {</div>
<div class="line">      b = qbels.front();</div>
<div class="line">      qbels.pop();</div>
<div class="line">      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;</div>
<div class="line">          <span class="comment">// ----- direct orientation ------</span></div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir, </div>
<div class="line">                                                K.sDirect( b, track_dir ) ) )</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )</div>
<div class="line">                {</div>
<div class="line">                  surface.insert( bn );</div>
<div class="line">                  qbels.push( bn );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span></div>
<div class="line">    } <span class="comment">// while ( ! qbels.empty() )</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a997c3b0bfec1b627a9822d4a1352f4ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename SurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackSurface </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a n-1 digital surface (specified by a predicate on surfel), closed or open, in a nD KSpace. The surface is returned as a set of surfels.</p>
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital surface described by a SurfelPredicate. The algorithms tracks surfels along the surface.</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">SurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a> describing whether a surfel belongs or not to the surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">sp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a>.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be part of the surface, ie. 'sp(start_surfel)==true'. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00244">244</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00414">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnSurfelPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate&lt;SurfelPredicate&gt;</a> ));</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span></div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span></div>
<div class="line">  ASSERT( K.sIsSurfel( start_surfel ) );</div>
<div class="line">  surface.clear(); <span class="comment">// boundary being extracted.</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;</div>
<div class="line">  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );</div>
<div class="line">  std::queue&lt;SCell&gt; qbels;</div>
<div class="line">  qbels.push( start_surfel );</div>
<div class="line">  surface.insert( start_surfel );</div>
<div class="line">  <span class="comment">// For all pending bels</span></div>
<div class="line">  <span class="keywordflow">while</span> ( ! qbels.empty() )</div>
<div class="line">    {</div>
<div class="line">      b = qbels.front();</div>
<div class="line">      qbels.pop();</div>
<div class="line">      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );</div>
<div class="line">      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;</div>
<div class="line">          <span class="comment">// ----- 1st pass with positive orientation ------</span></div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir, <span class="keyword">true</span> ) )</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )</div>
<div class="line">                {</div>
<div class="line">                  surface.insert( bn );</div>
<div class="line">                  qbels.push( bn );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">          <span class="comment">// ----- 2nd pass with negative orientation ------</span></div>
<div class="line">          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir, <span class="keyword">false</span> ) )</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )</div>
<div class="line">                {</div>
<div class="line">                  surface.insert( bn );</div>
<div class="line">                  qbels.push( bn );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span></div>
<div class="line">    } <span class="comment">// while ( ! qbels.empty() )</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a77140694e5697b73346f9e7e0e1a52fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename CellSet , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::uMakeBoundary </td>
          <td>(</td>
          <td class="paramtype">CellSet &amp;&#160;</td>
          <td class="paramname"><em>aBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a set of unsigned surfels whose elements represents all the boundary components of a digital shape described by the predicate [pp].</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CellSet</td><td>a model of a set of Cell (e.g., std::set&lt;Cell&gt;). </td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">aBoundary</td><td>(modified) a set of cells (which are all surfels), the boundary component of [aSpelSet].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space. </td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00826">826</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;</div>
<div class="line">  <span class="keywordtype">bool</span> in_here, in_further;</div>
<div class="line">  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_low_uid = aKSpace.uSpel( aLowerBound );</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_up_uid = aKSpace.uGetDecr( aKSpace.uSpel( aUpperBound ), k);</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> p = dir_low_uid;</div>
<div class="line">      <span class="keywordflow">do</span> </div>
<div class="line">        {</div>
<div class="line">          in_here = pp( aKSpace.uCoords(p) );</div>
<div class="line">          in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );</div>
<div class="line">          <span class="keywordflow">if</span> ( in_here != in_further ) <span class="comment">// boundary element</span></div>
<div class="line">            { <span class="comment">// add it to the set.</span></div>
<div class="line">              aBoundary.insert( aKSpace.uIncident( p, k, <span class="keyword">true</span> ));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">while</span> ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a051a425aad5367ebf261d774e2d8244a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::uWriteBoundary </td>
          <td>(</td>
          <td class="paramtype">OutputIterator &amp;&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes on the output iterator <em>out_it</em> the unsigned surfels whose elements represents all the boundary elements of a digital shape described by the predicate [pp].</p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIterator</td><td>any output iterator (like std::back_insert_iterator&lt; std::vector&lt;Cell&gt; &gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_it</td><td>any output iterator for writing the cells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00893">893</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;</div>
<div class="line">  <span class="keywordtype">bool</span> in_here, in_further;</div>
<div class="line">  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_low_uid = aKSpace.uSpel( aLowerBound );</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_up_uid = aKSpace.uGetDecr( aKSpace.uSpel( aUpperBound ), k);</div>
<div class="line">      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> p = dir_low_uid;</div>
<div class="line">      <span class="keywordflow">do</span> </div>
<div class="line">        {</div>
<div class="line">          in_here = pp( aKSpace.uCoords(p) );</div>
<div class="line">          in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );</div>
<div class="line">          <span class="keywordflow">if</span> ( in_here != in_further ) <span class="comment">// boundary element</span></div>
<div class="line">            { <span class="comment">// writes it into the output iterator.</span></div>
<div class="line">              *out_it++ = aKSpace.uIncident( p, k, <span class="keyword">true</span> );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">while</span> ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Surfaces_8h_source.html">Surfaces.h</a></li>
<li><a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 19 2012 19:10:59 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
